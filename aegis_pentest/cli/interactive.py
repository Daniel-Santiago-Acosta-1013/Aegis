"""
Modo interactivo simplificado para acceso directo a herramientas
"""

from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.table import Table
from rich import box
from rich.progress import Progress, SpinnerColumn, TextColumn
import asyncio
from datetime import datetime


from aegis_pentest.tools import (
    NmapWrapper, NucleiWrapper, GobusterWrapper, NiktoWrapper, 
    SqlMapWrapper, SSLAnalyzer, FfufWrapper, ZapWrapper,
    ShodanWrapper, TracerouteWrapper, W3afWrapper, CensysWrapper
)
from aegis_pentest.utils.logger import get_logger


class InteractiveMode:
    """Modo interactivo simplificado para acceso directo a herramientas"""
    
    def __init__(self, console: Console, scanner, display):
        self.console = console
        self.scanner = scanner
        self.display = display
        self.logger = get_logger(console)
        
        # Inicializar herramientas disponibles
        self.tools = {
            'nmap': {'wrapper': NmapWrapper, 'name': 'Nmap', 'desc': 'Escaneo de puertos y servicios'},
            'nuclei': {'wrapper': NucleiWrapper, 'name': 'Nuclei', 'desc': 'Detector de vulnerabilidades'},
            'gobuster': {'wrapper': GobusterWrapper, 'name': 'Gobuster', 'desc': 'Fuerza bruta de directorios'},
            'nikto': {'wrapper': NiktoWrapper, 'name': 'Nikto', 'desc': 'Esc√°ner web de vulnerabilidades'},
            'sqlmap': {'wrapper': SqlMapWrapper, 'name': 'SQLMap', 'desc': 'Detecci√≥n de inyecci√≥n SQL'},
            'ssl': {'wrapper': SSLAnalyzer, 'name': 'SSL Analyzer', 'desc': 'An√°lisis de certificados SSL/TLS'},
            'ffuf': {'wrapper': FfufWrapper, 'name': 'FFUF', 'desc': 'Fuzzer web r√°pido'},
            'shodan': {'wrapper': ShodanWrapper, 'name': 'Shodan', 'desc': 'Motor de b√∫squeda de dispositivos'},
            'traceroute': {'wrapper': TracerouteWrapper, 'name': 'Traceroute', 'desc': 'Rastreo de rutas de red'},
            'w3af': {'wrapper': W3afWrapper, 'name': 'W3AF', 'desc': 'Framework de auditor√≠a web'},
            'censys': {'wrapper': CensysWrapper, 'name': 'Censys', 'desc': 'Motor de b√∫squeda de internet'}
        }
    
    async def run(self):
        """Ejecuta el modo interactivo simplificado"""
        self.console.print(Panel(
            "[bold cyan]üõ†Ô∏è  MODO INTERACTIVO - HERRAMIENTAS AVANZADAS[/bold cyan]\n"
            "Acceso directo a todas las herramientas de pentesting",
            border_style="cyan"
        ))
        
        while True:
            choice = self._show_tools_menu()
            
            if choice == "back":
                break
            elif choice in self.tools:
                await self._use_tool(choice)
    
    def _show_tools_menu(self) -> str:
        """Muestra el men√∫ de herramientas disponibles"""
        table = Table(title="üõ†Ô∏è Herramientas Disponibles", box=box.ROUNDED)
        table.add_column("Opci√≥n", style="cyan", min_width=3)
        table.add_column("Herramienta", style="bold white")
        table.add_column("Descripci√≥n", style="dim white")
        table.add_column("Estado", style="green", justify="center")
        
        # Mapeo de keys a nombres de herramientas en config
        tool_config_names = {
            'nmap': 'nmap',
            'nuclei': 'nuclei', 
            'gobuster': 'gobuster',
            'nikto': 'nikto',
            'sqlmap': 'sqlmap',
            'ssl': 'openssl',  # SSL Analyzer usa OpenSSL
            'ffuf': 'ffuf',
            'shodan': 'shodan',
            'traceroute': 'traceroute',
            'w3af': 'w3af_console',
            'censys': 'censys'
        }
        
        choices = []
        for key, tool_info in self.tools.items():
            try:
                # Usar el config del scanner para verificar disponibilidad
                config_name = tool_config_names.get(key, key)
                available = self.scanner.config.is_tool_available(config_name)
                
                status = "‚úÖ Listo" if available else "‚ùå No disponible"
                table.add_row(key, tool_info['name'], tool_info['desc'], status)
                if available:
                    choices.append(key)
            except Exception as e:
                table.add_row(key, tool_info['name'], tool_info['desc'], "‚ùì Error")
                self.logger.log_tool_output("interactive", f"Error verificando {key}: {str(e)}", True)
        
        table.add_row("back", "Volver", "Regresar al men√∫ principal", "")
        choices.append("back")
        
        self.console.print(table)
        self.console.print()
        
        choice = Prompt.ask(
            "[bold yellow]Selecciona una herramienta[/bold yellow]",
            choices=choices,
            default="back"
        )
        
        return choice
    
    async def _use_tool(self, tool_key: str):
        """Usar una herramienta espec√≠fica"""
        tool_info = self.tools[tool_key]
        
        self.console.print(Panel(
            f"[bold cyan]üîß {tool_info['name']}[/bold cyan]\n"
            f"{tool_info['desc']}",
            border_style="cyan"
        ))
        
        # Llamar al m√©todo espec√≠fico para cada herramienta
        if tool_key == 'nmap':
            await self._use_nmap()
        elif tool_key == 'nuclei':
            await self._use_nuclei()
        elif tool_key == 'gobuster':
            await self._use_gobuster()
        elif tool_key == 'nikto':
            await self._use_nikto()
        elif tool_key == 'sqlmap':
            await self._use_sqlmap()
        elif tool_key == 'ssl':
            await self._use_ssl_analyzer()
        elif tool_key == 'ffuf':
            await self._use_ffuf()
        elif tool_key == 'shodan':
            await self._use_shodan()
        elif tool_key == 'traceroute':
            await self._use_traceroute()
        elif tool_key == 'w3af':
            await self._use_w3af()
        elif tool_key == 'censys':
            await self._use_censys()
    
    async def _use_nmap(self):
        """Interfaz para usar Nmap con recomendaciones"""
        nmap = NmapWrapper(self.scanner.config)
        
        # Solicitar objetivo
        target = Prompt.ask(
            "[bold cyan]üéØ Objetivo (IP/dominio/red)[/bold cyan]",
            default="scanme.nmap.org"
        )
        
        # Recomendaciones de puertos frecuentes
        self.console.print(Panel(
            "[bold yellow]üí° Puertos Frecuentes Recomendados[/bold yellow]\n\n"
            "‚Ä¢ [cyan]80,443[/cyan] - HTTP/HTTPS (Servicios web)\n"
            "‚Ä¢ [cyan]21,22[/cyan] - FTP/SSH (Servicios de transferencia)\n"
            "‚Ä¢ [cyan]25,587,993,995[/cyan] - SMTP/Email\n"
            "‚Ä¢ [cyan]53[/cyan] - DNS\n"
            "‚Ä¢ [cyan]139,445[/cyan] - SMB (Compartici√≥n Windows)\n"
            "‚Ä¢ [cyan]3389[/cyan] - RDP (Escritorio remoto)\n"
            "‚Ä¢ [cyan]1433,3306,5432[/cyan] - Bases de datos (SQL Server, MySQL, PostgreSQL)\n"
            "‚Ä¢ [cyan]8080,8443,8000[/cyan] - Servicios web alternativos\n"
            "‚Ä¢ [cyan]1-1000[/cyan] - Puertos m√°s comunes\n"
            "‚Ä¢ [cyan]1-65535[/cyan] - Escaneo completo (lento)",
            title="Recomendaciones de Puertos",
            border_style="yellow"
        ))
        
        ports = Prompt.ask(
            "[bold cyan]üîå Puertos a escanear[/bold cyan]",
            default="1-1000"
        )
        
        # Opciones avanzadas
        detect_os = Confirm.ask("[cyan]¬øDetectar sistema operativo? (-O)[/cyan]", default=False)
        detect_services = Confirm.ask("[cyan]¬øDetectar versiones de servicios? (-sV)[/cyan]", default=True)
        stealth = Confirm.ask("[cyan]¬øUsar modo sigiloso? (-sS)[/cyan]", default=True)
        
        if Confirm.ask(f"[yellow]¬øEjecutar escaneo Nmap en {target}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Nmap",
                    "Target": target,
                    "Puertos": ports,
                    "Detectar OS": "S√≠" if detect_os else "No",
                    "Detectar Servicios": "S√≠" if detect_services else "No",
                    "Modo Sigiloso": "S√≠" if stealth else "No",
                    "Tipo de Escaneo": "Comprensivo con detecci√≥n OS" if detect_os else "B√°sico con detecci√≥n de servicios"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("nmap", f"nmap scan {target}", target, characteristics)
                
                # Mostrar informaci√≥n inicial y ejecutar con output en tiempo real
                self.console.print(f"[dim]üì° Mostrando output en tiempo real...[/dim]")
                
                if detect_os or not stealth:
                    self.console.print(f"[yellow]üîÑ Ejecutando escaneo comprensivo con detecci√≥n de OS...[/yellow]")
                else:
                    self.console.print(f"[yellow]üîÑ Ejecutando escaneo b√°sico en modo sigiloso...[/yellow]")
                
                self.console.print(f"[dim]üìä Output en tiempo real a continuaci√≥n:[/dim]\n")
                
                # Ejecutar escaneo SIN Progress spinner para ver logs en tiempo real
                # EL OUTPUT REAL DE NMAP SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                if detect_os or not stealth:
                    # Usar escaneo comprensivo para detecci√≥n de OS
                    result = await nmap.comprehensive_scan(target, ports)
                else:
                    # Usar escaneo b√°sico
                    result = await nmap.basic_scan(target, ports)
                
                self.console.print(f"\n[green]‚úÖ Escaneo Nmap completado![/green]")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("nmap", True)
                
                # Mostrar resultados
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("nmap")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Escaneo Nmap Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"üîå Puertos: [yellow]{ports}[/yellow]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                    
                    # Mostrar resultados b√°sicos
                    self.display.show_scan_results(result)
                
            except Exception as e:
                self.logger.finish_tool("nmap", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando Nmap: {str(e)}[/red]")
    
    async def _use_nuclei(self):
        """Interfaz para usar Nuclei"""
        nuclei = NucleiWrapper(self.scanner.config)
        
        # Verificar instalaci√≥n de Nuclei antes de continuar
        self.console.print("[cyan]üîç Verificando instalaci√≥n de Nuclei...[/cyan]")
        nuclei_test = nuclei.test_nuclei_installation()
        
        if not nuclei_test['available']:
            self.console.print(Panel(
                f"[bold red]‚ùå Nuclei no est√° disponible[/bold red]\n\n"
                f"Error: {nuclei_test.get('error', 'Desconocido')}\n\n"
                f"[yellow]Soluciones sugeridas:[/yellow]\n" + 
                "\n".join([f"‚Ä¢ {suggestion}" for suggestion in nuclei_test.get('suggestions', [])]),
                title="Error de Nuclei",
                border_style="red"
            ))
            return
        
        # Mostrar informaci√≥n de la instalaci√≥n
        if not nuclei_test.get('ready', False):
            self.console.print(Panel(
                f"[yellow]‚ö†Ô∏è  Nuclei disponible pero sin templates[/yellow]\n\n"
                f"Versi√≥n: {nuclei_test.get('version', 'N/A')}\n"
                f"Templates: {nuclei_test.get('template_count', 0)}\n\n"
                f"[yellow]Sugerencia:[/yellow] Actualizar templates con: [cyan]nuclei -update-templates[/cyan]",
                title="Advertencia de Nuclei",
                border_style="yellow"
            ))
            
            if not Confirm.ask("[yellow]¬øContinuar sin templates actualizados?[/yellow]", default=False):
                return
        else:
            self.console.print(f"[green]‚úÖ Nuclei listo - Versi√≥n: {nuclei_test.get('version', 'N/A')} - Templates: {nuclei_test.get('template_count', 0)}[/green]")
        
        target = Prompt.ask(
            "[bold cyan]üéØ URL objetivo[/bold cyan]",
            default="https://scanme.nmap.org"
        )
        
        # Validar formato del target
        if not target.startswith(('http://', 'https://')):
            if Confirm.ask(f"[yellow]Target '{target}' no tiene protocolo. ¬øAgregar https://?[/yellow]", default=True):
                target = f"https://{target}"
            else:
                target = f"http://{target}"
        
        # Mostrar plantillas disponibles
        self.console.print(Panel(
            "[bold yellow]üîç Tipos de Plantillas Disponibles[/bold yellow]\n\n"
            "‚Ä¢ [cyan]all[/cyan] - [bold red]TODAS las plantillas[/bold red] (escaneo completo, ~15-30min)\n"
            "‚Ä¢ [cyan]cves[/cyan] - Vulnerabilidades CVE conocidas (recomendado para prod)\n"
            "‚Ä¢ [cyan]exposures[/cyan] - Exposiciones de informaci√≥n (r√°pido)\n"
            "‚Ä¢ [cyan]technologies[/cyan] - Detecci√≥n de tecnolog√≠as (informativo)\n"
            "‚Ä¢ [cyan]misconfigurations[/cyan] - Errores de configuraci√≥n (com√∫n)\n"
            "‚Ä¢ [cyan]default-logins[/cyan] - Credenciales por defecto (cr√≠tico)\n"
            "‚Ä¢ [cyan]vulnerabilities[/cyan] - Vulnerabilidades generales (amplio)\n"
            "‚Ä¢ [cyan]fuzzing[/cyan] - Fuzzing de par√°metros (exhaustivo)\n"
            "‚Ä¢ [cyan]takeovers[/cyan] - Detecci√≥n de subdomain takeover\n"
            "‚Ä¢ [cyan]workflows[/cyan] - Workflows complejos de detecci√≥n\n\n"
            "[dim]üí° Tips:[/dim]\n"
            "[dim]‚Ä¢ Menos templates = escaneo m√°s r√°pido[/dim]\n"
            "[dim]‚Ä¢ 'all' incluye TODAS las plantillas disponibles[/dim]\n"
            "[dim]‚Ä¢ Combina m√∫ltiples: cves,exposures,technologies[/dim]",
            title="Plantillas Nuclei",
            border_style="yellow"
        ))
        
        templates = Prompt.ask(
            "[bold cyan]üìã Plantillas (separadas por coma o 'all' para todas)[/bold cyan]",
            default="cves,exposures"
        )
        
        # Verificar si se seleccion√≥ "all" y advertir al usuario
        if templates.lower().strip() == 'all':
            self.console.print(Panel(
                "[bold yellow]‚ö†Ô∏è  ESCANEO COMPLETO SELECCIONADO[/bold yellow]\n\n"
                f"Se usar√°n TODAS las plantillas de Nuclei disponibles.\n"
                f"Esto incluye miles de tests y puede tomar 15-30 minutos.\n\n"
                f"[red]Consideraciones:[/red]\n"
                f"‚Ä¢ El escaneo ser√° muy exhaustivo\n"
                f"‚Ä¢ Mayor tiempo de ejecuci√≥n\n"
                f"‚Ä¢ M√°s carga en el servidor objetivo\n"
                f"‚Ä¢ Posible detecci√≥n por sistemas de seguridad\n\n"
                f"[green]Ventajas:[/green]\n"
                f"‚Ä¢ Cobertura m√°xima de vulnerabilidades\n"
                f"‚Ä¢ Detecci√≥n de issues poco comunes\n"
                f"‚Ä¢ An√°lisis comprensivo completo",
                title="‚ö†Ô∏è Advertencia: Escaneo Completo",
                border_style="yellow"
            ))
            
            if not Confirm.ask("[yellow]¬øContinuar con el escaneo completo?[/yellow]", default=False):
                self.console.print("[cyan]Escaneo cancelado. Puedes seleccionar plantillas espec√≠ficas en su lugar.[/cyan]")
                return
            
            # Estimar tiempo para escaneo completo
            template_count = nuclei_test.get('template_count', 1000)  # Usar count real o estimado
            estimated_time = max(900, template_count * 2)  # M√≠nimo 15 min, ~2s por template
        else:
            # Estimar tiempo para plantillas espec√≠ficas
            template_count = len([t.strip() for t in templates.split(',') if t.strip()])
            estimated_time = template_count * 30  # ~30 segundos por categor√≠a
        
        self.console.print(f"[dim]‚è±Ô∏è  Tiempo estimado: ~{estimated_time//60}m {estimated_time%60}s para {template_count if templates.lower().strip() == 'all' else template_count} {'plantillas' if templates.lower().strip() == 'all' else 'categor√≠as'}[/dim]")
        
        if Confirm.ask(f"[yellow]¬øEjecutar escaneo Nuclei en {target}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                scan_type = "COMPLETO (TODAS LAS PLANTILLAS)" if templates.lower().strip() == 'all' else "Espec√≠fico por categor√≠as"
                characteristics = {
                    "Herramienta": "Nuclei",
                    "Target": target,
                    "Plantillas": templates,
                    "Tipo de An√°lisis": f"Detecci√≥n de vulnerabilidades - {scan_type}",
                    "Plantillas Espec√≠ficas": "TODAS LAS PLANTILLAS DISPONIBLES" if templates.lower().strip() == 'all' else templates.replace(',', ', '),
                    "Templates Count": str(template_count),
                    "Nuclei Version": nuclei_test.get('version', 'N/A'),
                    "Template Database Size": str(nuclei_test.get('template_count', 0)),
                    "Estimated Duration": f"{estimated_time//60}m {estimated_time%60}s",
                    "Scan Intensity": "M√ÅXIMA" if templates.lower().strip() == 'all' else "MODERADA"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("nuclei", f"nuclei scan {target}", target, characteristics)
                
                # Mostrar informaci√≥n inicial y ejecutar con output en tiempo real
                self.console.print(f"[dim]üì° Mostrando output en tiempo real...[/dim]")
                
                if templates.lower().strip() == 'all':
                    self.console.print("[yellow]üîÑ Cargando TODAS las plantillas disponibles...[/yellow]")
                    self.console.print(f"[dim]‚ö†Ô∏è  Esto puede tomar 15-30 minutos. Output en tiempo real a continuaci√≥n:[/dim]\n")
                else:
                    self.console.print(f"[yellow]üîÑ Cargando plantillas: {templates}...[/yellow]")
                    self.console.print(f"[dim]üìä Output en tiempo real a continuaci√≥n:[/dim]\n")
                
                # Ejecutar el escaneo SIN Progress spinner para ver logs en tiempo real
                # EL OUTPUT REAL DE NUCLEI SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                start_time = datetime.now()
                result = await nuclei.scan_with_templates(target, templates.split(','))
                end_time = datetime.now()
                
                self.console.print(f"\n[green]‚úÖ Escaneo Nuclei completado![/green]")
                
                # Calcular duraci√≥n real
                duration = end_time - start_time
                duration_str = f"{duration.seconds//60}m {duration.seconds%60}s"
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("nuclei", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("nuclei")
                    
                    # Mostrar estad√≠sticas del escaneo
                    vuln_count = len(result.vulnerabilities)
                    stats = result.scan_stats
                    
                    # Agrupar vulnerabilidades por severidad
                    severity_counts = {}
                    for vuln in result.vulnerabilities:
                        severity = vuln.get('severity', 'UNKNOWN')
                        severity_counts[severity] = severity_counts.get(severity, 0) + 1
                    
                    severity_display = []
                    for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
                        count = severity_counts.get(severity, 0)
                        if count > 0:
                            color = {'CRITICAL': 'red', 'HIGH': 'orange', 'MEDIUM': 'yellow', 'LOW': 'blue', 'INFO': 'dim'}.get(severity, 'white')
                            severity_display.append(f"[{color}]{severity}: {count}[/{color}]")
                    
                    # Mostrar tipo de escaneo realizado
                    scan_type_display = "üåê ESCANEO COMPLETO" if templates.lower().strip() == 'all' else "üéØ Escaneo Espec√≠fico"
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Escaneo Nuclei Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"üìã Tipo: [yellow]{scan_type_display}[/yellow]\n"
                        f"üìã Plantillas: [yellow]{templates}[/yellow]\n"
                        f"‚è±Ô∏è  Duraci√≥n: [green]{duration_str}[/green]\n"
                        f"üîç Vulnerabilidades: [bold]{vuln_count}[/bold]\n"
                        f"üìä Por severidad: {' | '.join(severity_display) if severity_display else '[dim]Ninguna[/dim]'}\n"
                        f"üìÅ Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÇ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                    
                    # Mostrar las vulnerabilidades m√°s cr√≠ticas si las hay
                    critical_vulns = [v for v in result.vulnerabilities if v.get('severity') in ['CRITICAL', 'HIGH']]
                    if critical_vulns:
                        self.console.print(Panel(
                            f"[bold red]üö® Vulnerabilidades Cr√≠ticas/Altas encontradas: {len(critical_vulns)}[/bold red]\n\n" +
                            "\n".join([f"‚Ä¢ {v.get('id', 'N/A')}: {v.get('description', 'Sin descripci√≥n')[:60]}..." 
                                     for v in critical_vulns[:5]]) +
                            (f"\n... y {len(critical_vulns) - 5} m√°s" if len(critical_vulns) > 5 else ""),
                            title="‚ö†Ô∏è Vulnerabilidades Cr√≠ticas",
                            border_style="red"
                        ))
                    
                    # Mostrar estad√≠sticas especiales para escaneo completo
                    if templates.lower().strip() == 'all':
                        total_templates = stats.get('templates_used', ['ALL_TEMPLATES'])
                        self.console.print(Panel(
                            f"[bold cyan]üìä Estad√≠sticas del Escaneo Completo[/bold cyan]\n\n"
                            f"‚Ä¢ Total de plantillas ejecutadas: [yellow]{nuclei_test.get('template_count', 'N/A')}[/yellow]\n"
                            f"‚Ä¢ Tiempo promedio por plantilla: [cyan]{(duration.seconds / max(nuclei_test.get('template_count', 1), 1)):.2f}s[/cyan]\n"
                            f"‚Ä¢ Cobertura: [green]M√ÅXIMA[/green]\n"
                            f"‚Ä¢ Vulnerabilidades encontradas: [bold]{vuln_count}[/bold]\n"
                            f"‚Ä¢ Tasa de detecci√≥n: [yellow]{(vuln_count / max(nuclei_test.get('template_count', 1), 1) * 100):.2f}%[/yellow]",
                            title="üìà M√©tricas del Escaneo",
                            border_style="cyan"
                        ))
                else:
                    self.console.print("[yellow]‚ö†Ô∏è No se recibieron resultados del escaneo[/yellow]")
                
            except asyncio.TimeoutError:
                error_msg = f"Timeout del escaneo Nuclei (>{estimated_time}s)"
                self.logger.finish_tool("nuclei", False, error_msg)
                self.console.print(Panel(
                    f"[red]‚è∞ Timeout del escaneo[/red]\n\n"
                    f"El escaneo tard√≥ m√°s de lo esperado.\n"
                    f"Esto puede deberse a:\n"
                    f"‚Ä¢ Target lento o no responde\n"
                    f"‚Ä¢ Demasiados templates seleccionados\n"
                    f"‚Ä¢ Problemas de red\n\n"
                    f"[yellow]Sugerencias:[/yellow]\n"
                    f"‚Ä¢ Usar menos templates\n"
                    f"‚Ä¢ Verificar conectividad al target\n"
                    f"‚Ä¢ Intentar con un target m√°s r√°pido",
                    title="Timeout de Nuclei",
                    border_style="red"
                ))
            except Exception as e:
                error_msg = str(e)
                self.logger.finish_tool("nuclei", False, error_msg)
                
                # Manejar errores espec√≠ficos
                if "not found" in error_msg.lower():
                    self.console.print(Panel(
                        f"[red]‚ùå Nuclei no encontrado[/red]\n\n"
                        f"Error: {error_msg}\n\n"
                        f"[yellow]Soluciones:[/yellow]\n"
                        f"‚Ä¢ Instalar Nuclei: [cyan]go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest[/cyan]\n"
                        f"‚Ä¢ Verificar PATH: [cyan]which nuclei[/cyan]\n"
                        f"‚Ä¢ Actualizar templates: [cyan]nuclei -update-templates[/cyan]",
                        title="Error de Nuclei",
                        border_style="red"
                    ))
                elif "timeout" in error_msg.lower():
                    self.console.print(Panel(
                        f"[red]‚è∞ Timeout de conexi√≥n[/red]\n\n"
                        f"No se pudo conectar a {target}\n"
                        f"Verificar que el target est√© accesible",
                        title="Error de Conectividad",
                        border_style="red"
                    ))
                else:
                    self.console.print(f"[red]‚ùå Error ejecutando Nuclei: {error_msg}[/red]")
    
    async def _use_gobuster(self):
        """Interfaz para usar Gobuster"""
        gobuster = GobusterWrapper(self.scanner.config)
        
        target = Prompt.ask(
            "[bold cyan]üéØ URL objetivo[/bold cyan]",
            default="http://scanme.nmap.org"
        )
        
        # Mostrar wordlists comunes
        self.console.print(Panel(
            "[bold yellow]üìö Wordlists Recomendadas[/bold yellow]\n\n"
            "‚Ä¢ [cyan]/usr/share/wordlists/dirb/common.txt[/cyan] - Directorios comunes\n"
            "‚Ä¢ [cyan]/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt[/cyan] - Lista media\n"
            "‚Ä¢ [cyan]/usr/share/seclists/Discovery/Web-Content/common.txt[/cyan] - SecLists com√∫n\n"
            "‚Ä¢ [cyan]common[/cyan] - Usar wordlist por defecto",
            title="Wordlists Disponibles",
            border_style="yellow"
        ))
        
        wordlist = Prompt.ask(
            "[bold cyan]üìö Wordlist[/bold cyan]",
            default="common"
        )
        
        extensions = Prompt.ask(
            "[bold cyan]üìÑ Extensiones (separadas por coma)[/bold cyan]",
            default="php,html,txt,js"
        )
        
        threads = IntPrompt.ask(
            "[bold cyan]üßµ N√∫mero de hilos[/bold cyan]",
            default=10
        )
        
        if Confirm.ask(f"[yellow]¬øEjecutar fuerza bruta en {target}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Gobuster",
                    "Target": target,
                    "Wordlist": wordlist,
                    "Extensiones": extensions,
                    "Hilos": str(threads),
                    "Tipo de An√°lisis": "Fuerza bruta de directorios",
                    "Modo": "Directory enumeration"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("gobuster", f"gobuster dir scan {target}", target, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando Gobuster...", total=None)
                    
                    # EL OUTPUT REAL DE GOBUSTER SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await gobuster.directory_scan(target, wordlist, extensions.split(','), threads)
                    
                    progress.update(task, description="¬°Escaneo completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("gobuster", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("gobuster")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Escaneo Gobuster Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"üìö Wordlist: [yellow]{wordlist}[/yellow]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("gobuster", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando Gobuster: {str(e)}[/red]")
    
    async def _use_nikto(self):
        """Interfaz para usar Nikto"""
        nikto = NiktoWrapper(self.scanner.config)
        
        target = Prompt.ask(
            "[bold cyan]üéØ URL objetivo[/bold cyan]",
            default="http://scanme.nmap.org"
        )
        
        port = IntPrompt.ask(
            "[bold cyan]üîå Puerto[/bold cyan]",
            default=80
        )
        
        if Confirm.ask(f"[yellow]¬øEjecutar escaneo Nikto en {target}:{port}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Nikto",
                    "Target": target,
                    "Puerto": str(port),
                    "Tipo de An√°lisis": "Escaneo web de vulnerabilidades",
                    "Protocolo": "HTTPS" if port == 443 else "HTTP",
                    "URL Completa": f"{target}:{port}"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("nikto", f"nikto web scan {target}:{port}", target, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando Nikto...", total=None)
                    
                    # EL OUTPUT REAL DE NIKTO SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await nikto.scan_web_server(target, port)
                    
                    progress.update(task, description="¬°Escaneo completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("nikto", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("nikto")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Escaneo Nikto Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}:{port}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("nikto", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando Nikto: {str(e)}[/red]")
    
    async def _use_sqlmap(self):
        """Interfaz para usar SQLMap"""
        sqlmap = SqlMapWrapper(self.scanner.config)
        
        url = Prompt.ask(
            "[bold cyan]üéØ URL con par√°metros[/bold cyan]",
            default="http://scanme.nmap.org/page.php?id=1"
        )
        
        # Mostrar opciones de SQLMap
        self.console.print(Panel(
            "[bold yellow]üíâ Opciones de SQLMap[/bold yellow]\n\n"
            "‚Ä¢ [cyan]--dbs[/cyan] - Enumerar bases de datos\n"
            "‚Ä¢ [cyan]--tables[/cyan] - Enumerar tablas\n"
            "‚Ä¢ [cyan]--columns[/cyan] - Enumerar columnas\n"
            "‚Ä¢ [cyan]--dump[/cyan] - Extraer datos\n"
            "‚Ä¢ [cyan]--batch[/cyan] - Modo no interactivo",
            title="Opciones SQLMap",
            border_style="yellow"
        ))
        
        enumerate_dbs = Confirm.ask("[cyan]¬øEnumerar bases de datos?[/cyan]", default=True)
        
        if Confirm.ask(f"[yellow]¬øEjecutar SQLMap en {url}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                options = ['--batch']
                if enumerate_dbs:
                    options.append('--dbs')
                
                characteristics = {
                    "Herramienta": "SQLMap",
                    "Target": url,
                    "Tipo de An√°lisis": "Detecci√≥n de inyecci√≥n SQL",
                    "Enumerar DBs": "S√≠" if enumerate_dbs else "No",
                    "Opciones": " ".join(options),
                    "Modo": "Automatizado (--batch)"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("sqlmap", f"sqlmap injection test {url}", url, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando SQLMap...", total=None)
                    
                    # EL OUTPUT REAL DE SQLMAP SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await sqlmap.test_injection(url, additional_args=options)
                    
                    progress.update(task, description="¬°Escaneo completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("sqlmap", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("sqlmap")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Escaneo SQLMap Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{url}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("sqlmap", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando SQLMap: {str(e)}[/red]")
    
    async def _use_ssl_analyzer(self):
        """Interfaz para usar SSL Analyzer"""
        ssl_analyzer = SSLAnalyzer(self.console)
        
        domain = Prompt.ask(
            "[bold cyan]üéØ Dominio[/bold cyan]",
            default="scanme.nmap.org"
        )
        
        port = IntPrompt.ask(
            "[bold cyan]üîå Puerto SSL[/bold cyan]",
            default=443
        )
        
        if Confirm.ask(f"[yellow]¬øAnalizar SSL/TLS de {domain}:{port}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "SSL Analyzer",
                    "Dominio": domain,
                    "Puerto": str(port),
                    "Tipo de An√°lisis": "An√°lisis de certificados SSL/TLS",
                    "Protocolo": "TLS/SSL",
                    "Target Completo": f"{domain}:{port}"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("ssl_analyzer", f"ssl analysis {domain}:{port}", f"{domain}:{port}", characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Analizando SSL/TLS...", total=None)
                    
                    # EL OUTPUT REAL DE SSL ANALYZER SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await ssl_analyzer.analyze_domain(domain, port)
                    
                    progress.update(task, description="¬°An√°lisis completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("ssl_analyzer", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("ssl_analyzer")
                    
                    # Mostrar resultados del SSL Analyzer
                    ssl_analyzer.display_results(result)
                    
                    # Mostrar informaci√≥n del log
                    self.console.print(Panel(
                        f"[bold green]‚úÖ An√°lisis SSL Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{domain}:{port}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Log Generado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("ssl_analyzer", False, str(e))
                self.console.print(f"[red]‚ùå Error analizando SSL: {str(e)}[/red]")
    
    async def _use_ffuf(self):
        """Interfaz para usar FFUF"""
        ffuf = FfufWrapper(self.scanner.config)
        
        url = Prompt.ask(
            "[bold cyan]üéØ URL base (usa FUZZ como placeholder)[/bold cyan]",
            default="http://scanme.nmap.org/FUZZ"
        )
        
        wordlist = Prompt.ask(
            "[bold cyan]üìö Wordlist[/bold cyan]",
            default="/usr/share/wordlists/dirb/common.txt"
        )
        
        if Confirm.ask(f"[yellow]¬øEjecutar FFUF en {url}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "FFUF",
                    "URL Base": url,
                    "Wordlist": wordlist,
                    "Tipo de An√°lisis": "Fuzzing web r√°pido",
                    "Placeholder": "FUZZ",
                    "Modo": "Directory/File fuzzing"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("ffuf", f"ffuf fuzzing {url}", url, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando FFUF...", total=None)
                    
                    # EL OUTPUT REAL DE FFUF SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await ffuf.fuzz_target(url, wordlist)
                    
                    progress.update(task, description="¬°Fuzzing completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("ffuf", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("ffuf")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Fuzzing FFUF Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{url}[/cyan]\n"
                        f"üìö Wordlist: [yellow]{wordlist}[/yellow]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("ffuf", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando FFUF: {str(e)}[/red]")
    
    async def _use_shodan(self):
        """Interfaz para usar Shodan"""
        shodan = ShodanWrapper(self.scanner.config)
        
        query = Prompt.ask(
            "[bold cyan]üîç Consulta Shodan[/bold cyan]",
            default="apache"
        )
        
        if Confirm.ask(f"[yellow]¬øBuscar en Shodan: {query}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Shodan",
                    "Query": query,
                    "Tipo de An√°lisis": "B√∫squeda en motor de dispositivos IoT",
                    "Base de Datos": "Shodan Internet Database",
                    "Alcance": "Global"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("shodan", f"shodan search {query}", query, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Consultando Shodan...", total=None)
                    
                    # EL OUTPUT REAL DE SHODAN SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await shodan.search_query(query)
                    
                    progress.update(task, description="¬°B√∫squeda completada!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("shodan", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("shodan")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ B√∫squeda Shodan Completada[/bold green]\n\n"
                        f"üîç Query: [cyan]{query}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("shodan", False, str(e))
                self.console.print(f"[red]‚ùå Error consultando Shodan: {str(e)}[/red]")
    
    async def _use_traceroute(self):
        """Interfaz para usar Traceroute"""
        traceroute = TracerouteWrapper(self.scanner.config)
        
        target = Prompt.ask(
            "[bold cyan]üéØ Destino[/bold cyan]",
            default="8.8.8.8"
        )
        
        if Confirm.ask(f"[yellow]¬øEjecutar traceroute a {target}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Traceroute",
                    "Target": target,
                    "Tipo de An√°lisis": "Rastreo de rutas de red",
                    "Protocolo": "ICMP/UDP",
                    "Objetivo": "Mapear ruta de red hasta el destino"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("traceroute", f"traceroute {target}", target, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando traceroute...", total=None)
                    
                    # EL OUTPUT REAL DE TRACEROUTE SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await traceroute.trace_to_target(target)
                    
                    progress.update(task, description="¬°Traceroute completado!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("traceroute", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("traceroute")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Traceroute Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("traceroute", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando traceroute: {str(e)}[/red]")
    
    async def _use_w3af(self):
        """Interfaz para usar W3AF"""
        w3af = W3afWrapper(self.scanner.config)
        
        target = Prompt.ask(
            "[bold cyan]üéØ URL objetivo[/bold cyan]",
            default="http://scanme.nmap.org"
        )
        
        if Confirm.ask(f"[yellow]¬øEjecutar auditor√≠a W3AF en {target}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "W3AF",
                    "Target": target,
                    "Tipo de An√°lisis": "Framework de auditor√≠a web completa",
                    "Scope": "Auditor√≠a completa de aplicaci√≥n web",
                    "Framework": "Web Application Attack and Audit Framework"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("w3af", f"w3af audit {target}", target, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Ejecutando W3AF...", total=None)
                    
                    # EL OUTPUT REAL DE W3AF SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await w3af.audit_target(target)
                    
                    progress.update(task, description="¬°Auditor√≠a completada!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("w3af", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("w3af")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ Auditor√≠a W3AF Completada[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("w3af", False, str(e))
                self.console.print(f"[red]‚ùå Error ejecutando W3AF: {str(e)}[/red]")
    
    async def _use_censys(self):
        """Interfaz para usar Censys"""
        censys = CensysWrapper(self.scanner.config)
        
        query = Prompt.ask(
            "[bold cyan]üîç Consulta Censys[/bold cyan]",
            default="services.service_name: HTTP"
        )
        
        if Confirm.ask(f"[yellow]¬øBuscar en Censys: {query}?[/yellow]"):
            try:
                # Preparar caracter√≠sticas del an√°lisis para el log individual
                characteristics = {
                    "Herramienta": "Censys",
                    "Query": query,
                    "Tipo de An√°lisis": "B√∫squeda en motor de internet",
                    "Base de Datos": "Censys Internet Database",
                    "Alcance": "Internet IPv4/IPv6"
                }
                
                # Iniciar logging individual - SOLO las caracter√≠sticas, no logs adicionales
                self.logger.start_tool_with_individual_log("censys", f"censys search {query}", query, characteristics)
                
                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=self.console
                ) as progress:
                    task = progress.add_task("Consultando Censys...", total=None)
                    
                    # EL OUTPUT REAL DE CENSYS SER√Å CAPTURADO AUTOM√ÅTICAMENTE POR process_runner
                    result = await censys.search_hosts_query(query)
                    
                    progress.update(task, description="¬°B√∫squeda completada!")
                
                # Finalizar el log individual (sin logs adicionales nuestros)
                self.logger.finish_tool("censys", True)
                
                if result:
                    # Obtener la ruta del log individual
                    individual_log = self.logger.get_tool_individual_log_path("censys")
                    
                    self.console.print(Panel(
                        f"[bold green]‚úÖ B√∫squeda Censys Completada[/bold green]\n\n"
                        f"üîç Query: [cyan]{query}[/cyan]\n"
                        f"üìä Log individual: [green]{individual_log.name if individual_log else 'N/A'}[/green]\n"
                        f"üìÅ Ubicaci√≥n: [dim]{individual_log.parent if individual_log else 'N/A'}[/dim]",
                        title="Resultado",
                        border_style="green"
                    ))
                
            except Exception as e:
                self.logger.finish_tool("censys", False, str(e))
                self.console.print(f"[red]‚ùå Error consultando Censys: {str(e)}[/red]") 