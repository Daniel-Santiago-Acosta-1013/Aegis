"""
CLI principal moderna para Aegis Pentest Automation
Interfaz completamente interactiva sin par√°metros
Con sistema de logging integrado y manejo de privilegios
"""

import asyncio
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from rich.prompt import Prompt, Confirm
from rich import box

from aegis_pentest.core.scanner import AegisScanner
from aegis_pentest.utils.config import Config
from aegis_pentest.utils.installer import ToolInstaller
from aegis_pentest.tools.ssl_analyzer import SSLAnalyzer
from aegis_pentest.utils.helpers import validate_target
from aegis_pentest.utils.logger import get_logger, cleanup_logger
from aegis_pentest.utils.privilege_manager import ensure_admin_privileges, get_privilege_manager
from .display import DisplayManager
from .interactive import InteractiveMode


class AegisCLI:
    """Interfaz CLI moderna y enriquecida para Aegis con logging integrado y manejo de privilegios"""
    
    def __init__(self):
        self.console = Console()
        self.config = Config()
        self.installer = ToolInstaller(self.console)
        self.ssl_analyzer = SSLAnalyzer(self.console)
        # Pasar console al scanner para integrar logging
        self.scanner = AegisScanner(self.config, self.console)
        self.display = DisplayManager(self.console)
        self.interactive = InteractiveMode(self.console, self.scanner, self.display)
        self.current_scan = None
        
        # Inicializar sistema de logging
        self.tool_logger = get_logger(self.console)
        
        # Inicializar gestor de privilegios
        self.privilege_manager = get_privilege_manager(self.console)
        self.privileges_validated = False
        
    def check_admin_privileges(self) -> bool:
        """Verifica y solicita privilegios de administrador al inicio"""
        self.console.print(Panel(
            "[bold cyan]üîê Verificaci√≥n de Privilegios[/bold cyan]\n\n"
            "[yellow]Aegis Pentest requiere privilegios de administrador para:[/yellow]\n"
            "‚Ä¢ Ejecutar escaneos SYN stealth con Nmap\n"
            "‚Ä¢ Detectar servicios y sistemas operativos\n"
            "‚Ä¢ Acceder a funcionalidades avanzadas de pentesting\n\n"
            "[dim]Verificando permisos actuales...[/dim]",
            title="Inicializaci√≥n de Privilegios",
            border_style="cyan"
        ))
        
        # Verificar privilegios actuales
        if self.privilege_manager.is_admin():
            self.console.print("[green]‚úì Ejecut√°ndose como administrador[/green]")
            self.privileges_validated = True
            return True
        
        # Si no somos admin, intentar obtener privilegios sudo
        if ensure_admin_privileges(self.console):
            self.privileges_validated = True
            return True
        else:
            self.console.print(Panel(
                "[bold red]‚ùå No se pudieron obtener privilegios de administrador[/bold red]\n\n"
                "[yellow]‚ö†Ô∏è El programa puede continuar con funcionalidad limitada:[/yellow]\n"
                "‚Ä¢ Algunos escaneos de Nmap no funcionar√°n\n"
                "‚Ä¢ La detecci√≥n de OS estar√° deshabilitada\n"
                "‚Ä¢ Algunas herramientas pueden fallar\n\n"
                "[cyan]Recomendaci√≥n: Reinicia como administrador para funcionalidad completa[/cyan]",
                title="Privilegios Limitados",
                border_style="yellow"
            ))
            
            if not Confirm.ask("[yellow]¬øContinuar con privilegios limitados?[/yellow]"):
                return False
            
            self.privileges_validated = False
            return True
    
    def print_banner(self):
        """Muestra el banner de Aegis con informaci√≥n de logging y privilegios"""
        banner = Text.assemble(
            ("    ___    __________ _____ _____\n", "bold cyan"),
            ("   /   |  / ____/ __ \\_   _/ ___/\n", "bold cyan"),
            ("  / /| | / __/ / / / / // / \\__ \\ \n", "bold cyan"),
            (" / ___ |/ /___/ /_/ _// /_____/ / \n", "bold cyan"),
            ("/_/  |_/_____/\\____/___//____/  \n", "bold cyan"),
            ("\nüõ°Ô∏è  ", "bold white"),
            ("Automatizaci√≥n de Pentesting Web", "bold white"),
            (" üõ°Ô∏è\n", "bold white"),
            ("v1.0.0", "dim white")
        )
        
        panel = Panel(
            banner,
            title="[bold red]AEGIS PENTEST AUTOMATION[/bold red]",
            border_style="bright_blue",
            padding=(1, 2)
        )
        self.console.print(panel)
        
        # Mostrar informaci√≥n del sistema de logging
        log_file = self.tool_logger.get_log_file_path()
        
        # Mostrar estado de privilegios
        privilege_status = "üîê [bold green]Administrador[/bold green]" if self.privileges_validated else "‚ö†Ô∏è [bold yellow]Limitado[/bold yellow]"
        privilege_details = "Funcionalidad completa disponible" if self.privileges_validated else "Algunas funciones pueden estar limitadas"
        
        self.console.print(Panel(
            f"üìã [bold cyan]Sistema de Logging Activado[/bold cyan]\n"
            f"üìÅ Archivo: [green]{log_file.name}[/green]\n"
            f"üìç Ruta: [dim]{log_file.parent}[/dim]\n"
            f"‚ö° Monitoreo en tiempo real: [bold green]Activo[/bold green]\n\n"
            f"üîê [bold cyan]Estado de Privilegios[/bold cyan]\n"
            f"üë§ Modo: {privilege_status}\n"
            f"üìù Estado: [dim]{privilege_details}[/dim]",
            title="Estado del Sistema",
            border_style="cyan",
            padding=(0, 1)
        ))
        self.console.print()
    
    def show_main_menu(self):
        """Muestra el men√∫ principal"""
        table = Table(title="üéØ Men√∫ Principal", box=box.ROUNDED)
        table.add_column("Opci√≥n", style="cyan", min_width=3)
        table.add_column("Descripci√≥n", style="white")
        table.add_column("Tiempo Est.", style="yellow", justify="center")
        
        table.add_row("1", "[bold green]Escaneo R√°pido[/bold green] - Puertos comunes", "5-15 min")
        table.add_row("2", "[bold blue]Escaneo Completo[/bold blue] - M√∫ltiples herramientas", "30-60 min")
        table.add_row("3", "[bold red]Escaneo de Vulnerabilidades[/bold red] - Detecci√≥n CVE", "20-45 min")
        table.add_row("4", "[bold magenta]Escaneo Sigiloso[/bold magenta] - Evasi√≥n", "10-30 min")
        table.add_row("5", "[bold yellow]An√°lisis SSL/TLS[/bold yellow] - Certificados y seguridad", "2-5 min")
        table.add_row("6", "[bold cyan]Modo Interactivo[/bold cyan] - Configuraci√≥n avanzada", "Variable")
        table.add_row("7", "[dim]Estado de Herramientas[/dim] - Verificar disponibilidad", "< 1 min")
        table.add_row("8", "[dim]Estado de Privilegios[/dim] - Verificar permisos", "< 1 min")
        table.add_row("9", "[dim]Configuraci√≥n[/dim] - Ajustes del sistema", "< 1 min")
        table.add_row("0", "[bold red]Salir[/bold red]", "")
        
        self.console.print(table)
        self.console.print()
    
    def get_target(self):
        """Solicita y valida el objetivo"""
        while True:
            target = Prompt.ask(
                "[bold cyan]üéØ Ingresa el objetivo[/bold cyan]",
                default="scanme.nmap.org"
            )
            
            if target:
                is_valid, target_type, message = validate_target(target)
                if is_valid:
                    self.console.print(f"[green]‚úì[/green] Objetivo v√°lido: {target} ({target_type})")
                    return target
                else:
                    self.console.print(f"[red]‚úó[/red] {message}")
            else:
                self.console.print("[red]‚úó[/red] Por favor ingresa un objetivo v√°lido")
    
    def get_ports(self, default_ports="1-1000"):
        """Solicita la configuraci√≥n de puertos"""
        ports = Prompt.ask(
            "[bold cyan]üîå Puertos a escanear[/bold cyan]",
            default=default_ports
        )
        return ports
    
    async def run_scan(self, scan_type, target, options=None):
        """Ejecuta un escaneo con progress bar y logging en tiempo real"""
        options = options or {}
        
        # Configurar callback de progreso
        progress_data = {"current": 0, "total": 100, "message": "Iniciando..."}
        
        def progress_callback(step, total, percentage, message):
            progress_data["current"] = int(percentage)
            progress_data["message"] = message
        
        try:
            self.scanner.add_progress_callback(progress_callback)
        except AttributeError:
            # Si no existe el m√©todo, continuar sin callback
            pass
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=self.console
        ) as progress:
            
            progress_task = progress.add_task("Escaneando...", total=100)
            
            try:
                # Crear tarea de escaneo y convertir a Task
                if scan_type == "quick":
                    scan_coro = self.scanner.basic_scan(target, options.get('ports', '1-1000'))
                elif scan_type == "full":
                    scan_coro = self.scanner.comprehensive_scan(target, options)
                elif scan_type == "vulnerability":
                    scan_coro = self.scanner.vulnerability_scan(target, options)
                elif scan_type == "stealth":
                    scan_coro = self.scanner.nmap.stealth_scan(target, options.get('ports', '80,443,8080,8443'))
                else:
                    raise ValueError(f"Tipo de escaneo desconocido: {scan_type}")
                
                # Convertir corrutina en Task para poder usar .done()
                scan_task = asyncio.create_task(scan_coro)
                
                # Ejecutar escaneo con actualizaciones de progreso
                while not scan_task.done():
                    progress.update(
                        progress_task,
                        completed=progress_data["current"],
                        description=progress_data["message"]
                    )
                    await asyncio.sleep(0.1)
                
                # Obtener resultado
                result = await scan_task
                progress.update(progress_task, completed=100, description="¬°Completado!")
                
                # Mostrar informaci√≥n del log generado
                if result and hasattr(result, 'log_file_path') and result.log_file_path:
                    self.console.print()
                    self.console.print(Panel(
                        f"üìã [bold green]Escaneo Completado[/bold green]\n\n"
                        f"üéØ Target: [cyan]{target}[/cyan]\n"
                        f"‚è±Ô∏è  Duraci√≥n: [yellow]{result.duration:.2f}s[/yellow]\n"
                        f"üìä Puertos abiertos: [green]{len(result.open_ports)}[/green]\n"
                        f"üîß Servicios detectados: [blue]{len(result.services)}[/blue]\n"
                        f"üìÅ Log completo: [dim]{result.log_file_path}[/dim]",
                        title="Resumen del An√°lisis",
                        border_style="green"
                    ))
                
                return result
                
            except Exception as e:
                import traceback
                
                # Capturar traceback completo para debugging
                full_traceback = traceback.format_exc()
                error_type = type(e).__name__
                error_message = str(e)
                
                # Log del error completo
                self.tool_logger.log_tool_output("cli", f"Error completo en {scan_type}: {full_traceback}", True)
                
                # Mostrar error detallado en consola
                self.console.print(f"[red]‚úó Error en escaneo ({error_type}): {error_message}[/red]")
                
                # Obtener archivo de log
                log_file = self.tool_logger.get_log_file_path()
                
                # Generar mensaje de error m√°s informativo
                error_details = []
                if "nmap" in error_message.lower() or error_message == "'nmap'":
                    error_details.append("üîß Problema con Nmap detectado")
                    
                    # Verificar estado detallado de nmap
                    try:
                        nmap_status = self.scanner.nmap.get_availability_status()
                        
                        if not nmap_status["binary_available"]:
                            error_details.append("‚ùå Binario nmap no est√° instalado o no est√° en PATH")
                            error_details.append("üí° Soluci√≥n: Instala nmap con 'brew install nmap' (macOS) o 'sudo apt install nmap' (Linux)")
                        
                        if not nmap_status["python_nmap_available"]:
                            error_details.append("‚ùå Librer√≠a python-nmap no disponible")
                            error_details.append(f"   Error: {nmap_status['python_nmap_error']}")
                            error_details.append("üí° Soluci√≥n: Ejecuta 'poetry install' para instalar dependencias")
                        
                        if nmap_status["init_error"]:
                            error_details.append("‚ö†Ô∏è Error de inicializaci√≥n de NmapWrapper")
                            error_details.append(f"   Error: {nmap_status['init_error']}")
                    
                    except Exception:
                        # Si no podemos obtener el estado, usar verificaciones b√°sicas
                        if not self.scanner.nmap.is_available():
                            error_details.append("‚ùå Nmap no est√° instalado o no est√° en PATH")
                            error_details.append("üí° Soluci√≥n: Instala nmap con 'brew install nmap' (macOS) o 'sudo apt install nmap' (Linux)")
                        elif not self.privileges_validated:
                            error_details.append("üîê Posible problema de privilegios")
                            error_details.append("üí° Soluci√≥n: Ejecuta con sudo o valida privilegios en el men√∫ (opci√≥n 8)")
                        else:
                            error_details.append("‚ö†Ô∏è Error desconocido de Nmap")
                            error_details.append("üí° Verifica el log para m√°s detalles")
                
                # Si hay errores en el resultado del scanner
                scanner_status = self.scanner.get_scan_status()
                if scanner_status.get("status") == "error":
                    current_scan = self.scanner.current_scan
                    if current_scan and current_scan.errors:
                        error_details.append("üìã Errores del scanner:")
                        for scanner_error in current_scan.errors:
                            error_details.append(f"   ‚Ä¢ {scanner_error}")
                
                # Construir panel de error
                error_content = f"[red]‚ùå Escaneo Fall√≥[/red]\n\n"
                error_content += f"üêõ Tipo de Error: [yellow]{error_type}[/yellow]\n"
                error_content += f"üìù Mensaje: [yellow]{error_message}[/yellow]\n"
                
                if error_details:
                    error_content += f"\nüîç Diagn√≥stico:\n"
                    for detail in error_details:
                        error_content += f"   {detail}\n"
                
                error_content += f"\nüìÅ Log completo: [dim]{log_file}[/dim]\n"
                error_content += f"üîß Traceback guardado en log para debugging"
                
                self.console.print(Panel(
                    error_content,
                    title="Error en An√°lisis",
                    border_style="red"
                ))
                
                return None
    
    async def quick_scan_mode(self):
        """Modo de escaneo r√°pido"""
        self.console.print(Panel(
            "[bold green]üöÄ ESCANEO R√ÅPIDO[/bold green]\n"
            "Escaneo b√°sico de puertos comunes con Nmap",
            border_style="green"
        ))
        
        target = self.get_target()
        ports = self.get_ports("1-1000")
        
        if Confirm.ask("[yellow]¬øIniciar escaneo r√°pido?[/yellow]"):
            result = await self.run_scan("quick", target, {"ports": ports})
            if result:
                self.display.show_scan_results(result)
    
    async def full_scan_mode(self):
        """Modo de escaneo completo"""
        self.console.print(Panel(
            "[bold blue]üîç ESCANEO COMPLETO[/bold blue]\n"
            "Escaneo comprehensivo con m√∫ltiples herramientas",
            border_style="blue"
        ))
        
        target = self.get_target()
        ports = self.get_ports("1-65535")
        
        options = {
            "ports": ports,
            "detect_os": Confirm.ask("[cyan]¬øDetectar sistema operativo?[/cyan]", default=True),
            "detect_services": Confirm.ask("[cyan]¬øDetectar servicios?[/cyan]", default=True),
            "run_scripts": Confirm.ask("[cyan]¬øEjecutar scripts NSE?[/cyan]", default=False)
        }
        
        if Confirm.ask("[yellow]¬øIniciar escaneo completo?[/yellow]"):
            result = await self.run_scan("full", target, options)
            if result:
                self.display.show_scan_results(result)
    
    async def vulnerability_scan_mode(self):
        """Modo de escaneo de vulnerabilidades"""
        self.console.print(Panel(
            "[bold red]üö® ESCANEO DE VULNERABILIDADES[/bold red]\n"
            "Detecci√≥n especializada de CVEs y vulnerabilidades",
            border_style="red"
        ))
        
        target = self.get_target()
        ports = self.get_ports("1-1000")
        
        options = {
            "ports": ports,
            "run_scripts": True,
            "run_sqlmap": Confirm.ask("[cyan]¬øEjecutar SQLMap (solo para web)?[/cyan]", default=False)
        }
        
        if Confirm.ask("[yellow]¬øIniciar escaneo de vulnerabilidades?[/yellow]"):
            result = await self.run_scan("vulnerability", target, options)
            if result:
                self.display.show_scan_results(result)
    
    async def stealth_scan_mode(self):
        """Modo de escaneo sigiloso"""
        self.console.print(Panel(
            "[bold magenta]ü•∑ ESCANEO SIGILOSO[/bold magenta]\n"
            "T√©cnicas de evasi√≥n para evitar detecci√≥n",
            border_style="magenta"
        ))
        
        target = self.get_target()
        ports = self.get_ports("80,443,8080,8443")
        
        if Confirm.ask("[yellow]¬øIniciar escaneo sigiloso?[/yellow]"):
            result = await self.run_scan("stealth", target, {"ports": ports})
            if result:
                self.display.show_scan_results(result)
    
    async def ssl_analysis_mode(self):
        """Modo de an√°lisis SSL/TLS"""
        if not self.ssl_analyzer.is_available():
            self.console.print(Panel(
                "[bold red]‚ùå OpenSSL no est√° disponible[/bold red]\n"
                "Para usar esta funci√≥n, instale OpenSSL primero.",
                border_style="red"
            ))
            return
        
        self.console.print(Panel(
            "[bold yellow]üîí AN√ÅLISIS SSL/TLS[/bold yellow]\n"
            "An√°lisis completo de certificados, configuraci√≥n y vulnerabilidades SSL",
            border_style="yellow"
        ))
        
        target = self.get_target()
        
        # Extraer dominio de URL si es necesario
        if target.startswith(('http://', 'https://')):
            from urllib.parse import urlparse
            parsed = urlparse(target)
            domain = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)
        else:
            domain = target
            port = 443
        
        # Permitir especificar puerto personalizado
        port_input = Prompt.ask(
            f"[bold cyan]üîå Puerto SSL[/bold cyan]",
            default=str(port)
        )
        
        try:
            port = int(port_input)
        except ValueError:
            self.console.print("[red]‚úó Puerto inv√°lido, usando 443[/red]")
            port = 443
        
        if Confirm.ask(f"[yellow]¬øIniciar an√°lisis SSL/TLS de {domain}:{port}?[/yellow]"):
            
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                
                task = progress.add_task("Analizando SSL/TLS...", total=None)
                
                try:
                    # Ejecutar an√°lisis SSL
                    results = await self.ssl_analyzer.analyze_domain(domain, port)
                    
                    progress.update(task, description="¬°An√°lisis completado!")
                    
                    # Mostrar resultados
                    self.console.clear()
                    self.ssl_analyzer.display_results(results)
                    
                except Exception as e:
                    self.console.print(f"[red]‚úó Error en an√°lisis SSL: {str(e)}[/red]")
    
    async def show_tools_status(self):
        """Muestra el estado de las herramientas con opciones de instalaci√≥n"""
        missing_tools = None
        
        # Mostrar loader mientras se verifica el estado de las herramientas
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("üîç Verificando herramientas disponibles...", total=None)
            
            # Hacer la verificaci√≥n real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # Peque√±o delay para mostrar el loader
            
            # La verificaci√≥n real ocurre aqu√≠
            progress.update(task, description="‚öôÔ∏è Detectando versiones y rutas...")
            
            # Ejecutar la verificaci√≥n de manera s√≠ncrona pero controlada
            try:
                missing_tools = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.display.show_tools_status(self.config, self.installer)
                )
                # Actualizar el mensaje una vez que termine
                progress.update(task, description="‚úÖ Verificaci√≥n completada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="‚ùå Error en verificaci√≥n")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece autom√°ticamente cuando sale del contexto
        # y la tabla ya est√° mostrada por show_tools_status
        
        if missing_tools:
            choice = Prompt.ask(
                "[bold yellow]¬øQu√© deseas hacer?[/bold yellow]",
                choices=["i", "s", "p", ""],
                default=""
            )
            
            if choice == "i":
                # Instalar todas las herramientas faltantes
                await self._install_all_missing_tools(missing_tools)
            elif choice == "s":
                # Seleccionar herramientas espec√≠ficas
                await self._install_selected_tools(missing_tools)
            elif choice == "p":
                # Verificar prerequisitos
                self._show_prerequisites()
    
    async def _install_all_missing_tools(self, tools: list):
        """Instala todas las herramientas faltantes"""
        self.console.print(Panel(
            f"[bold cyan]üì¶ Instalando {len(tools)} herramientas...[/bold cyan]",
            border_style="cyan"
        ))
        
        if not Confirm.ask(f"[yellow]¬øContinuar con la instalaci√≥n de {', '.join(tools)}?[/yellow]"):
            return
        
        results = {}
        successful_installs = []
        
        for tool in tools:
            success, message = await self.installer.install_tool(tool)
            results[tool] = (success, message)
            
            if success:
                successful_installs.append(tool)
        
        # Mostrar resumen de instalaci√≥n
        self.installer.show_installation_summary(results)
        
        # Si hubo instalaciones exitosas, refrescar la detecci√≥n de herramientas
        if successful_installs:
            self.console.print(Panel(
                "[bold green]üîÑ Actualizando detecci√≥n de herramientas...[/bold green]",
                border_style="green"
            ))
            
            # Refrescar la configuraci√≥n global
            self.config.refresh_tools_detection()
            
            # Mostrar estado actualizado
            self.console.print()
            self.console.print("[bold green]‚úÖ Estado actualizado de herramientas:[/bold green]")
            updated_missing = self.display.show_tools_status(self.config, self.installer, show_header=False)
            
            if not updated_missing:
                self.console.print("[bold green]üéâ ¬°Todas las herramientas est√°n ahora disponibles![/bold green]")
            else:
                self.console.print(f"[yellow]‚ÑπÔ∏è  Herramientas a√∫n faltantes: {', '.join(updated_missing)}[/yellow]")
                self.console.print("[dim]Puedes intentar instalarlas manualmente o reiniciar la terminal[/dim]")
    
    async def _install_selected_tools(self, tools: list):
        """Permite seleccionar herramientas espec√≠ficas para instalar"""
        self.console.print(Panel(
            "[bold cyan]üì¶ Selecci√≥n de Herramientas[/bold cyan]",
            border_style="cyan"
        ))
        
        selected_tools = []
        for tool in tools:
            config = self.installer.tools_config.get(tool, {})
            description = config.get('description', '')
            
            if Confirm.ask(f"[cyan]¬øInstalar {tool}?[/cyan] [dim]({description})[/dim]"):
                selected_tools.append(tool)
        
        if selected_tools:
            await self._install_all_missing_tools(selected_tools)
        else:
            self.console.print("[yellow]‚ö†Ô∏è  No se seleccion√≥ ninguna herramienta[/yellow]")
    
    def _show_prerequisites(self):
        """Muestra el estado de los prerequisitos del sistema"""
        prereqs = self.installer.check_prerequisites()
        
        self.console.print(Panel(
            "[bold cyan]üîç PREREQUISITOS DEL SISTEMA[/bold cyan]",
            border_style="cyan"
        ))
        
        prereq_table = Table(box=box.ROUNDED)
        prereq_table.add_column("Prerequisito", style="cyan")
        prereq_table.add_column("Estado", style="white", justify="center")
        prereq_table.add_column("Descripci√≥n", style="dim white")
        
        descriptions = {
            'homebrew': 'Gestor de paquetes para macOS',
            'apt': 'Gestor de paquetes para Debian/Ubuntu',
            'yum': 'Gestor de paquetes para RHEL/CentOS',
            'pacman': 'Gestor de paquetes para Arch Linux',
            'go': 'Lenguaje Go para herramientas modernas',
            'git': 'Sistema de control de versiones'
        }
        
        for prereq, available in prereqs.items():
            status = "üü¢ Disponible" if available else "üî¥ No disponible"
            description = descriptions.get(prereq, '')
            prereq_table.add_row(prereq.upper(), status, description)
        
        self.console.print(prereq_table)
        
        # Ofrecer instalar prerequisitos faltantes
        missing_prereqs = [name for name, available in prereqs.items() if not available]
        if missing_prereqs:
            self.console.print()
            if Confirm.ask("[yellow]¬øInstalar prerequisitos faltantes autom√°ticamente?[/yellow]"):
                if self.installer.install_prerequisites():
                    self.console.print("[green]‚úì Prerequisitos instalados correctamente[/green]")
                else:
                    self.console.print("[red]‚úó Error instalando prerequisitos[/red]")
    
    async def show_configuration(self):
        """Muestra la configuraci√≥n actual"""
        # Mostrar loader mientras se carga la configuraci√≥n
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("‚öôÔ∏è Cargando configuraci√≥n del sistema...", total=None)
            
            # Hacer la carga real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # Peque√±o delay para mostrar el loader
            
            # La carga real ocurre aqu√≠
            progress.update(task, description="üìã Recopilando configuraciones...")
            
            try:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.display.show_configuration(self.config)
                )
                progress.update(task, description="‚úÖ Configuraci√≥n cargada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="‚ùå Error cargando configuraci√≥n")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece autom√°ticamente cuando sale del contexto
        # y la configuraci√≥n ya est√° mostrada
    
    async def run(self):
        """Bucle principal de la CLI"""
        try:
            if not self.check_admin_privileges():
                return
            
            self.print_banner()
            
            while True:
                self.show_main_menu()
                
                choice = Prompt.ask(
                    "[bold yellow]Selecciona una opci√≥n[/bold yellow]",
                    choices=["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
                    default="1"
                )
                
                self.console.print()
                
                try:
                    if choice == "0":
                        self.console.print("[bold red]üëã ¬°Hasta luego![/bold red]")
                        break
                    elif choice == "1":
                        await self.quick_scan_mode()
                    elif choice == "2":
                        await self.full_scan_mode()
                    elif choice == "3":
                        await self.vulnerability_scan_mode()
                    elif choice == "4":
                        await self.stealth_scan_mode()
                    elif choice == "5":
                        await self.ssl_analysis_mode()
                    elif choice == "6":
                        await self.interactive.run()
                    elif choice == "7":
                        await self.show_tools_status()
                    elif choice == "8":
                        await self.show_privilege_status()
                    elif choice == "9":
                        await self.show_configuration()
                    
                    if choice != "0":
                        self.console.print()
                        Prompt.ask("[dim]Presiona Enter para continuar...[/dim]", default="")
                        self.console.clear()
                        self.print_banner()
                        
                except KeyboardInterrupt:
                    self.console.print("\n[yellow]‚ö†Ô∏è  Operaci√≥n cancelada[/yellow]")
                    if Confirm.ask("[red]¬øSalir de Aegis?[/red]"):
                        break
                except Exception as e:
                    self.console.print(f"[red]üí• Error inesperado: {str(e)}[/red]")
        
        finally:
            # Cleanup del sistema de logging
            self.console.print()
            log_file = self.tool_logger.get_log_file_path()
            self.console.print(Panel(
                f"üìã [bold cyan]Finalizando Sesi√≥n[/bold cyan]\n\n"
                f"üìÅ Log de sesi√≥n guardado: [green]{log_file.name}[/green]\n"
                f"üìç Ubicaci√≥n: [dim]{log_file.parent}[/dim]\n"
                f"üìä Revisa el archivo para detalles completos del an√°lisis",
                title="Sistema de Logs",
                border_style="cyan"
            ))
            
            # Cleanup del logger
            cleanup_logger()
    
    async def show_privilege_status(self):
        """Muestra el estado detallado de privilegios"""
        # Mostrar loader mientras se verifica el estado de privilegios
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("üîê Verificando privilegios del sistema...", total=None)
            
            # Hacer la verificaci√≥n real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # Peque√±o delay para mostrar el loader
            
            # La verificaci√≥n real ocurre aqu√≠
            progress.update(task, description="üîç Analizando permisos y capacidades...")
            
            try:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.privilege_manager.show_privilege_status()
                )
                progress.update(task, description="‚úÖ Verificaci√≥n de privilegios completada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="‚ùå Error verificando privilegios")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece autom√°ticamente cuando sale del contexto
        # y el estado de privilegios ya est√° mostrado
        
        if not self.privileges_validated:
            self.console.print()
            if Confirm.ask("[yellow]¬øIntentar validar privilegios de administrador ahora?[/yellow]"):
                if ensure_admin_privileges(self.console):
                    self.privileges_validated = True
                    self.console.print("[green]‚úì Privilegios de administrador validados exitosamente[/green]")
                else:
                    self.console.print("[red]‚úó No se pudieron validar los privilegios[/red]") 