"""
CLI principal moderna para Aegis Pentest Automation
Interfaz completamente interactiva sin parÃ¡metros
Con sistema de logging integrado y manejo de privilegios
"""

import asyncio
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from rich.prompt import Prompt, Confirm
from rich import box

from aegis_pentest.core.scanner import AegisScanner
from aegis_pentest.utils.config import Config
from aegis_pentest.utils.installer import ToolInstaller
from aegis_pentest.utils.logger import get_logger, cleanup_logger
from aegis_pentest.utils.privilege_manager import ensure_admin_privileges, get_privilege_manager
from .display import DisplayManager
from .interactive import InteractiveMode


class AegisCLI:
    """Interfaz CLI moderna y enriquecida para Aegis con logging integrado y manejo de privilegios"""
    
    def __init__(self):
        self.console = Console()
        self.config = Config()
        self.installer = ToolInstaller(self.console)
        # Pasar console al scanner para integrar logging
        self.scanner = AegisScanner(self.config, self.console)
        self.display = DisplayManager(self.console)
        self.interactive = InteractiveMode(self.console, self.scanner, self.display)
        self.current_scan = None
        
        # Inicializar sistema de logging
        self.tool_logger = get_logger(self.console)
        
        # Inicializar gestor de privilegios
        self.privilege_manager = get_privilege_manager(self.console)
        self.privileges_validated = False
        
    def check_admin_privileges(self) -> bool:
        """Verifica y solicita privilegios de administrador al inicio"""
        self.console.print(Panel(
            "[bold cyan]ğŸ” VerificaciÃ³n de Privilegios[/bold cyan]\n\n"
            "[yellow]Aegis Pentest requiere privilegios de administrador para:[/yellow]\n"
            "â€¢ Ejecutar escaneos SYN stealth con Nmap\n"
            "â€¢ Detectar servicios y sistemas operativos\n"
            "â€¢ Acceder a funcionalidades avanzadas de pentesting\n\n"
            "[dim]Verificando permisos actuales...[/dim]",
            title="InicializaciÃ³n de Privilegios",
            border_style="cyan"
        ))
        
        # Verificar privilegios actuales
        if self.privilege_manager.is_admin():
            self.console.print("[green]âœ“ EjecutÃ¡ndose como administrador[/green]")
            self.privileges_validated = True
            return True
        
        # Si no somos admin, intentar obtener privilegios sudo
        if ensure_admin_privileges(self.console):
            self.privileges_validated = True
            return True
        else:
            self.console.print(Panel(
                "[bold red]âŒ No se pudieron obtener privilegios de administrador[/bold red]\n\n"
                "[yellow]âš ï¸ El programa puede continuar con funcionalidad limitada:[/yellow]\n"
                "â€¢ Algunos escaneos de Nmap no funcionarÃ¡n\n"
                "â€¢ La detecciÃ³n de OS estarÃ¡ deshabilitada\n"
                "â€¢ Algunas herramientas pueden fallar\n\n"
                "[cyan]RecomendaciÃ³n: Reinicia como administrador para funcionalidad completa[/cyan]",
                title="Privilegios Limitados",
                border_style="yellow"
            ))
            
            if not Confirm.ask("[yellow]Â¿Continuar con privilegios limitados?[/yellow]"):
                return False
            
            self.privileges_validated = False
            return True
    
    def print_banner(self):
        """Muestra el banner de Aegis con informaciÃ³n de logging y privilegios"""
        banner = Text.assemble(
            ("    ___    __________ _____ _____\n", "bold cyan"),
            ("   /   |  / ____/ __ \\_   _/ ___/\n", "bold cyan"),
            ("  / /| | / __/ / / / / // / \\__ \\ \n", "bold cyan"),
            (" / ___ |/ /___/ /_/ _// /_____/ / \n", "bold cyan"),
            ("/_/  |_/_____/\\____/___//____/  \n", "bold cyan"),
            ("\nğŸ›¡ï¸  ", "bold white"),
            ("AutomatizaciÃ³n de Pentesting Web", "bold white"),
            (" ğŸ›¡ï¸\n", "bold white"),
            ("v1.0.0", "dim white")
        )
        
        panel = Panel(
            banner,
            title="[bold red]AEGIS PENTEST AUTOMATION[/bold red]",
            border_style="bright_blue",
            padding=(1, 2)
        )
        self.console.print(panel)
        
        # Mostrar informaciÃ³n del sistema de logging
        log_file = self.tool_logger.get_log_file_path()
        
        # Mostrar estado de privilegios
        privilege_status = "ğŸ” [bold green]Administrador[/bold green]" if self.privileges_validated else "âš ï¸ [bold yellow]Limitado[/bold yellow]"
        privilege_details = "Funcionalidad completa disponible" if self.privileges_validated else "Algunas funciones pueden estar limitadas"
        
        self.console.print(Panel(
            f"ğŸ“‹ [bold cyan]Sistema de Logging Activado[/bold cyan]\n"
            f"ğŸ“ Archivo: [green]{log_file.name}[/green]\n"
            f"ğŸ“ Ruta: [dim]{log_file.parent}[/dim]\n"
            f"âš¡ Monitoreo en tiempo real: [bold green]Activo[/bold green]\n\n"
            f"ğŸ” [bold cyan]Estado de Privilegios[/bold cyan]\n"
            f"ğŸ‘¤ Modo: {privilege_status}\n"
            f"ğŸ“ Estado: [dim]{privilege_details}[/dim]",
            title="Estado del Sistema",
            border_style="cyan",
            padding=(0, 1)
        ))
        self.console.print()
    
    def show_main_menu(self):
        """Muestra el menÃº principal"""
        table = Table(title="ğŸ¯ MenÃº Principal", box=box.ROUNDED)
        table.add_column("OpciÃ³n", style="cyan", min_width=3)
        table.add_column("DescripciÃ³n", style="white")
        table.add_column("Tiempo Est.", style="yellow", justify="center")
        
        table.add_row("1", "[bold cyan]Modo Interactivo[/bold cyan] - Herramientas avanzadas", "Variable")
        table.add_row("2", "[dim]Estado de Herramientas[/dim] - Verificar disponibilidad", "< 1 min")
        table.add_row("3", "[dim]Estado de Privilegios[/dim] - Verificar permisos", "< 1 min")
        table.add_row("4", "[dim]ConfiguraciÃ³n[/dim] - Ajustes del sistema", "< 1 min")
        table.add_row("0", "[bold red]Salir[/bold red]", "")
        
        self.console.print(table)
        self.console.print()
    
    async def show_tools_status(self):
        """Muestra el estado de las herramientas con opciones de instalaciÃ³n"""
        missing_tools = None
        
        # Mostrar loader mientras se verifica el estado de las herramientas
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("ğŸ” Verificando herramientas disponibles...", total=None)
            
            # Hacer la verificaciÃ³n real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # PequeÃ±o delay para mostrar el loader
            
            # La verificaciÃ³n real ocurre aquÃ­
            progress.update(task, description="âš™ï¸ Detectando versiones y rutas...")
            
            # Ejecutar la verificaciÃ³n de manera sÃ­ncrona pero controlada
            try:
                missing_tools = await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.display.show_tools_status(self.config, self.installer)
                )
                # Actualizar el mensaje una vez que termine
                progress.update(task, description="âœ… VerificaciÃ³n completada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="âŒ Error en verificaciÃ³n")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece automÃ¡ticamente cuando sale del contexto
        # y la tabla ya estÃ¡ mostrada por show_tools_status
        
        if missing_tools:
            choice = Prompt.ask(
                "[bold yellow]Â¿QuÃ© deseas hacer?[/bold yellow]",
                choices=["i", "s", "p", ""],
                default=""
            )
            
            if choice == "i":
                # Instalar todas las herramientas faltantes
                await self._install_all_missing_tools(missing_tools)
            elif choice == "s":
                # Seleccionar herramientas especÃ­ficas
                await self._install_selected_tools(missing_tools)
            elif choice == "p":
                # Verificar prerequisitos
                self._show_prerequisites()
    
    async def _install_all_missing_tools(self, tools: list):
        """Instala todas las herramientas faltantes"""
        self.console.print(Panel(
            f"[bold cyan]ğŸ“¦ Instalando {len(tools)} herramientas...[/bold cyan]",
            border_style="cyan"
        ))
        
        if not Confirm.ask(f"[yellow]Â¿Continuar con la instalaciÃ³n de {', '.join(tools)}?[/yellow]"):
            return
        
        results = {}
        successful_installs = []
        
        for tool in tools:
            success, message = await self.installer.install_tool(tool)
            results[tool] = (success, message)
            
            if success:
                successful_installs.append(tool)
        
        # Mostrar resumen de instalaciÃ³n
        self.installer.show_installation_summary(results)
        
        # Si hubo instalaciones exitosas, refrescar la detecciÃ³n de herramientas
        if successful_installs:
            self.console.print(Panel(
                "[bold green]ğŸ”„ Actualizando detecciÃ³n de herramientas...[/bold green]",
                border_style="green"
            ))
            
            # Refrescar la configuraciÃ³n global
            self.config.refresh_tools_detection()
            
            # Mostrar estado actualizado
            self.console.print()
            self.console.print("[bold green]âœ… Estado actualizado de herramientas:[/bold green]")
            updated_missing = self.display.show_tools_status(self.config, self.installer, show_header=False)
            
            if not updated_missing:
                self.console.print("[bold green]ğŸ‰ Â¡Todas las herramientas estÃ¡n ahora disponibles![/bold green]")
            else:
                self.console.print(f"[yellow]â„¹ï¸  Herramientas aÃºn faltantes: {', '.join(updated_missing)}[/yellow]")
                self.console.print("[dim]Puedes intentar instalarlas manualmente o reiniciar la terminal[/dim]")
    
    async def _install_selected_tools(self, tools: list):
        """Permite seleccionar herramientas especÃ­ficas para instalar"""
        self.console.print(Panel(
            "[bold cyan]ğŸ“¦ SelecciÃ³n de Herramientas[/bold cyan]",
            border_style="cyan"
        ))
        
        selected_tools = []
        for tool in tools:
            config = self.installer.tools_config.get(tool, {})
            description = config.get('description', '')
            
            if Confirm.ask(f"[cyan]Â¿Instalar {tool}?[/cyan] [dim]({description})[/dim]"):
                selected_tools.append(tool)
        
        if selected_tools:
            await self._install_all_missing_tools(selected_tools)
        else:
            self.console.print("[yellow]âš ï¸  No se seleccionÃ³ ninguna herramienta[/yellow]")
    
    def _show_prerequisites(self):
        """Muestra el estado de los prerequisitos del sistema"""
        prereqs = self.installer.check_prerequisites()
        
        self.console.print(Panel(
            "[bold cyan]ğŸ” PREREQUISITOS DEL SISTEMA[/bold cyan]",
            border_style="cyan"
        ))
        
        prereq_table = Table(box=box.ROUNDED)
        prereq_table.add_column("Prerequisito", style="cyan")
        prereq_table.add_column("Estado", style="white", justify="center")
        prereq_table.add_column("DescripciÃ³n", style="dim white")
        
        descriptions = {
            'homebrew': 'Gestor de paquetes para macOS',
            'apt': 'Gestor de paquetes para Debian/Ubuntu',
            'yum': 'Gestor de paquetes para RHEL/CentOS',
            'pacman': 'Gestor de paquetes para Arch Linux',
            'go': 'Lenguaje Go para herramientas modernas',
            'git': 'Sistema de control de versiones'
        }
        
        for prereq, available in prereqs.items():
            status = "ğŸŸ¢ Disponible" if available else "ğŸ”´ No disponible"
            description = descriptions.get(prereq, '')
            prereq_table.add_row(prereq.upper(), status, description)
        
        self.console.print(prereq_table)
        
        # Ofrecer instalar prerequisitos faltantes
        missing_prereqs = [name for name, available in prereqs.items() if not available]
        if missing_prereqs:
            self.console.print()
            if Confirm.ask("[yellow]Â¿Instalar prerequisitos faltantes automÃ¡ticamente?[/yellow]"):
                if self.installer.install_prerequisites():
                    self.console.print("[green]âœ“ Prerequisitos instalados correctamente[/green]")
                else:
                    self.console.print("[red]âœ— Error instalando prerequisitos[/red]")
    
    async def show_configuration(self):
        """Muestra la configuraciÃ³n actual"""
        # Mostrar loader mientras se carga la configuraciÃ³n
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("âš™ï¸ Cargando configuraciÃ³n del sistema...", total=None)
            
            # Hacer la carga real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # PequeÃ±o delay para mostrar el loader
            
            # La carga real ocurre aquÃ­
            progress.update(task, description="ğŸ“‹ Recopilando configuraciones...")
            
            try:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.display.show_configuration(self.config)
                )
                progress.update(task, description="âœ… ConfiguraciÃ³n cargada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="âŒ Error cargando configuraciÃ³n")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece automÃ¡ticamente cuando sale del contexto
        # y la configuraciÃ³n ya estÃ¡ mostrada
    
    async def run(self):
        """Bucle principal de la CLI"""
        try:
            if not self.check_admin_privileges():
                return
            
            self.print_banner()
            
            while True:
                self.show_main_menu()
                
                choice = Prompt.ask(
                    "[bold yellow]Selecciona una opciÃ³n[/bold yellow]",
                    choices=["0", "1", "2", "3", "4"],
                    default="1"
                )
                
                self.console.print()
                
                try:
                    if choice == "0":
                        self.console.print("[bold red]ğŸ‘‹ Â¡Hasta luego![/bold red]")
                        break
                    elif choice == "1":
                        await self.interactive.run()
                    elif choice == "2":
                        await self.show_tools_status()
                    elif choice == "3":
                        await self.show_privilege_status()
                    elif choice == "4":
                        await self.show_configuration()
                    
                    if choice != "0":
                        self.console.print()
                        Prompt.ask("[dim]Presiona Enter para continuar...[/dim]", default="")
                        self.console.clear()
                        self.print_banner()
                        
                except KeyboardInterrupt:
                    self.console.print("\n[yellow]âš ï¸  OperaciÃ³n cancelada[/yellow]")
                    if Confirm.ask("[red]Â¿Salir de Aegis?[/red]"):
                        break
                except Exception as e:
                    self.console.print(f"[red]ğŸ’¥ Error inesperado: {str(e)}[/red]")
        
        finally:
            # Cleanup del sistema de logging
            self.console.print()
            log_file = self.tool_logger.get_log_file_path()
            self.console.print(Panel(
                f"ğŸ“‹ [bold cyan]Finalizando SesiÃ³n[/bold cyan]\n\n"
                f"ğŸ“ Log de sesiÃ³n guardado: [green]{log_file.name}[/green]\n"
                f"ğŸ“ UbicaciÃ³n: [dim]{log_file.parent}[/dim]\n"
                f"ğŸ“Š Revisa el archivo para detalles completos del anÃ¡lisis",
                title="Sistema de Logs",
                border_style="cyan"
            ))
            
            # Cleanup del logger
            cleanup_logger()
    
    async def show_privilege_status(self):
        """Muestra el estado detallado de privilegios"""
        # Mostrar loader mientras se verifica el estado de privilegios
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("ğŸ” Verificando privilegios del sistema...", total=None)
            
            # Hacer la verificaciÃ³n real durante el loader
            import asyncio
            await asyncio.sleep(0.1)  # PequeÃ±o delay para mostrar el loader
            
            # La verificaciÃ³n real ocurre aquÃ­
            progress.update(task, description="ğŸ” Analizando permisos y capacidades...")
            
            try:
                await asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: self.privilege_manager.show_privilege_status()
                )
                progress.update(task, description="âœ… VerificaciÃ³n de privilegios completada")
                await asyncio.sleep(0.1)  # Breve pausa para mostrar el mensaje final
            except Exception as e:
                progress.update(task, description="âŒ Error verificando privilegios")
                await asyncio.sleep(0.1)
                raise e
        
        # El loader desaparece automÃ¡ticamente cuando sale del contexto
        # y el estado de privilegios ya estÃ¡ mostrado
        
        if not self.privileges_validated:
            self.console.print()
            if Confirm.ask("[yellow]Â¿Intentar validar privilegios de administrador ahora?[/yellow]"):
                if ensure_admin_privileges(self.console):
                    self.privileges_validated = True
                    self.console.print("[green]âœ“ Privilegios de administrador validados exitosamente[/green]")
                else:
                    self.console.print("[red]âœ— No se pudieron validar los privilegios[/red]") 