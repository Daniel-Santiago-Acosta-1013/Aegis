"""
Sistema de instalación automática de herramientas para Aegis Pentest
"""

import platform
import subprocess
import shutil
from pathlib import Path
from typing import Dict, List, Tuple
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
import asyncio
import os
import sys

# Import Config to resolve "Config no está definido" error
from .config import Config

class ToolInstaller:
    """Instalador automático de herramientas de pentesting"""
    
    def __init__(self, console: Console = None):
        self.console = console or Console()
        self.system = platform.system().lower()
        self.arch = platform.machine().lower()
        
        # Configuración de instaladores por sistema operativo
        self.installers = {
            'darwin': {  # macOS
                'package_manager': 'brew',
                'install_cmd': ['brew', 'install'],
                'update_cmd': ['brew', 'update'],
                'check_cmd': ['brew', '--version']
            },
            'linux': {
                'package_manager': 'apt',  # Por defecto, detectar específico después
                'install_cmd': ['sudo', 'apt', 'install', '-y'],
                'update_cmd': ['sudo', 'apt', 'update'],
                'check_cmd': ['apt', '--version']
            }
        }
        
        # Configuración específica de herramientas
        self.tools_config = {
            'nmap': {
                'description': 'Scanner de puertos y detección de servicios',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nmap']
                    },
                    'linux': {
                        'apt': ['nmap']
                    }
                }
            },
            'nuclei': {
                'description': 'Scanner de vulnerabilidades basado en templates',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nuclei'],
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                        'binary': 'https://github.com/projectdiscovery/nuclei/releases/latest/download/nuclei_3.2.0_linux_amd64.zip'
                    }
                },
                'post_install': self._setup_nuclei_templates
            },
            'gobuster': {
                'description': 'Herramienta de fuerza bruta para directorios/archivos',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['gobuster']
                    },
                    'linux': {
                        'apt': ['gobuster'],
                        'go': 'github.com/OJ/gobuster/v3@latest'
                    }
                }
            },
            'nikto': {
                'description': 'Scanner de vulnerabilidades web',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nikto']
                    },
                    'linux': {
                        'apt': ['nikto']
                    }
                }
            },
            'sqlmap': {
                'description': 'Herramienta de detección de inyección SQL',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['sqlmap']
                    },
                    'linux': {
                        'apt': ['sqlmap']
                    }
                }
            },
            'hydra': {
                'description': 'Herramienta de ataques de fuerza bruta',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['hydra']
                    },
                    'linux': {
                        'apt': ['hydra']
                    }
                }
            },
            'subfinder': {
                'description': 'Enumeración rápida de subdominios',
                'install_methods': {
                    'darwin': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    }
                },
                'post_install': self._auto_detect_go_tools
            },
            'ffuf': {
                'description': 'Fuzzer web rápido y flexible',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['ffuf'],
                        'go': 'github.com/ffuf/ffuf@latest'
                    },
                    'linux': {
                        'apt': ['ffuf'],
                        'go': 'github.com/ffuf/ffuf@latest'
                    }
                }
            },
            'zap-baseline.py': {
                'description': 'Proxy de seguridad OWASP ZAP',
                'install_methods': {
                    'darwin': {
                        'homebrew_cask': ['zap']
                    },
                    'linux': {
                        'apt': ['zaproxy']
                    }
                },
                'post_install': self._auto_setup_zap
            },
            'shodan': {
                'description': 'CLI para inteligencia de infraestructura Shodan',
                'install_methods': {
                    'darwin': {
                        'pip': ['shodan']
                    },
                    'linux': {
                        'pip': ['shodan']
                    }
                }
            },
            'traceroute': {
                'description': 'Herramienta de análisis de rutas de red',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['traceroute']
                    },
                    'linux': {
                        'apt': ['traceroute']
                    }
                }
            },
            'w3af_console': {
                'description': 'Framework de auditoría de aplicaciones web',
                'install_methods': {
                    'darwin': {
                        'manual': 'https://github.com/andresriancho/w3af'
                    },
                    'linux': {
                        'apt': ['w3af'],
                        'manual': 'https://github.com/andresriancho/w3af'
                    }
                },
                'post_install': self._setup_w3af_dependencies
            },
            'censys': {
                'description': 'CLI para motor de búsqueda Censys',
                'install_methods': {
                    'darwin': {
                        'pip': ['censys']
                    },
                    'linux': {
                        'pip': ['censys']
                    }
                }
            },
            'openssl': {
                'description': 'Herramienta para análisis SSL/TLS y criptografía',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['openssl']
                    },
                    'linux': {
                        'apt': ['openssl']
                    }
                }
            },
            'nginxpwner': {
                'description': 'Herramienta de análisis de configuraciones Nginx',
                'install_methods': {
                    'darwin': {
                        'manual': 'https://github.com/stark0de/nginxpwner'
                    },
                    'linux': {
                        'manual': 'https://github.com/stark0de/nginxpwner'
                    }
                }
            },
            'apache_vuln': {
                'description': 'Testing de vulnerabilidades Apache personalizadas',
                'install_methods': {
                    'darwin': {
                        'manual': 'Script personalizado incluido en Aegis'
                    },
                    'linux': {
                        'manual': 'Script personalizado incluido en Aegis'
                    }
                }
            }
        }
    
    def check_prerequisites(self) -> Dict[str, bool]:
        """Verifica los prerequisitos del sistema"""
        prereqs = {}
        
        if self.system == 'darwin':
            # Verificar Homebrew
            prereqs['homebrew'] = shutil.which('brew') is not None
            prereqs['homebrew_cask'] = shutil.which('brew') is not None  # Cask requiere brew
            
        elif self.system == 'linux':
            # Verificar gestores de paquetes
            prereqs['apt'] = shutil.which('apt') is not None
            prereqs['yum'] = shutil.which('yum') is not None
            prereqs['pacman'] = shutil.which('pacman') is not None
        
        # Verificar Go (común para muchas herramientas)
        prereqs['go'] = shutil.which('go') is not None
        
        # Verificar Git
        prereqs['git'] = shutil.which('git') is not None
        
        # Verificar Python/pip - mejorar detección de entornos virtuales
        pip_available = False
        pip3_available = False
        
        # Verificar pip y pip3
        if shutil.which('pip'):
            pip_available = True
        if shutil.which('pip3'):
            pip3_available = True
            
        # En entornos virtuales, usar pip directamente sin --user
        in_venv = (hasattr(sys, 'real_prefix') or 
                  (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix) or
                  os.environ.get('VIRTUAL_ENV'))
        
        prereqs['pip'] = pip_available or pip3_available
        prereqs['in_venv'] = in_venv
        
        # Verificar Node.js/npm
        prereqs['npm'] = shutil.which('npm') is not None
        
        return prereqs
    
    def install_prerequisites(self) -> bool:
        """Instala prerequisitos básicos"""
        self.console.print(Panel(
            "[bold cyan]📦 Instalando prerequisitos...[/bold cyan]",
            border_style="cyan"
        ))
        
        if self.system == 'darwin':
            return self._install_homebrew()
        elif self.system == 'linux':
            return self._install_linux_prerequisites()
        
        return False
    
    def _install_homebrew(self) -> bool:
        """Instala Homebrew en macOS"""
        if shutil.which('brew'):
            self.console.print("[green]✓ Homebrew ya está instalado[/green]")
            return True
        
        self.console.print("[yellow]⚡ Instalando Homebrew...[/yellow]")
        
        try:
            install_script = '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
            result = subprocess.run(install_script, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.console.print("[green]✓ Homebrew instalado correctamente[/green]")
                return True
            else:
                self.console.print(f"[red]✗ Error instalando Homebrew: {result.stderr}[/red]")
                return False
                
        except Exception as e:
            self.console.print(f"[red]✗ Error instalando Homebrew: {str(e)}[/red]")
            return False
    
    def _install_linux_prerequisites(self) -> bool:
        """Instala prerequisitos en Linux"""
        # Actualizar repositorios
        if shutil.which('apt'):
            try:
                self.console.print("[yellow]⚡ Actualizando repositorios...[/yellow]")
                subprocess.run(['sudo', 'apt', 'update'], check=True, capture_output=True)
                self.console.print("[green]✓ Repositorios actualizados[/green]")
                return True
            except subprocess.CalledProcessError as e:
                self.console.print(f"[red]✗ Error actualizando repositorios: {e}[/red]")
                return False
        
        return True
    
    def get_available_tools(self) -> List[str]:
        """Obtiene lista de herramientas disponibles para instalar"""
        return list(self.tools_config.keys())
    
    def is_tool_installable(self, tool_name: str) -> bool:
        """Verifica si una herramienta se puede instalar en el sistema actual"""
        if tool_name not in self.tools_config:
            return False
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config.get('install_methods', {})
        
        return self.system in install_methods
    
    def get_install_methods(self, tool_name: str) -> List[str]:
        """Obtiene métodos de instalación disponibles para una herramienta"""
        if not self.is_tool_installable(tool_name):
            return []
        
        methods = self.tools_config[tool_name]['install_methods'][self.system]
        available_methods = []
        
        prereqs = self.check_prerequisites()
        
        for method in methods.keys():
            if method == 'homebrew' and prereqs.get('homebrew'):
                available_methods.append(method)
            elif method == 'homebrew_cask' and prereqs.get('homebrew_cask'):
                available_methods.append(method)
            elif method == 'apt' and prereqs.get('apt'):
                available_methods.append(method)
            elif method == 'go' and prereqs.get('go'):
                available_methods.append(method)
            elif method == 'pip' and prereqs.get('pip'):
                available_methods.append(method)
            elif method == 'npm' and prereqs.get('npm'):
                available_methods.append(method)
            elif method == 'binary':
                available_methods.append(method)
            elif method == 'manual':
                available_methods.append(method)
        
        return available_methods
    
    async def install_tool(self, tool_name: str, method: str = None) -> Tuple[bool, str]:
        """Instala una herramienta específica"""
        if not self.is_tool_installable(tool_name):
            return False, f"La herramienta {tool_name} no es instalable en {self.system}"
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config['install_methods'][self.system]
        
        # Si no se especifica método, usar el primero disponible
        if not method:
            available_methods = self.get_install_methods(tool_name)
            if not available_methods:
                return False, f"No hay métodos de instalación disponibles para {tool_name}"
            method = available_methods[0]
        
        if method not in install_methods:
            return False, f"Método de instalación '{method}' no disponible para {tool_name}"
        
        self.console.print(Panel(
            f"[bold cyan]📦 Instalando {tool_name}...[/bold cyan]\n"
            f"[dim]{tool_config['description']}[/dim]\n"
            f"[yellow]Método: {method}[/yellow]",
            border_style="cyan"
        ))
        
        try:
            success = False
            
            if method == 'homebrew':
                success = await self._install_via_homebrew(tool_name, install_methods[method])
            elif method == 'homebrew_cask':
                success = await self._install_via_homebrew_cask(tool_name, install_methods[method])
            elif method == 'apt':
                success = await self._install_via_apt(tool_name, install_methods[method])
            elif method == 'go':
                success = await self._install_via_go(tool_name, install_methods[method])
            elif method == 'pip':
                success = await self._install_via_pip(tool_name, install_methods[method])
            elif method == 'npm':
                success = await self._install_via_npm(tool_name, install_methods[method])
            elif method == 'binary':
                success = await self._install_via_binary(tool_name, install_methods[method])
            elif method == 'manual':
                success = await self._install_via_manual(tool_name, install_methods[method])
            
            if success:
                # Ejecutar configuración post-instalación si existe
                if 'post_install' in tool_config:
                    await tool_config['post_install'](tool_name)
                
                # Verificar que realmente esté disponible después de la instalación
                self.console.print("[yellow]🔍 Verificando instalación...[/yellow]")
                await asyncio.sleep(1)  # Esperar un momento para que el sistema detecte la nueva instalación
                
                # Importar config y forzar re-detección
                config = Config()
                
                # Forzar detección de la herramienta recién instalada
                is_available = config.force_tool_detection(tool_name)
                
                if is_available:
                    tool_path = config.get_tool_path(tool_name)
                    self.console.print(f"[bold green]✓ {tool_name} instalado y verificado correctamente[/bold green]")
                    self.console.print(f"[dim]Ruta: {tool_path}[/dim]")
                    return True, f"{tool_name} instalado y verificado en {tool_path}"
                else:
                    # Intentar búsqueda manual adicional
                    manual_path = self._manual_tool_search(tool_name)
                    if manual_path:
                        config.set(f'tools.{tool_name}.path', manual_path)
                        config.save()
                        self.console.print(f"[bold green]✓ {tool_name} encontrado manualmente y configurado[/bold green]")
                        self.console.print(f"[dim]Ruta: {manual_path}[/dim]")
                        return True, f"{tool_name} instalado y configurado en {manual_path}"
                    else:
                        self.console.print(f"[yellow]⚠️ {tool_name} parece instalado pero no se detecta automáticamente[/yellow]")
                        self.console.print("[dim]Intenta ejecutar el comando manualmente para verificar[/dim]")
                        return False, f"{tool_name} instalado pero no detectado automáticamente"
            else:
                return False, f"Error instalando {tool_name}"
                
        except Exception as e:
            error_msg = f"Error instalando {tool_name}: {str(e)}"
            self.console.print(f"[red]✗ {error_msg}[/red]")
            return False, error_msg
    
    async def _install_via_homebrew(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta vía Homebrew"""
        for package in packages:
            cmd = ['brew', 'install', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_homebrew_cask(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta vía Homebrew Cask"""
        for package in packages:
            cmd = ['brew', 'install', '--cask', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_apt(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta vía APT"""
        for package in packages:
            cmd = ['sudo', 'apt', 'install', '-y', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_go(self, tool_name: str, package: str) -> bool:
        """Instala herramienta vía Go"""
        cmd = ['go', 'install', '-v', package]
        return await self._run_command(cmd)
    
    async def _install_via_pip(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta vía pip"""
        pip_cmd = 'pip3' if shutil.which('pip3') else 'pip'
        
        # Verificar si estamos en un entorno virtual
        prereqs = self.check_prerequisites()
        in_venv = prereqs.get('in_venv', False)
        
        for package in packages:
            if in_venv:
                # En entornos virtuales no usar --user
                cmd = [pip_cmd, 'install', package]
            else:
                # En sistema global usar --user
                cmd = [pip_cmd, 'install', '--user', package]
            
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_npm(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta vía npm"""
        for package in packages:
            cmd = ['npm', 'install', '-g', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_manual(self, tool_name: str, info: str) -> bool:
        """Maneja instalación manual"""
        if tool_name == 'nginxpwner':
            return await self._install_nginxpwner()
        elif tool_name == 'apache_vuln':
            return await self._install_apache_vuln()
        elif tool_name == 'w3af_console':
            return await self._install_w3af()
        else:
            self.console.print(f"[yellow]ℹ️  Instalación manual requerida para {tool_name}[/yellow]")
            self.console.print(f"[dim]Información: {info}[/dim]")
            self.console.print("[dim]Consulta la documentación oficial para instalación manual[/dim]")
            return False
    
    async def _install_nginxpwner(self) -> bool:
        """Instala nginxpwner desde GitHub"""
        try:
            # Crear directorio external-tools si no existe
            external_dir = Path('./external-tools')
            external_dir.mkdir(exist_ok=True)
            
            # Clonar repositorio
            cmd = ['git', 'clone', 'https://github.com/stark0de/nginxpwner.git', './external-tools/nginxpwner']
            success = await self._run_command(cmd)
            if success:
                # Hacer ejecutable
                script_path = Path('./external-tools/nginxpwner/nginxpwner.py')
                if script_path.exists():
                    script_path.chmod(0o755)
                    self.console.print(f"[green]✓ nginxpwner clonado en {script_path.parent.absolute()}[/green]")
                    return True
            return False
        except Exception as e:
            self.console.print(f"[red]Error instalando nginxpwner: {e}[/red]")
            return False
    
    async def _install_apache_vuln(self) -> bool:
        """Configura el script apache_vuln personalizado"""
        # Verificar que el script correcto existe en external-tools
        script_path = Path('./external-tools/apache-vuln/apache_vuln.py')
        
        if script_path.exists():
            # El script ya existe, verificar que sea ejecutable
            if not os.access(script_path, os.X_OK):
                script_path.chmod(0o755)
            self.console.print(f"[green]✓ Apache vuln script ya disponible en {script_path.absolute()}[/green]")
            return True
        
        # Si no existe, crear el directorio y script básico
        script_path.parent.mkdir(parents=True, exist_ok=True)
        
        script_content = '''#!/usr/bin/env python3
"""
Script básico de testing de vulnerabilidades Apache
Integrado con Aegis Pentest Automation
"""
import sys
import argparse
import requests
import re

def main():
    parser = argparse.ArgumentParser(description='Apache Vulnerability Testing')
    parser.add_argument('target', help='Target URL or IP')
    parser.add_argument('--output', '-o', help='Output file')
    parser.add_argument('--timeout', '-t', type=int, default=10, help='Request timeout')
    
    args = parser.parse_args()
    
    target = args.target
    if not target.startswith(('http://', 'https://')):
        target = f"https://{target}"
    
    print(f"[+] Testing Apache vulnerabilities for: {target}")
    
    try:
        # Test básico de servidor Apache
        response = requests.get(target, timeout=args.timeout, verify=False)
        server_header = response.headers.get('Server', '')
        
        if 'apache' in server_header.lower():
            print(f"[+] Apache server detected: {server_header}")
            
            # Verificar server-status
            for path in ['/server-status', '/server-status/', '/apache-status']:
                try:
                    url = target.rstrip('/') + path
                    resp = requests.get(url, timeout=args.timeout, verify=False)
                    if resp.status_code == 200 and 'apache server status' in resp.text.lower():
                        print(f"[!] Server-status accessible: {url}")
                except:
                    continue
        else:
            print("[-] Apache not detected in Server header")
    
    except Exception as e:
        print(f"[-] Error testing target: {e}")
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write(f"Apache vulnerability test results for {args.target}\\n")
            f.write(f"Target: {target}\\n")
            f.write("Test completed\\n")

if __name__ == "__main__":
    main()
'''
        
        with open(script_path, 'w') as f:
            f.write(script_content)
        script_path.chmod(0o755)
        
        self.console.print(f"[green]✓ Apache vuln script creado en {script_path.absolute()}[/green]")
        return True
    
    async def _install_w3af(self) -> bool:
        """Instala w3af desde GitHub"""
        try:
            # Crear directorio external-tools si no existe
            external_dir = Path('./external-tools')
            external_dir.mkdir(exist_ok=True)
            
            # Verificar si ya existe el directorio
            w3af_dir = Path('./external-tools/w3af')
            if w3af_dir.exists():
                self.console.print(f"[yellow]⚠️  Directorio w3af ya existe, actualizando...[/yellow]")
                # Actualizar repositorio existente
                cmd = ['git', '-C', './external-tools/w3af', 'pull']
                await self._run_command(cmd)
            else:
                # Clonar repositorio
                cmd = ['git', 'clone', 'https://github.com/andresriancho/w3af.git', './external-tools/w3af']
                success = await self._run_command(cmd)
                if not success:
                    return False
            
            # Verificar que el directorio se creó correctamente
            if not w3af_dir.exists():
                self.console.print(f"[red]✗ No se pudo crear el directorio w3af[/red]")
                return False
            
            self.console.print("[yellow]⚡ Configurando w3af...[/yellow]")
            
            # Buscar script de instalación de dependencias
            possible_scripts = [
                w3af_dir / 'w3af_dependency_install.sh',
                w3af_dir / 'tmp' / 'w3af_dependency_install.sh',
                w3af_dir / 'extras' / 'w3af_dependency_install.sh'
            ]
            
            script_found = None
            for script in possible_scripts:
                if script.exists():
                    script_found = script
                    break
            
            if script_found:
                # Hacer ejecutable y ejecutar
                script_found.chmod(0o755)
                install_cmd = ['bash', str(script_found)]
                dep_success = await self._run_command(install_cmd)
            else:
                # Instalación manual de dependencias básicas de Python
                self.console.print("[yellow]⚡ Instalando dependencias de Python para w3af...[/yellow]")
                
                # Verificar si estamos en un entorno virtual
                prereqs = self.check_prerequisites()
                in_venv = prereqs.get('in_venv', False)
                pip_cmd = 'pip3' if shutil.which('pip3') else 'pip'
                
                # Dependencias básicas de w3af
                w3af_deps = [
                    'pyclamd', 'PyGithub', 'GitPython', 'pybloomfiltermmap3',
                    'phply', 'nltk', 'chardet', 'tblib', 'pdfminer', 'futures',
                    'pyOpenSSL', 'lxml', 'scapy', 'guess_language', 'cluster',
                    'msgpack-python', 'python-ntlm', 'halberd', 'darts.util.lru',
                    'Jinja2', 'vulndb', 'markdown'
                ]
                
                for dep in w3af_deps:
                    try:
                        if in_venv:
                            cmd = [pip_cmd, 'install', dep]
                        else:
                            cmd = [pip_cmd, 'install', '--user', dep]
                        await self._run_command(cmd)
                    except:
                        # Continuar con otras dependencias si una falla
                        continue
                
                dep_success = True
            
            if dep_success:
                # Verificar que w3af_console existe
                w3af_console = w3af_dir / 'w3af_console'
                if not w3af_console.exists():
                    # Buscar otros posibles ejecutables
                    possible_executables = [
                        w3af_dir / 'w3af_console.py',
                        w3af_dir / 'w3af_gui',
                        w3af_dir / 'w3af'
                    ]
                    
                    for exe in possible_executables:
                        if exe.exists():
                            exe.chmod(0o755)
                            break
                
                self.console.print(f"[green]✓ w3af configurado en {w3af_dir.absolute()}[/green]")
                return True
            else:
                self.console.print(f"[yellow]⚠️ w3af clonado pero puede requerir configuración manual de dependencias[/yellow]")
                return True  # Considerar éxito parcial
                
        except Exception as e:
            self.console.print(f"[red]Error instalando w3af: {e}[/red]")
            return False
    
    async def _install_via_binary(self, tool_name: str, url: str) -> bool:
        """Instala herramienta descargando binario"""
        self.console.print("[yellow]⚡ Descargando binario...[/yellow]")
        # TODO: Implementar descarga de binarios específicos
        self.console.print(f"[yellow]ℹ️  Descarga manual requerida desde: {url}[/yellow]")
        return False
    
    async def _run_command(self, cmd: List[str]) -> bool:
        """Ejecuta un comando del sistema"""
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                task = progress.add_task(f"Ejecutando: {' '.join(cmd)}", total=None)
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    return True
                else:
                    self.console.print(f"[red]Error: {stderr.decode()}[/red]")
                    return False
                    
        except Exception as e:
            self.console.print(f"[red]Error ejecutando comando: {str(e)}[/red]")
            return False
    
    async def _setup_nuclei_templates(self, tool_name: str):
        """Configuración post-instalación para Nuclei"""
        self.console.print("[yellow]⚡ Descargando templates de Nuclei...[/yellow]")
        
        templates_dir = Path.home() / 'nuclei-templates'
        if templates_dir.exists():
            self.console.print("[green]✓ Templates ya existen[/green]")
            return
        
        # Clonar repositorio de templates
        cmd = ['git', 'clone', 'https://github.com/projectdiscovery/nuclei-templates.git', str(templates_dir)]
        success = await self._run_command(cmd)
        
        if success:
            self.console.print("[green]✓ Templates de Nuclei descargados[/green]")
        else:
            self.console.print("[red]✗ Error descargando templates de Nuclei[/red]")
    
    async def _setup_w3af_dependencies(self, tool_name: str):
        """Configuración post-instalación para w3af"""
        self.console.print("[yellow]⚡ Configurando w3af...[/yellow]")
        
        w3af_dir = Path('./external-tools/w3af')
        if not w3af_dir.exists():
            self.console.print("[red]✗ Directorio w3af no encontrado[/red]")
            return
        
        # Verificar ejecutables de w3af
        possible_executables = [
            w3af_dir / 'w3af_console',
            w3af_dir / 'w3af_console.py',
            w3af_dir / 'w3af'
        ]
        
        for exe in possible_executables:
            if exe.exists():
                exe.chmod(0o755)
                self.console.print(f"[green]✓ Ejecutable w3af configurado: {exe}[/green]")
                break
        
        self.console.print("[green]✓ w3af configurado correctamente[/green]")
    
    def show_installation_summary(self, results: Dict[str, Tuple[bool, str]]):
        """Muestra resumen de instalaciones"""
        self.console.print(Panel(
            "[bold cyan]📊 RESUMEN DE INSTALACIÓN[/bold cyan]",
            border_style="cyan"
        ))
        
        successful = []
        failed = []
        
        for tool, (success, message) in results.items():
            if success:
                successful.append(tool)
                self.console.print(f"[green]✓ {tool}[/green]: {message}")
            else:
                failed.append(tool)
                self.console.print(f"[red]✗ {tool}[/red]: {message}")
        
        self.console.print()
        self.console.print(f"[bold green]Exitosas: {len(successful)}[/bold green]")
        self.console.print(f"[bold red]Fallidas: {len(failed)}[/bold red]")
        
        if failed:
            self.console.print()
            self.console.print("[yellow]⚠️  Herramientas que fallaron pueden instalarse manualmente:[/yellow]")
            for tool in failed:
                config = self.tools_config.get(tool, {})
                self.console.print(f"  • {tool}: {config.get('description', '')}")
    
    def _manual_tool_search(self, tool_name: str) -> str:
        """Búsqueda manual adicional de herramientas en ubicaciones específicas"""
        import shutil
        
        # Primero probar shutil.which de nuevo (puede que PATH se haya actualizado)
        tool_path = shutil.which(tool_name)
        if tool_path:
            return tool_path
        
        # Rutas adicionales específicas del sistema
        additional_paths = []
        
        if self.system == 'darwin':
            additional_paths = [
                f"/usr/local/bin/{tool_name}",
                f"/opt/homebrew/bin/{tool_name}",
                f"/usr/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                f"/usr/local/Cellar/*/bin/{tool_name}",  # Homebrew específico
            ]
        elif self.system == 'linux':
            additional_paths = [
                f"/usr/bin/{tool_name}",
                f"/usr/local/bin/{tool_name}",
                f"/opt/{tool_name}/{tool_name}",
                f"/snap/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                str(Path.home() / ".local" / "bin" / tool_name),
            ]
        
        for path in additional_paths:
            if "*" in path:
                # Manejar rutas con wildcards
                import glob
                matches = glob.glob(path)
                for match in matches:
                    if Path(match).exists() and os.access(match, os.X_OK):
                        return match
            else:
                if Path(path).exists() and os.access(path, os.X_OK):
                    return path
        
        return ""

    async def _auto_setup_zap(self, tool_name: str):
        """Configuración automática para ZAP"""
        self.console.print("[yellow]⚡ Configurando ZAP automáticamente...[/yellow]")
        
        # Forzar detección automática
        config = Config()
        if config.is_tool_available('zap-baseline.py'):
            self.console.print("[green]✓ ZAP configurado automáticamente[/green]")
        else:
            self.console.print("[yellow]⚠️ ZAP instalado, wrapper será creado automáticamente cuando sea necesario[/yellow]")
        
        return True
    
    async def _auto_detect_go_tools(self, tool_name: str):
        """Detección automática de herramientas Go después de la instalación"""
        import os
        self.console.print(f"[yellow]⚡ Detectando {tool_name} automáticamente...[/yellow]")
        
        # Actualizar PATH para incluir Go bin
        go_bin_path = str(Path.home() / 'go' / 'bin')
        current_path = os.environ.get('PATH', '')
        
        if go_bin_path not in current_path:
            os.environ['PATH'] = f"{go_bin_path}:{current_path}"
        
        # Forzar detección
        config = Config()
        if config.force_tool_detection(tool_name):
            self.console.print(f"[green]✓ {tool_name} detectado automáticamente[/green]")
            return True
        else:
            self.console.print(f"[yellow]⚠️ {tool_name} instalado pero requiere reinicio de shell[/yellow]")
            return True 