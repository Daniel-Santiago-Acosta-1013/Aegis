"""
Sistema de instalaci√≥n autom√°tica de herramientas para Aegis Pentest
"""

import platform
import subprocess
import shutil
from pathlib import Path
from typing import Dict, List, Tuple
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel

class ToolInstaller:
    """Instalador autom√°tico de herramientas de pentesting"""
    
    def __init__(self, console: Console = None):
        self.console = console or Console()
        self.system = platform.system().lower()
        self.arch = platform.machine().lower()
        
        # Configuraci√≥n de instaladores por sistema operativo
        self.installers = {
            'darwin': {  # macOS
                'package_manager': 'brew',
                'install_cmd': ['brew', 'install'],
                'update_cmd': ['brew', 'update'],
                'check_cmd': ['brew', '--version']
            },
            'linux': {
                'package_manager': 'apt',  # Por defecto, detectar espec√≠fico despu√©s
                'install_cmd': ['sudo', 'apt', 'install', '-y'],
                'update_cmd': ['sudo', 'apt', 'update'],
                'check_cmd': ['apt', '--version']
            }
        }
        
        # Configuraci√≥n espec√≠fica de herramientas
        self.tools_config = {
            'nuclei': {
                'description': 'Scanner de vulnerabilidades basado en templates',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nuclei'],
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                        'binary': 'https://github.com/projectdiscovery/nuclei/releases/latest/download/nuclei_3.2.0_linux_amd64.zip'
                    }
                },
                'post_install': self._setup_nuclei_templates
            },
            'gobuster': {
                'description': 'Herramienta de fuerza bruta para directorios/archivos',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['gobuster']
                    },
                    'linux': {
                        'apt': ['gobuster'],
                        'go': 'github.com/OJ/gobuster/v3@latest'
                    }
                }
            },
            'nikto': {
                'description': 'Scanner de vulnerabilidades web',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nikto']
                    },
                    'linux': {
                        'apt': ['nikto']
                    }
                }
            },
            'sqlmap': {
                'description': 'Herramienta de detecci√≥n de inyecci√≥n SQL',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['sqlmap']
                    },
                    'linux': {
                        'apt': ['sqlmap']
                    }
                }
            },
            'hydra': {
                'description': 'Herramienta de ataques de fuerza bruta',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['hydra']
                    },
                    'linux': {
                        'apt': ['hydra']
                    }
                }
            },
            'subfinder': {
                'description': 'Herramienta de enumeraci√≥n de subdominios',
                'install_methods': {
                    'darwin': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    }
                }
            },
            'openssl': {
                'description': 'Herramienta para an√°lisis SSL/TLS y criptograf√≠a',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['openssl']
                    },
                    'linux': {
                        'apt': ['openssl']
                    }
                }
            }
        }
    
    def check_prerequisites(self) -> Dict[str, bool]:
        """Verifica los prerequisitos del sistema"""
        prereqs = {}
        
        if self.system == 'darwin':
            # Verificar Homebrew
            prereqs['homebrew'] = shutil.which('brew') is not None
            
        elif self.system == 'linux':
            # Verificar gestores de paquetes
            prereqs['apt'] = shutil.which('apt') is not None
            prereqs['yum'] = shutil.which('yum') is not None
            prereqs['pacman'] = shutil.which('pacman') is not None
        
        # Verificar Go (com√∫n para muchas herramientas)
        prereqs['go'] = shutil.which('go') is not None
        
        # Verificar Git
        prereqs['git'] = shutil.which('git') is not None
        
        return prereqs
    
    def install_prerequisites(self) -> bool:
        """Instala prerequisitos b√°sicos"""
        self.console.print(Panel(
            "[bold cyan]üì¶ Instalando prerequisitos...[/bold cyan]",
            border_style="cyan"
        ))
        
        if self.system == 'darwin':
            return self._install_homebrew()
        elif self.system == 'linux':
            return self._install_linux_prerequisites()
        
        return False
    
    def _install_homebrew(self) -> bool:
        """Instala Homebrew en macOS"""
        if shutil.which('brew'):
            self.console.print("[green]‚úì Homebrew ya est√° instalado[/green]")
            return True
        
        self.console.print("[yellow]‚ö° Instalando Homebrew...[/yellow]")
        
        try:
            install_script = '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
            result = subprocess.run(install_script, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.console.print("[green]‚úì Homebrew instalado correctamente[/green]")
                return True
            else:
                self.console.print(f"[red]‚úó Error instalando Homebrew: {result.stderr}[/red]")
                return False
                
        except Exception as e:
            self.console.print(f"[red]‚úó Error instalando Homebrew: {str(e)}[/red]")
            return False
    
    def _install_linux_prerequisites(self) -> bool:
        """Instala prerequisitos en Linux"""
        # Actualizar repositorios
        if shutil.which('apt'):
            try:
                self.console.print("[yellow]‚ö° Actualizando repositorios...[/yellow]")
                subprocess.run(['sudo', 'apt', 'update'], check=True, capture_output=True)
                self.console.print("[green]‚úì Repositorios actualizados[/green]")
                return True
            except subprocess.CalledProcessError as e:
                self.console.print(f"[red]‚úó Error actualizando repositorios: {e}[/red]")
                return False
        
        return True
    
    def get_available_tools(self) -> List[str]:
        """Obtiene lista de herramientas disponibles para instalar"""
        return list(self.tools_config.keys())
    
    def is_tool_installable(self, tool_name: str) -> bool:
        """Verifica si una herramienta se puede instalar en el sistema actual"""
        if tool_name not in self.tools_config:
            return False
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config.get('install_methods', {})
        
        return self.system in install_methods
    
    def get_install_methods(self, tool_name: str) -> List[str]:
        """Obtiene m√©todos de instalaci√≥n disponibles para una herramienta"""
        if not self.is_tool_installable(tool_name):
            return []
        
        methods = self.tools_config[tool_name]['install_methods'][self.system]
        available_methods = []
        
        prereqs = self.check_prerequisites()
        
        for method in methods.keys():
            if method == 'homebrew' and prereqs.get('homebrew'):
                available_methods.append(method)
            elif method == 'apt' and prereqs.get('apt'):
                available_methods.append(method)
            elif method == 'go' and prereqs.get('go'):
                available_methods.append(method)
            elif method == 'binary':
                available_methods.append(method)
        
        return available_methods
    
    async def install_tool(self, tool_name: str, method: str = None) -> Tuple[bool, str]:
        """Instala una herramienta espec√≠fica"""
        if not self.is_tool_installable(tool_name):
            return False, f"La herramienta {tool_name} no es instalable en {self.system}"
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config['install_methods'][self.system]
        
        # Si no se especifica m√©todo, usar el primero disponible
        if not method:
            available_methods = self.get_install_methods(tool_name)
            if not available_methods:
                return False, f"No hay m√©todos de instalaci√≥n disponibles para {tool_name}"
            method = available_methods[0]
        
        if method not in install_methods:
            return False, f"M√©todo de instalaci√≥n '{method}' no disponible para {tool_name}"
        
        self.console.print(Panel(
            f"[bold cyan]üì¶ Instalando {tool_name}...[/bold cyan]\n"
            f"[dim]{tool_config['description']}[/dim]\n"
            f"[yellow]M√©todo: {method}[/yellow]",
            border_style="cyan"
        ))
        
        try:
            success = False
            
            if method == 'homebrew':
                success = await self._install_via_homebrew(tool_name, install_methods[method])
            elif method == 'apt':
                success = await self._install_via_apt(tool_name, install_methods[method])
            elif method == 'go':
                success = await self._install_via_go(tool_name, install_methods[method])
            elif method == 'binary':
                success = await self._install_via_binary(tool_name, install_methods[method])
            
            if success:
                # Ejecutar configuraci√≥n post-instalaci√≥n si existe
                if 'post_install' in tool_config:
                    await tool_config['post_install'](tool_name)
                
                self.console.print(f"[bold green]‚úì {tool_name} instalado correctamente[/bold green]")
                return True, f"{tool_name} instalado correctamente"
            else:
                return False, f"Error instalando {tool_name}"
                
        except Exception as e:
            error_msg = f"Error instalando {tool_name}: {str(e)}"
            self.console.print(f"[red]‚úó {error_msg}[/red]")
            return False, error_msg
    
    async def _install_via_homebrew(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a Homebrew"""
        for package in packages:
            cmd = ['brew', 'install', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_apt(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a APT"""
        for package in packages:
            cmd = ['sudo', 'apt', 'install', '-y', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_go(self, tool_name: str, package: str) -> bool:
        """Instala herramienta v√≠a Go"""
        cmd = ['go', 'install', '-v', package]
        return await self._run_command(cmd)
    
    async def _install_via_binary(self, tool_name: str, url: str) -> bool:
        """Instala herramienta descargando binario"""
        # Implementar descarga y instalaci√≥n de binarios
        self.console.print("[yellow]‚ö° Descargando binario...[/yellow]")
        # TODO: Implementar descarga de binarios
        return True
    
    async def _run_command(self, cmd: List[str]) -> bool:
        """Ejecuta un comando del sistema"""
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                task = progress.add_task(f"Ejecutando: {' '.join(cmd)}", total=None)
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    return True
                else:
                    self.console.print(f"[red]Error: {stderr.decode()}[/red]")
                    return False
                    
        except Exception as e:
            self.console.print(f"[red]Error ejecutando comando: {str(e)}[/red]")
            return False
    
    async def _setup_nuclei_templates(self, tool_name: str):
        """Configuraci√≥n post-instalaci√≥n para Nuclei"""
        self.console.print("[yellow]‚ö° Descargando templates de Nuclei...[/yellow]")
        
        templates_dir = Path.home() / 'nuclei-templates'
        if templates_dir.exists():
            self.console.print("[green]‚úì Templates ya existen[/green]")
            return
        
        # Clonar repositorio de templates
        cmd = ['git', 'clone', 'https://github.com/projectdiscovery/nuclei-templates.git', str(templates_dir)]
        success = await self._run_command(cmd)
        
        if success:
            self.console.print("[green]‚úì Templates de Nuclei descargados[/green]")
        else:
            self.console.print("[red]‚úó Error descargando templates de Nuclei[/red]")
    
    def show_installation_summary(self, results: Dict[str, Tuple[bool, str]]):
        """Muestra resumen de instalaciones"""
        self.console.print(Panel(
            "[bold cyan]üìä RESUMEN DE INSTALACI√ìN[/bold cyan]",
            border_style="cyan"
        ))
        
        successful = []
        failed = []
        
        for tool, (success, message) in results.items():
            if success:
                successful.append(tool)
                self.console.print(f"[green]‚úì {tool}[/green]: {message}")
            else:
                failed.append(tool)
                self.console.print(f"[red]‚úó {tool}[/red]: {message}")
        
        self.console.print()
        self.console.print(f"[bold green]Exitosas: {len(successful)}[/bold green]")
        self.console.print(f"[bold red]Fallidas: {len(failed)}[/bold red]")
        
        if failed:
            self.console.print()
            self.console.print("[yellow]‚ö†Ô∏è  Herramientas que fallaron pueden instalarse manualmente:[/yellow]")
            for tool in failed:
                config = self.tools_config.get(tool, {})
                self.console.print(f"  ‚Ä¢ {tool}: {config.get('description', '')}")


# Importar asyncio al final para evitar problemas de importaci√≥n circular
import asyncio 