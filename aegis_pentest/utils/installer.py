"""
Sistema de instalaci√≥n autom√°tica de herramientas para Aegis Pentest
"""

import platform
import subprocess
import shutil
from pathlib import Path
from typing import Dict, List, Tuple
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
import asyncio
import os
import sys

# Import Config to resolve "Config no est√° definido" error
from .config import Config

class ToolInstaller:
    """Instalador autom√°tico de herramientas de pentesting"""
    
    def __init__(self, console: Console = None):
        self.console = console or Console()
        self.system = platform.system().lower()
        self.arch = platform.machine().lower()
        
        # Configuraci√≥n de instaladores por sistema operativo
        self.installers = {
            'darwin': {  # macOS
                'package_manager': 'brew',
                'install_cmd': ['brew', 'install'],
                'update_cmd': ['brew', 'update'],
                'check_cmd': ['brew', '--version']
            },
            'linux': {
                'package_manager': 'apt',  # Por defecto, detectar espec√≠fico despu√©s
                'install_cmd': ['sudo', 'apt', 'install', '-y'],
                'update_cmd': ['sudo', 'apt', 'update'],
                'check_cmd': ['apt', '--version']
            }
        }
        
        # Configuraci√≥n espec√≠fica de herramientas
        self.tools_config = {
            'nmap': {
                'description': 'Scanner de puertos y detecci√≥n de servicios',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nmap']
                    },
                    'linux': {
                        'apt': ['nmap']
                    }
                }
            },
            'nuclei': {
                'description': 'Scanner de vulnerabilidades basado en templates',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nuclei'],
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                        'binary': 'https://github.com/projectdiscovery/nuclei/releases/latest/download/nuclei_3.2.0_linux_amd64.zip'
                    }
                },
                'post_install': self._setup_nuclei_templates
            },
            'gobuster': {
                'description': 'Herramienta de fuerza bruta para directorios/archivos',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['gobuster']
                    },
                    'linux': {
                        'apt': ['gobuster'],
                        'go': 'github.com/OJ/gobuster/v3@latest'
                    }
                }
            },
            'nikto': {
                'description': 'Scanner de vulnerabilidades web',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['nikto']
                    },
                    'linux': {
                        'apt': ['nikto']
                    }
                }
            },
            'sqlmap': {
                'description': 'Herramienta de detecci√≥n de inyecci√≥n SQL',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['sqlmap']
                    },
                    'linux': {
                        'apt': ['sqlmap']
                    }
                }
            },
            'hydra': {
                'description': 'Herramienta de ataques de fuerza bruta',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['hydra']
                    },
                    'linux': {
                        'apt': ['hydra']
                    }
                }
            },
            'subfinder': {
                'description': 'Enumeraci√≥n r√°pida de subdominios',
                'install_methods': {
                    'darwin': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    },
                    'linux': {
                        'go': 'github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest'
                    }
                },
                'post_install': self._auto_detect_go_tools
            },
            'ffuf': {
                'description': 'Fuzzer web r√°pido y flexible',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['ffuf'],
                        'go': 'github.com/ffuf/ffuf@latest'
                    },
                    'linux': {
                        'apt': ['ffuf'],
                        'go': 'github.com/ffuf/ffuf@latest'
                    }
                }
            },
            'zap-baseline.py': {
                'description': 'Proxy de seguridad OWASP ZAP',
                'install_methods': {
                    'darwin': {
                        'homebrew_cask': ['zap']
                    },
                    'linux': {
                        'apt': ['zaproxy']
                    }
                },
                'post_install': self._auto_setup_zap
            },
            'shodan': {
                'description': 'CLI para inteligencia de infraestructura Shodan',
                'install_methods': {
                    'darwin': {
                        'pip': ['shodan']
                    },
                    'linux': {
                        'pip': ['shodan']
                    }
                }
            },
            'traceroute': {
                'description': 'Herramienta de an√°lisis de rutas de red',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['traceroute']
                    },
                    'linux': {
                        'apt': ['traceroute']
                    }
                }
            },
            'w3af_console': {
                'description': 'Framework de auditor√≠a de aplicaciones web',
                'install_methods': {
                    'darwin': {
                        'manual': 'https://github.com/andresriancho/w3af'
                    },
                    'linux': {
                        'apt': ['w3af'],
                        'manual': 'https://github.com/andresriancho/w3af'
                    }
                },
                'post_install': self._setup_w3af_dependencies
            },
            'censys': {
                'description': 'CLI para motor de b√∫squeda Censys',
                'install_methods': {
                    'darwin': {
                        'pip': ['censys']
                    },
                    'linux': {
                        'pip': ['censys']
                    }
                }
            },
            'openssl': {
                'description': 'Herramienta para an√°lisis SSL/TLS y criptograf√≠a',
                'install_methods': {
                    'darwin': {
                        'homebrew': ['openssl']
                    },
                    'linux': {
                        'apt': ['openssl']
                    }
                }
            },
            'nginxpwner': {
                'description': 'Herramienta de an√°lisis de configuraciones Nginx',
                'install_methods': {
                    'darwin': {
                        'manual': 'https://github.com/stark0de/nginxpwner'
                    },
                    'linux': {
                        'manual': 'https://github.com/stark0de/nginxpwner'
                    }
                }
            },
            'apache_vuln': {
                'description': 'Testing de vulnerabilidades Apache personalizadas',
                'install_methods': {
                    'darwin': {
                        'manual': 'Script personalizado incluido en Aegis'
                    },
                    'linux': {
                        'manual': 'Script personalizado incluido en Aegis'
                    }
                }
            }
        }
    
    def check_prerequisites(self) -> Dict[str, bool]:
        """Verifica los prerequisitos del sistema"""
        prereqs = {}
        
        if self.system == 'darwin':
            # Verificar Homebrew
            prereqs['homebrew'] = shutil.which('brew') is not None
            prereqs['homebrew_cask'] = shutil.which('brew') is not None  # Cask requiere brew
            
        elif self.system == 'linux':
            # Verificar gestores de paquetes
            prereqs['apt'] = shutil.which('apt') is not None
            prereqs['yum'] = shutil.which('yum') is not None
            prereqs['pacman'] = shutil.which('pacman') is not None
        
        # Verificar Go (com√∫n para muchas herramientas)
        prereqs['go'] = shutil.which('go') is not None
        
        # Verificar Git
        prereqs['git'] = shutil.which('git') is not None
        
        # Verificar Python/pip - mejorar detecci√≥n de entornos virtuales
        pip_available = False
        pip3_available = False
        
        # Verificar pip y pip3
        if shutil.which('pip'):
            pip_available = True
        if shutil.which('pip3'):
            pip3_available = True
            
        # En entornos virtuales, usar pip directamente sin --user
        in_venv = (hasattr(sys, 'real_prefix') or 
                  (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix) or
                  os.environ.get('VIRTUAL_ENV'))
        
        prereqs['pip'] = pip_available or pip3_available
        prereqs['in_venv'] = in_venv
        
        # Verificar Node.js/npm
        prereqs['npm'] = shutil.which('npm') is not None
        
        return prereqs
    
    def install_prerequisites(self) -> bool:
        """Instala prerequisitos b√°sicos"""
        self.console.print(Panel(
            "[bold cyan]üì¶ Instalando prerequisitos...[/bold cyan]",
            border_style="cyan"
        ))
        
        if self.system == 'darwin':
            return self._install_homebrew()
        elif self.system == 'linux':
            return self._install_linux_prerequisites()
        
        return False
    
    def _install_homebrew(self) -> bool:
        """Instala Homebrew en macOS"""
        if shutil.which('brew'):
            self.console.print("[green]‚úì Homebrew ya est√° instalado[/green]")
            return True
        
        self.console.print("[yellow]‚ö° Instalando Homebrew...[/yellow]")
        
        try:
            install_script = '/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
            result = subprocess.run(install_script, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.console.print("[green]‚úì Homebrew instalado correctamente[/green]")
                return True
            else:
                self.console.print(f"[red]‚úó Error instalando Homebrew: {result.stderr}[/red]")
                return False
                
        except Exception as e:
            self.console.print(f"[red]‚úó Error instalando Homebrew: {str(e)}[/red]")
            return False
    
    def _install_linux_prerequisites(self) -> bool:
        """Instala prerequisitos en Linux"""
        # Actualizar repositorios
        if shutil.which('apt'):
            try:
                self.console.print("[yellow]‚ö° Actualizando repositorios...[/yellow]")
                subprocess.run(['sudo', 'apt', 'update'], check=True, capture_output=True)
                self.console.print("[green]‚úì Repositorios actualizados[/green]")
                return True
            except subprocess.CalledProcessError as e:
                self.console.print(f"[red]‚úó Error actualizando repositorios: {e}[/red]")
                return False
        
        return True
    
    def get_available_tools(self) -> List[str]:
        """Obtiene lista de herramientas disponibles para instalar"""
        return list(self.tools_config.keys())
    
    def is_tool_installable(self, tool_name: str) -> bool:
        """Verifica si una herramienta se puede instalar en el sistema actual"""
        if tool_name not in self.tools_config:
            return False
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config.get('install_methods', {})
        
        return self.system in install_methods
    
    def get_install_methods(self, tool_name: str) -> List[str]:
        """Obtiene m√©todos de instalaci√≥n disponibles para una herramienta"""
        if not self.is_tool_installable(tool_name):
            return []
        
        methods = self.tools_config[tool_name]['install_methods'][self.system]
        available_methods = []
        
        prereqs = self.check_prerequisites()
        
        for method in methods.keys():
            if method == 'homebrew' and prereqs.get('homebrew'):
                available_methods.append(method)
            elif method == 'homebrew_cask' and prereqs.get('homebrew_cask'):
                available_methods.append(method)
            elif method == 'apt' and prereqs.get('apt'):
                available_methods.append(method)
            elif method == 'go' and prereqs.get('go'):
                available_methods.append(method)
            elif method == 'pip' and prereqs.get('pip'):
                available_methods.append(method)
            elif method == 'npm' and prereqs.get('npm'):
                available_methods.append(method)
            elif method == 'binary':
                available_methods.append(method)
            elif method == 'manual':
                available_methods.append(method)
        
        return available_methods
    
    async def install_tool(self, tool_name: str, method: str = None) -> Tuple[bool, str]:
        """Instala una herramienta espec√≠fica"""
        if not self.is_tool_installable(tool_name):
            return False, f"La herramienta {tool_name} no es instalable en {self.system}"
        
        tool_config = self.tools_config[tool_name]
        install_methods = tool_config['install_methods'][self.system]
        
        # Si no se especifica m√©todo, usar el primero disponible
        if not method:
            available_methods = self.get_install_methods(tool_name)
            if not available_methods:
                return False, f"No hay m√©todos de instalaci√≥n disponibles para {tool_name}"
            method = available_methods[0]
        
        if method not in install_methods:
            return False, f"M√©todo de instalaci√≥n '{method}' no disponible para {tool_name}"
        
        self.console.print(Panel(
            f"[bold cyan]üì¶ Instalando {tool_name}...[/bold cyan]\n"
            f"[dim]{tool_config['description']}[/dim]\n"
            f"[yellow]M√©todo: {method}[/yellow]",
            border_style="cyan"
        ))
        
        try:
            success = False
            
            if method == 'homebrew':
                success = await self._install_via_homebrew(tool_name, install_methods[method])
            elif method == 'homebrew_cask':
                success = await self._install_via_homebrew_cask(tool_name, install_methods[method])
            elif method == 'apt':
                success = await self._install_via_apt(tool_name, install_methods[method])
            elif method == 'go':
                success = await self._install_via_go(tool_name, install_methods[method])
            elif method == 'pip':
                success = await self._install_via_pip(tool_name, install_methods[method])
            elif method == 'npm':
                success = await self._install_via_npm(tool_name, install_methods[method])
            elif method == 'binary':
                success = await self._install_via_binary(tool_name, install_methods[method])
            elif method == 'manual':
                success = await self._install_via_manual(tool_name, install_methods[method])
            
            if success:
                # Ejecutar configuraci√≥n post-instalaci√≥n si existe
                if 'post_install' in tool_config:
                    await tool_config['post_install'](tool_name)
                
                # Verificar que realmente est√© disponible despu√©s de la instalaci√≥n
                self.console.print("[yellow]üîç Verificando instalaci√≥n...[/yellow]")
                await asyncio.sleep(1)  # Esperar un momento para que el sistema detecte la nueva instalaci√≥n
                
                # Importar config y forzar re-detecci√≥n
                config = Config()
                
                # Forzar detecci√≥n de la herramienta reci√©n instalada
                is_available = config.force_tool_detection(tool_name)
                
                if is_available:
                    tool_path = config.get_tool_path(tool_name)
                    self.console.print(f"[bold green]‚úì {tool_name} instalado y verificado correctamente[/bold green]")
                    self.console.print(f"[dim]Ruta: {tool_path}[/dim]")
                    return True, f"{tool_name} instalado y verificado en {tool_path}"
                else:
                    # Intentar b√∫squeda manual adicional
                    manual_path = self._manual_tool_search(tool_name)
                    if manual_path:
                        config.set(f'tools.{tool_name}.path', manual_path)
                        config.save()
                        self.console.print(f"[bold green]‚úì {tool_name} encontrado manualmente y configurado[/bold green]")
                        self.console.print(f"[dim]Ruta: {manual_path}[/dim]")
                        return True, f"{tool_name} instalado y configurado en {manual_path}"
                    else:
                        self.console.print(f"[yellow]‚ö†Ô∏è {tool_name} parece instalado pero no se detecta autom√°ticamente[/yellow]")
                        self.console.print("[dim]Intenta ejecutar el comando manualmente para verificar[/dim]")
                        return False, f"{tool_name} instalado pero no detectado autom√°ticamente"
            else:
                return False, f"Error instalando {tool_name}"
                
        except Exception as e:
            error_msg = f"Error instalando {tool_name}: {str(e)}"
            self.console.print(f"[red]‚úó {error_msg}[/red]")
            return False, error_msg
    
    async def _install_via_homebrew(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a Homebrew"""
        for package in packages:
            cmd = ['brew', 'install', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_homebrew_cask(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a Homebrew Cask"""
        for package in packages:
            cmd = ['brew', 'install', '--cask', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_apt(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a APT"""
        for package in packages:
            cmd = ['sudo', 'apt', 'install', '-y', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_go(self, tool_name: str, package: str) -> bool:
        """Instala herramienta v√≠a Go"""
        cmd = ['go', 'install', '-v', package]
        return await self._run_command(cmd)
    
    async def _install_via_pip(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a pip"""
        pip_cmd = 'pip3' if shutil.which('pip3') else 'pip'
        
        # Verificar si estamos en un entorno virtual
        prereqs = self.check_prerequisites()
        in_venv = prereqs.get('in_venv', False)
        
        for package in packages:
            if in_venv:
                # En entornos virtuales no usar --user
                cmd = [pip_cmd, 'install', package]
            else:
                # En sistema global usar --user
                cmd = [pip_cmd, 'install', '--user', package]
            
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_npm(self, tool_name: str, packages: List[str]) -> bool:
        """Instala herramienta v√≠a npm"""
        for package in packages:
            cmd = ['npm', 'install', '-g', package]
            result = await self._run_command(cmd)
            if not result:
                return False
        return True
    
    async def _install_via_manual(self, tool_name: str, info: str) -> bool:
        """Maneja instalaci√≥n manual"""
        if tool_name == 'nginxpwner':
            return await self._install_nginxpwner()
        elif tool_name == 'apache_vuln':
            return await self._install_apache_vuln()
        elif tool_name == 'w3af_console':
            return await self._install_w3af()
        else:
            self.console.print(f"[yellow]‚ÑπÔ∏è  Instalaci√≥n manual requerida para {tool_name}[/yellow]")
            self.console.print(f"[dim]Informaci√≥n: {info}[/dim]")
            self.console.print("[dim]Consulta la documentaci√≥n oficial para instalaci√≥n manual[/dim]")
            return False
    
    async def _install_nginxpwner(self) -> bool:
        """Instala nginxpwner desde GitHub"""
        try:
            # Crear directorio external-tools si no existe
            external_dir = Path('./external-tools')
            external_dir.mkdir(exist_ok=True)
            
            # Clonar repositorio
            cmd = ['git', 'clone', 'https://github.com/stark0de/nginxpwner.git', './external-tools/nginxpwner']
            success = await self._run_command(cmd)
            if success:
                # Hacer ejecutable
                script_path = Path('./external-tools/nginxpwner/nginxpwner.py')
                if script_path.exists():
                    script_path.chmod(0o755)
                    self.console.print(f"[green]‚úì nginxpwner clonado en {script_path.parent.absolute()}[/green]")
                    return True
            return False
        except Exception as e:
            self.console.print(f"[red]Error instalando nginxpwner: {e}[/red]")
            return False
    
    async def _install_apache_vuln(self) -> bool:
        """Configura el script apache_vuln personalizado"""
        # Verificar que el script correcto existe en external-tools
        script_path = Path('./external-tools/apache-vuln/apache_vuln.py')
        
        if script_path.exists():
            # El script ya existe, verificar que sea ejecutable
            if not os.access(script_path, os.X_OK):
                script_path.chmod(0o755)
            self.console.print(f"[green]‚úì Apache vuln script ya disponible en {script_path.absolute()}[/green]")
            return True
        
        # Si no existe, crear el directorio y script b√°sico
        script_path.parent.mkdir(parents=True, exist_ok=True)
        
        script_content = '''#!/usr/bin/env python3
"""
Script b√°sico de testing de vulnerabilidades Apache
Integrado con Aegis Pentest Automation
"""
import sys
import argparse
import requests
import re

def main():
    parser = argparse.ArgumentParser(description='Apache Vulnerability Testing')
    parser.add_argument('target', help='Target URL or IP')
    parser.add_argument('--output', '-o', help='Output file')
    parser.add_argument('--timeout', '-t', type=int, default=10, help='Request timeout')
    
    args = parser.parse_args()
    
    target = args.target
    if not target.startswith(('http://', 'https://')):
        target = f"https://{target}"
    
    print(f"[+] Testing Apache vulnerabilities for: {target}")
    
    try:
        # Test b√°sico de servidor Apache
        response = requests.get(target, timeout=args.timeout, verify=False)
        server_header = response.headers.get('Server', '')
        
        if 'apache' in server_header.lower():
            print(f"[+] Apache server detected: {server_header}")
            
            # Verificar server-status
            for path in ['/server-status', '/server-status/', '/apache-status']:
                try:
                    url = target.rstrip('/') + path
                    resp = requests.get(url, timeout=args.timeout, verify=False)
                    if resp.status_code == 200 and 'apache server status' in resp.text.lower():
                        print(f"[!] Server-status accessible: {url}")
                except:
                    continue
        else:
            print("[-] Apache not detected in Server header")
    
    except Exception as e:
        print(f"[-] Error testing target: {e}")
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write(f"Apache vulnerability test results for {args.target}\\n")
            f.write(f"Target: {target}\\n")
            f.write("Test completed\\n")

if __name__ == "__main__":
    main()
'''
        
        with open(script_path, 'w') as f:
            f.write(script_content)
        script_path.chmod(0o755)
        
        self.console.print(f"[green]‚úì Apache vuln script creado en {script_path.absolute()}[/green]")
        return True
    
    async def _install_w3af(self) -> bool:
        """Instala w3af desde GitHub"""
        try:
            # Crear directorio external-tools si no existe
            external_dir = Path('./external-tools')
            external_dir.mkdir(exist_ok=True)
            
            # Verificar si ya existe el directorio
            w3af_dir = Path('./external-tools/w3af')
            if w3af_dir.exists():
                self.console.print(f"[yellow]‚ö†Ô∏è  Directorio w3af ya existe, actualizando...[/yellow]")
                # Actualizar repositorio existente
                cmd = ['git', '-C', './external-tools/w3af', 'pull']
                await self._run_command(cmd)
            else:
                # Clonar repositorio
                cmd = ['git', 'clone', 'https://github.com/andresriancho/w3af.git', './external-tools/w3af']
                success = await self._run_command(cmd)
                if not success:
                    return False
            
            # Verificar que el directorio se cre√≥ correctamente
            if not w3af_dir.exists():
                self.console.print(f"[red]‚úó No se pudo crear el directorio w3af[/red]")
                return False
            
            self.console.print("[yellow]‚ö° Configurando w3af...[/yellow]")
            
            # Buscar script de instalaci√≥n de dependencias
            possible_scripts = [
                w3af_dir / 'w3af_dependency_install.sh',
                w3af_dir / 'tmp' / 'w3af_dependency_install.sh',
                w3af_dir / 'extras' / 'w3af_dependency_install.sh'
            ]
            
            script_found = None
            for script in possible_scripts:
                if script.exists():
                    script_found = script
                    break
            
            if script_found:
                # Hacer ejecutable y ejecutar
                script_found.chmod(0o755)
                install_cmd = ['bash', str(script_found)]
                dep_success = await self._run_command(install_cmd)
            else:
                # Instalaci√≥n manual de dependencias b√°sicas de Python
                self.console.print("[yellow]‚ö° Instalando dependencias de Python para w3af...[/yellow]")
                
                # Verificar si estamos en un entorno virtual
                prereqs = self.check_prerequisites()
                in_venv = prereqs.get('in_venv', False)
                pip_cmd = 'pip3' if shutil.which('pip3') else 'pip'
                
                # Dependencias b√°sicas de w3af
                w3af_deps = [
                    'pyclamd', 'PyGithub', 'GitPython', 'pybloomfiltermmap3',
                    'phply', 'nltk', 'chardet', 'tblib', 'pdfminer', 'futures',
                    'pyOpenSSL', 'lxml', 'scapy', 'guess_language', 'cluster',
                    'msgpack-python', 'python-ntlm', 'halberd', 'darts.util.lru',
                    'Jinja2', 'vulndb', 'markdown'
                ]
                
                for dep in w3af_deps:
                    try:
                        if in_venv:
                            cmd = [pip_cmd, 'install', dep]
                        else:
                            cmd = [pip_cmd, 'install', '--user', dep]
                        await self._run_command(cmd)
                    except:
                        # Continuar con otras dependencias si una falla
                        continue
                
                dep_success = True
            
            if dep_success:
                # Verificar que w3af_console existe
                w3af_console = w3af_dir / 'w3af_console'
                if not w3af_console.exists():
                    # Buscar otros posibles ejecutables
                    possible_executables = [
                        w3af_dir / 'w3af_console.py',
                        w3af_dir / 'w3af_gui',
                        w3af_dir / 'w3af'
                    ]
                    
                    for exe in possible_executables:
                        if exe.exists():
                            exe.chmod(0o755)
                            break
                
                self.console.print(f"[green]‚úì w3af configurado en {w3af_dir.absolute()}[/green]")
                return True
            else:
                self.console.print(f"[yellow]‚ö†Ô∏è w3af clonado pero puede requerir configuraci√≥n manual de dependencias[/yellow]")
                return True  # Considerar √©xito parcial
                
        except Exception as e:
            self.console.print(f"[red]Error instalando w3af: {e}[/red]")
            return False
    
    async def _install_via_binary(self, tool_name: str, url: str) -> bool:
        """Instala herramienta descargando binario"""
        self.console.print("[yellow]‚ö° Descargando binario...[/yellow]")
        # TODO: Implementar descarga de binarios espec√≠ficos
        self.console.print(f"[yellow]‚ÑπÔ∏è  Descarga manual requerida desde: {url}[/yellow]")
        return False
    
    async def _run_command(self, cmd: List[str]) -> bool:
        """Ejecuta un comando del sistema"""
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=self.console
            ) as progress:
                task = progress.add_task(f"Ejecutando: {' '.join(cmd)}", total=None)
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    return True
                else:
                    self.console.print(f"[red]Error: {stderr.decode()}[/red]")
                    return False
                    
        except Exception as e:
            self.console.print(f"[red]Error ejecutando comando: {str(e)}[/red]")
            return False
    
    async def _setup_nuclei_templates(self, tool_name: str):
        """Configuraci√≥n post-instalaci√≥n para Nuclei"""
        self.console.print("[yellow]‚ö° Descargando templates de Nuclei...[/yellow]")
        
        templates_dir = Path.home() / 'nuclei-templates'
        if templates_dir.exists():
            self.console.print("[green]‚úì Templates ya existen[/green]")
            return
        
        # Clonar repositorio de templates
        cmd = ['git', 'clone', 'https://github.com/projectdiscovery/nuclei-templates.git', str(templates_dir)]
        success = await self._run_command(cmd)
        
        if success:
            self.console.print("[green]‚úì Templates de Nuclei descargados[/green]")
        else:
            self.console.print("[red]‚úó Error descargando templates de Nuclei[/red]")
    
    async def _setup_w3af_dependencies(self, tool_name: str):
        """Configuraci√≥n post-instalaci√≥n para w3af"""
        self.console.print("[yellow]‚ö° Configurando w3af...[/yellow]")
        
        w3af_dir = Path('./external-tools/w3af')
        if not w3af_dir.exists():
            self.console.print("[red]‚úó Directorio w3af no encontrado[/red]")
            return
        
        # Verificar ejecutables de w3af
        possible_executables = [
            w3af_dir / 'w3af_console',
            w3af_dir / 'w3af_console.py',
            w3af_dir / 'w3af'
        ]
        
        for exe in possible_executables:
            if exe.exists():
                exe.chmod(0o755)
                self.console.print(f"[green]‚úì Ejecutable w3af configurado: {exe}[/green]")
                break
        
        self.console.print("[green]‚úì w3af configurado correctamente[/green]")
    
    def show_installation_summary(self, results: Dict[str, Tuple[bool, str]]):
        """Muestra resumen de instalaciones"""
        self.console.print(Panel(
            "[bold cyan]üìä RESUMEN DE INSTALACI√ìN[/bold cyan]",
            border_style="cyan"
        ))
        
        successful = []
        failed = []
        
        for tool, (success, message) in results.items():
            if success:
                successful.append(tool)
                self.console.print(f"[green]‚úì {tool}[/green]: {message}")
            else:
                failed.append(tool)
                self.console.print(f"[red]‚úó {tool}[/red]: {message}")
        
        self.console.print()
        self.console.print(f"[bold green]Exitosas: {len(successful)}[/bold green]")
        self.console.print(f"[bold red]Fallidas: {len(failed)}[/bold red]")
        
        if failed:
            self.console.print()
            self.console.print("[yellow]‚ö†Ô∏è  Herramientas que fallaron pueden instalarse manualmente:[/yellow]")
            for tool in failed:
                config = self.tools_config.get(tool, {})
                self.console.print(f"  ‚Ä¢ {tool}: {config.get('description', '')}")
    
    def _manual_tool_search(self, tool_name: str) -> str:
        """B√∫squeda manual adicional de herramientas en ubicaciones espec√≠ficas"""
        import shutil
        
        # Primero probar shutil.which de nuevo (puede que PATH se haya actualizado)
        tool_path = shutil.which(tool_name)
        if tool_path:
            return tool_path
        
        # Rutas adicionales espec√≠ficas del sistema
        additional_paths = []
        
        if self.system == 'darwin':
            additional_paths = [
                f"/usr/local/bin/{tool_name}",
                f"/opt/homebrew/bin/{tool_name}",
                f"/usr/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                f"/usr/local/Cellar/*/bin/{tool_name}",  # Homebrew espec√≠fico
            ]
        elif self.system == 'linux':
            additional_paths = [
                f"/usr/bin/{tool_name}",
                f"/usr/local/bin/{tool_name}",
                f"/opt/{tool_name}/{tool_name}",
                f"/snap/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                str(Path.home() / ".local" / "bin" / tool_name),
            ]
        
        for path in additional_paths:
            if "*" in path:
                # Manejar rutas con wildcards
                import glob
                matches = glob.glob(path)
                for match in matches:
                    if Path(match).exists() and os.access(match, os.X_OK):
                        return match
            else:
                if Path(path).exists() and os.access(path, os.X_OK):
                    return path
        
        return ""

    async def _auto_setup_zap(self, tool_name: str):
        """Configuraci√≥n autom√°tica para ZAP"""
        self.console.print("[yellow]‚ö° Configurando ZAP autom√°ticamente...[/yellow]")
        
        # Forzar detecci√≥n autom√°tica
        config = Config()
        if config.is_tool_available('zap-baseline.py'):
            self.console.print("[green]‚úì ZAP configurado autom√°ticamente[/green]")
        else:
            self.console.print("[yellow]‚ö†Ô∏è ZAP instalado, wrapper ser√° creado autom√°ticamente cuando sea necesario[/yellow]")
        
        return True
    
    async def _auto_detect_go_tools(self, tool_name: str):
        """Detecci√≥n autom√°tica de herramientas Go despu√©s de la instalaci√≥n"""
        import os
        self.console.print(f"[yellow]‚ö° Detectando {tool_name} autom√°ticamente...[/yellow]")
        
        # Actualizar PATH para incluir Go bin
        go_bin_path = str(Path.home() / 'go' / 'bin')
        current_path = os.environ.get('PATH', '')
        
        if go_bin_path not in current_path:
            os.environ['PATH'] = f"{go_bin_path}:{current_path}"
        
        # Forzar detecci√≥n
        config = Config()
        if config.force_tool_detection(tool_name):
            self.console.print(f"[green]‚úì {tool_name} detectado autom√°ticamente[/green]")
            return True
        else:
            self.console.print(f"[yellow]‚ö†Ô∏è {tool_name} instalado pero requiere reinicio de shell[/yellow]")
            return True 