"""
Runner de procesos con integración de logging en tiempo real
Ejecuta herramientas de pentesting con monitoreo completo
"""
import asyncio
import subprocess
import threading
import time
import signal
import os
import shutil
from pathlib import Path
from typing import Optional, List, Dict, Tuple, Callable
from dataclasses import dataclass
from rich.console import Console

from .logger import get_logger, ToolLogger


@dataclass
class ProcessResult:
    """Resultado de ejecución de proceso"""
    success: bool
    exit_code: int
    duration: float
    stdout_lines: List[str]
    stderr_lines: List[str]
    error_message: str = ""
    timeout_occurred: bool = False


class ToolProcessRunner:
    """Ejecuta herramientas con logging y monitoreo en tiempo real"""
    
    def __init__(self, console: Optional[Console] = None):
        self.console = console or Console()
        self.logger = get_logger(self.console)
        self.running_processes: Dict[str, subprocess.Popen] = {}
        
    def check_tool_availability(self, tool_name: str, tool_path: Optional[str] = None) -> Tuple[bool, str]:
        """Verifica si una herramienta está disponible"""
        if tool_path and Path(tool_path).exists():
            return True, tool_path
        
        # Buscar en PATH
        found_path = shutil.which(tool_name)
        if found_path:
            return True, found_path
        
        # Buscar rutas comunes
        common_paths = [
            f"/usr/bin/{tool_name}",
            f"/usr/local/bin/{tool_name}",
            f"/opt/homebrew/bin/{tool_name}",
            f"/home/linuxbrew/.linuxbrew/bin/{tool_name}"
        ]
        
        for path in common_paths:
            if Path(path).exists():
                return True, path
        
        return False, ""
    
    async def run_tool_async(
        self,
        tool_name: str,
        command: List[str],
        target: str = "",
        timeout: int = 300,
        cwd: Optional[str] = None,
        env: Optional[Dict[str, str]] = None,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> ProcessResult:
        """Ejecuta una herramienta de forma asíncrona con logging completo"""
        
        # Verificar disponibilidad de la herramienta
        tool_available, tool_path = self.check_tool_availability(tool_name)
        if not tool_available:
            self.logger.handle_tool_not_found(tool_name)
            return ProcessResult(
                success=False,
                exit_code=-1,
                duration=0,
                stdout_lines=[],
                stderr_lines=[],
                error_message=f"Herramienta {tool_name} no encontrada"
            )
        
        # Actualizar comando con ruta encontrada si es necesario
        if tool_path and not command[0].startswith('/'):
            command[0] = tool_path
        
        command_str = ' '.join(command)
        tool_id = self.logger.start_tool(tool_name, command_str, target)
        
        start_time = time.time()
        stdout_lines = []
        stderr_lines = []
        process = None
        
        try:
            # Preparar entorno
            process_env = os.environ.copy()
            if env:
                process_env.update(env)
            
            # Iniciar proceso
            self.logger.update_tool_progress(tool_name, 5, "Iniciando proceso...")
            
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd,
                env=process_env
            )
            
            self.running_processes[tool_name] = process
            self.logger.update_tool_progress(tool_name, 10, "Proceso iniciado, leyendo salida...")
            
            # Leer output en tiempo real
            stdout_task = asyncio.create_task(
                self._read_stream_async(process.stdout, tool_name, False, progress_callback)
            )
            stderr_task = asyncio.create_task(
                self._read_stream_async(process.stderr, tool_name, True, progress_callback)
            )
            
            # Esperar a que termine con timeout
            try:
                await asyncio.wait_for(process.wait(), timeout=timeout)
                
                # Esperar a que terminen las tareas de lectura
                stdout_lines = await stdout_task
                stderr_lines = await stderr_task
                
                duration = time.time() - start_time
                success = process.returncode == 0
                
                self.logger.finish_tool(tool_name, success)
                
                return ProcessResult(
                    success=success,
                    exit_code=process.returncode,
                    duration=duration,
                    stdout_lines=stdout_lines,
                    stderr_lines=stderr_lines
                )
                
            except asyncio.TimeoutError:
                # Manejar timeout
                self.logger.handle_tool_timeout(tool_name, timeout)
                
                if process:
                    try:
                        process.terminate()
                        await asyncio.wait_for(process.wait(), timeout=5)
                    except asyncio.TimeoutError:
                        process.kill()
                        await process.wait()
                
                duration = time.time() - start_time
                return ProcessResult(
                    success=False,
                    exit_code=-1,
                    duration=duration,
                    stdout_lines=stdout_lines,
                    stderr_lines=stderr_lines,
                    error_message=f"Timeout después de {timeout} segundos",
                    timeout_occurred=True
                )
                
        except Exception as e:
            error_msg = f"Error ejecutando {tool_name}: {str(e)}"
            self.logger.finish_tool(tool_name, False, error_msg)
            
            duration = time.time() - start_time
            return ProcessResult(
                success=False,
                exit_code=-1,
                duration=duration,
                stdout_lines=stdout_lines,
                stderr_lines=stderr_lines,
                error_message=error_msg
            )
        
        finally:
            if tool_name in self.running_processes:
                del self.running_processes[tool_name]
    
    async def _read_stream_async(
        self,
        stream,
        tool_name: str,
        is_stderr: bool,
        progress_callback: Optional[Callable[[int, str], None]]
    ) -> List[str]:
        """Lee un stream de forma asíncrona y registra el output"""
        lines = []
        line_count = 0
        
        try:
            while True:
                line_bytes = await stream.readline()
                if not line_bytes:
                    break
                
                line = line_bytes.decode('utf-8', errors='ignore').strip()
                if line:
                    lines.append(line)
                    line_count += 1
                    
                    # Log la línea
                    self.logger.log_tool_output(tool_name, line, is_stderr)
                    
                    # Actualizar progreso basado en patrones conocidos
                    progress = self._estimate_progress(tool_name, line, line_count)
                    if progress > 0:
                        self.logger.update_tool_progress(tool_name, progress, line[:50])
                    
                    # Callback de progreso personalizado
                    if progress_callback:
                        progress_callback(progress, line)
        
        except Exception as e:
            error_line = f"Error leyendo stream: {str(e)}"
            lines.append(error_line)
            self.logger.log_tool_output(tool_name, error_line, True)
        
        return lines
    
    def _estimate_progress(self, tool_name: str, line: str, line_count: int) -> int:
        """Estima el progreso basado en patterns de salida conocidos"""
        progress = 0
        line_lower = line.lower()
        
        # Patterns generales
        if "starting" in line_lower or "iniciando" in line_lower:
            progress = 15
        elif "scanning" in line_lower or "escaneando" in line_lower:
            progress = min(30 + (line_count * 2), 70)
        elif "found" in line_lower or "encontrado" in line_lower:
            progress = min(50 + (line_count), 80)
        elif "complete" in line_lower or "finished" in line_lower or "done" in line_lower:
            progress = 95
        
        # Patterns específicos por herramienta
        if tool_name.lower() == "nmap":
            if "syn stealth scan" in line_lower:
                progress = 25
            elif "service detection" in line_lower:
                progress = 60
            elif "script scan" in line_lower:
                progress = 80
        
        elif tool_name.lower() == "nuclei":
            if "loading templates" in line_lower:
                progress = 20
            elif "running" in line_lower:
                progress = min(40 + (line_count * 3), 85)
        
        elif tool_name.lower() == "gobuster":
            if "starting gobuster" in line_lower:
                progress = 20
            elif "/" in line and ("200" in line or "403" in line):
                progress = min(30 + (line_count * 2), 85)
        
        elif tool_name.lower() == "sqlmap":
            if "testing connection" in line_lower:
                progress = 25
            elif "testing for" in line_lower:
                progress = min(40 + (line_count * 5), 80)
            elif "injection" in line_lower:
                progress = 85
        
        return progress
    
    def run_tool_sync(
        self,
        tool_name: str,
        command: List[str],
        target: str = "",
        timeout: int = 300,
        cwd: Optional[str] = None,
        env: Optional[Dict[str, str]] = None
    ) -> ProcessResult:
        """Ejecuta una herramienta de forma síncrona"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(
                self.run_tool_async(tool_name, command, target, timeout, cwd, env)
            )
        finally:
            loop.close()
    
    def stop_tool(self, tool_name: str) -> bool:
        """Detiene una herramienta en ejecución"""
        if tool_name in self.running_processes:
            process = self.running_processes[tool_name]
            try:
                process.terminate()
                self.logger.update_tool_progress(tool_name, 0, "Detenido por usuario")
                self.logger.finish_tool(tool_name, False, "Detenido por usuario")
                return True
            except Exception as e:
                self.logger.log_tool_output(tool_name, f"Error deteniendo proceso: {e}", True)
                return False
        return False
    
    def stop_all_tools(self):
        """Detiene todas las herramientas en ejecución"""
        for tool_name in list(self.running_processes.keys()):
            self.stop_tool(tool_name)
    
    def get_running_tools(self) -> List[str]:
        """Obtiene lista de herramientas en ejecución"""
        return list(self.running_processes.keys())


# Instancia global del runner
_global_runner: Optional[ToolProcessRunner] = None


def get_process_runner(console: Optional[Console] = None) -> ToolProcessRunner:
    """Obtiene la instancia global del process runner"""
    global _global_runner
    if _global_runner is None:
        _global_runner = ToolProcessRunner(console)
    return _global_runner 