"""
Runner de procesos con integración de logging en tiempo real
Ejecuta herramientas de pentesting con monitoreo completo
Con manejo automático de privilegios de administrador
"""
import asyncio
import subprocess
import threading
import time
import signal
import os
import shutil
from pathlib import Path
from typing import Optional, List, Dict, Tuple, Callable
from dataclasses import dataclass
from rich.console import Console

from .logger import get_logger, ToolLogger
from .privilege_manager import get_privilege_manager, PrivilegeManager


@dataclass
class ProcessResult:
    """Resultado de ejecución de proceso"""
    success: bool
    exit_code: int
    duration: float
    stdout_lines: List[str]
    stderr_lines: List[str]
    error_message: str = ""
    timeout_occurred: bool = False
    used_sudo: bool = False


class ToolProcessRunner:
    """Ejecuta herramientas con logging y monitoreo en tiempo real"""
    
    def __init__(self, console: Optional[Console] = None):
        self.console = console or Console()
        self.logger = get_logger(self.console)
        self.privilege_manager = get_privilege_manager(self.console)
        self.running_processes: Dict[str, subprocess.Popen] = {}
        
    def check_tool_availability(self, tool_name: str, tool_path: Optional[str] = None) -> Tuple[bool, str]:
        """Verifica si una herramienta está disponible"""
        if tool_path and Path(tool_path).exists():
            return True, tool_path
        
        # Buscar en PATH
        found_path = shutil.which(tool_name)
        if found_path:
            return True, found_path
        
        # Buscar rutas comunes
        common_paths = [
            f"/usr/bin/{tool_name}",
            f"/usr/local/bin/{tool_name}",
            f"/opt/homebrew/bin/{tool_name}",
            f"/home/linuxbrew/.linuxbrew/bin/{tool_name}"
        ]
        
        for path in common_paths:
            if Path(path).exists():
                return True, path
        
        return False, ""
    
    async def run_tool_async(
        self,
        tool_name: str,
        command: List[str],
        target: str = "",
        timeout: int = 300,
        cwd: Optional[str] = None,
        env: Optional[Dict[str, str]] = None,
        progress_callback: Optional[Callable[[int, str], None]] = None
    ) -> ProcessResult:
        """Ejecuta una herramienta de forma asíncrona con logging completo y manejo de privilegios"""
        
        # Verificar disponibilidad de la herramienta
        tool_available, tool_path = self.check_tool_availability(tool_name)
        if not tool_available:
            self.logger.handle_tool_not_found(tool_name)
            return ProcessResult(
                success=False,
                exit_code=-1,
                duration=0,
                stdout_lines=[],
                stderr_lines=[],
                error_message=f"Herramienta {tool_name} no encontrada",
                used_sudo=False
            )
        
        # Actualizar comando con ruta encontrada si es necesario
        if tool_path and not command[0].startswith('/'):
            command[0] = tool_path
        
        # Verificar si necesita privilegios sudo
        needs_sudo = self.privilege_manager.needs_sudo(tool_name, command)
        used_sudo = False
        
        if needs_sudo:
            if not self.privilege_manager._sudo_validated and not self.privilege_manager.is_admin():
                error_msg = f"La herramienta {tool_name} requiere privilegios de administrador pero no están disponibles"
                self.logger.log_tool_output(tool_name, error_msg, True)
                return ProcessResult(
                    success=False,
                    exit_code=-1,
                    duration=0,
                    stdout_lines=[],
                    stderr_lines=[],
                    error_message=error_msg,
                    used_sudo=False
                )
            
            # Preparar comando con sudo
            command = self.privilege_manager.prepare_command_with_sudo(command)
            used_sudo = True
            self.logger.log_tool_output(tool_name, f"Ejecutando con privilegios de administrador: {' '.join(command)}", False)
        
        command_str = ' '.join(command)
        tool_id = self.logger.start_tool(tool_name, command_str, target)
        
        start_time = time.time()
        stdout_lines = []
        stderr_lines = []
        process = None
        is_asyncio_process = False  # Rastrear tipo de proceso directamente
        
        try:
            # Preparar entorno
            process_env = os.environ.copy()
            if env:
                process_env.update(env)
            
            # Iniciar proceso
            self.logger.update_tool_progress(tool_name, 5, "Iniciando proceso...")
            
            # Crear proceso con manejo especial para sudo
            if used_sudo and not self.privilege_manager.is_admin():
                # Usar Popen para poder enviar la contraseña a stdin
                process = subprocess.Popen(
                    command,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    cwd=cwd,
                    env=process_env,
                    text=True
                )
                is_asyncio_process = False  # Este es subprocess.Popen
                
                # Enviar contraseña de sudo
                sudo_input = self.privilege_manager.get_sudo_input()
                if sudo_input:
                    process.stdin.write(sudo_input)
                    process.stdin.flush()
                
                # Convertir a proceso async para mantener compatibilidad
                # Crear tareas para leer stdout/stderr
                stdout_task = asyncio.create_task(
                    self._read_sync_stream_async(process.stdout, tool_name, False, progress_callback)
                )
                stderr_task = asyncio.create_task(
                    self._read_sync_stream_async(process.stderr, tool_name, True, progress_callback)
                )
            else:
                # Proceso normal (sin sudo o ya somos root)
                process = await asyncio.create_subprocess_exec(
                    *command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                    cwd=cwd,
                    env=process_env
                )
                is_asyncio_process = True  # Este es asyncio subprocess
                
                # Leer output en tiempo real
                stdout_task = asyncio.create_task(
                    self._read_stream_async(process.stdout, tool_name, False, progress_callback)
                )
                stderr_task = asyncio.create_task(
                    self._read_stream_async(process.stderr, tool_name, True, progress_callback)
                )
            
            self.running_processes[tool_name] = process
            self.logger.update_tool_progress(tool_name, 10, "Proceso iniciado, leyendo salida...")
            
            # Esperar a que termine con timeout
            try:
                if is_asyncio_process:
                    # Proceso asyncio
                    await asyncio.wait_for(process.wait(), timeout=timeout)
                else:
                    # Proceso subprocess.Popen
                    await asyncio.wait_for(
                        asyncio.get_event_loop().run_in_executor(None, process.wait),
                        timeout=timeout
                    )
                
                # Esperar a que terminen las tareas de lectura
                stdout_lines = await stdout_task
                stderr_lines = await stderr_task
                
                duration = time.time() - start_time
                success = process.returncode == 0
                
                # Manejar caso especial donde sudo falla por contraseña incorrecta
                if used_sudo and not success:
                    error_output = '\n'.join(stderr_lines).lower()
                    if 'incorrect password' in error_output or 'authentication failure' in error_output:
                        error_msg = "Error de autenticación sudo - contraseña incorrecta"
                        self.logger.log_tool_output(tool_name, error_msg, True)
                
                self.logger.finish_tool(tool_name, success)
                
                return ProcessResult(
                    success=success,
                    exit_code=process.returncode,
                    duration=duration,
                    stdout_lines=stdout_lines,
                    stderr_lines=stderr_lines,
                    used_sudo=used_sudo
                )
                
            except asyncio.TimeoutError:
                # Manejar timeout
                self.logger.handle_tool_timeout(tool_name, timeout)
                
                if process:
                    try:
                        if hasattr(process, 'terminate'):
                            process.terminate()
                            if is_asyncio_process:
                                # Proceso asyncio
                                await asyncio.wait_for(process.wait(), timeout=5)
                            else:
                                # Proceso subprocess.Popen
                                await asyncio.wait_for(
                                    asyncio.get_event_loop().run_in_executor(None, process.wait),
                                    timeout=5
                                )
                        else:
                            process.terminate()
                            await asyncio.wait_for(
                                asyncio.get_event_loop().run_in_executor(None, process.wait),
                                timeout=5
                            )
                    except asyncio.TimeoutError:
                        if hasattr(process, 'kill'):
                            process.kill()
                        else:
                            process.kill()
                        if is_asyncio_process:
                            # Proceso asyncio
                            await process.wait()
                        else:
                            # Proceso subprocess.Popen - no hacer await directo
                            await asyncio.get_event_loop().run_in_executor(None, process.wait)
                
                duration = time.time() - start_time
                return ProcessResult(
                    success=False,
                    exit_code=-1,
                    duration=duration,
                    stdout_lines=stdout_lines,
                    stderr_lines=stderr_lines,
                    error_message=f"Timeout después de {timeout} segundos",
                    timeout_occurred=True,
                    used_sudo=used_sudo
                )
                
        except Exception as e:
            error_msg = f"Error ejecutando {tool_name}: {str(e)}"
            self.logger.finish_tool(tool_name, False, error_msg)
            
            duration = time.time() - start_time
            return ProcessResult(
                success=False,
                exit_code=-1,
                duration=duration,
                stdout_lines=stdout_lines,
                stderr_lines=stderr_lines,
                error_message=error_msg,
                used_sudo=used_sudo
            )
        
        finally:
            if tool_name in self.running_processes:
                del self.running_processes[tool_name]
    
    async def _read_sync_stream_async(
        self,
        stream,
        tool_name: str,
        is_stderr: bool,
        progress_callback: Optional[Callable[[int, str], None]]
    ) -> List[str]:
        """Lee un stream síncrono de forma asíncrona (para procesos con sudo)"""
        lines = []
        line_count = 0
        
        try:
            loop = asyncio.get_event_loop()
            
            while True:
                # Leer línea de forma no bloqueante
                line = await loop.run_in_executor(None, stream.readline)
                
                if not line:
                    break
                
                line = line.strip()
                if line:
                    lines.append(line)
                    line_count += 1
                    
                    # Log la línea
                    self.logger.log_tool_output(tool_name, line, is_stderr)
                    
                    # Actualizar progreso basado en patrones conocidos
                    progress = self._estimate_progress(tool_name, line, line_count)
                    if progress > 0:
                        self.logger.update_tool_progress(tool_name, progress, line[:50])
                    
                    # Callback de progreso personalizado
                    if progress_callback:
                        progress_callback(progress, line)
        
        except Exception as e:
            error_line = f"Error leyendo stream: {str(e)}"
            lines.append(error_line)
            self.logger.log_tool_output(tool_name, error_line, True)
        
        return lines
    
    async def _read_stream_async(
        self,
        stream,
        tool_name: str,
        is_stderr: bool,
        progress_callback: Optional[Callable[[int, str], None]]
    ) -> List[str]:
        """Lee un stream de forma asíncrona y registra el output"""
        lines = []
        line_count = 0
        
        try:
            while True:
                line_bytes = await stream.readline()
                if not line_bytes:
                    break
                
                line = line_bytes.decode('utf-8', errors='ignore').strip()
                if line:
                    lines.append(line)
                    line_count += 1
                    
                    # Log la línea
                    self.logger.log_tool_output(tool_name, line, is_stderr)
                    
                    # Actualizar progreso basado en patrones conocidos
                    progress = self._estimate_progress(tool_name, line, line_count)
                    if progress > 0:
                        self.logger.update_tool_progress(tool_name, progress, line[:50])
                    
                    # Callback de progreso personalizado
                    if progress_callback:
                        progress_callback(progress, line)
        
        except Exception as e:
            error_line = f"Error leyendo stream: {str(e)}"
            lines.append(error_line)
            self.logger.log_tool_output(tool_name, error_line, True)
        
        return lines
    
    def _estimate_progress(self, tool_name: str, line: str, line_count: int) -> int:
        """Estima el progreso basado en patterns de salida conocidos"""
        progress = 0
        line_lower = line.lower()
        
        # Patterns generales
        if "starting" in line_lower or "iniciando" in line_lower:
            progress = 15
        elif "scanning" in line_lower or "escaneando" in line_lower:
            progress = min(30 + (line_count * 2), 70)
        elif "found" in line_lower or "encontrado" in line_lower:
            progress = min(50 + (line_count), 80)
        elif "complete" in line_lower or "finished" in line_lower or "done" in line_lower:
            progress = 95
        
        # Patterns específicos por herramienta
        if tool_name.lower() == "nmap":
            if "syn stealth scan" in line_lower:
                progress = 25
            elif "service detection" in line_lower:
                progress = 60
            elif "script scan" in line_lower:
                progress = 80
        
        elif tool_name.lower() == "nuclei":
            if "loading templates" in line_lower:
                progress = 20
            elif "running" in line_lower:
                progress = min(40 + (line_count * 3), 85)
        
        elif tool_name.lower() == "gobuster":
            if "starting gobuster" in line_lower:
                progress = 20
            elif "/" in line and ("200" in line or "403" in line):
                progress = min(30 + (line_count * 2), 85)
        
        elif tool_name.lower() == "sqlmap":
            if "testing connection" in line_lower:
                progress = 25
            elif "testing for" in line_lower:
                progress = min(40 + (line_count * 5), 80)
            elif "injection" in line_lower:
                progress = 85
        
        return progress
    
    def run_tool_sync(
        self,
        tool_name: str,
        command: List[str],
        target: str = "",
        timeout: int = 300,
        cwd: Optional[str] = None,
        env: Optional[Dict[str, str]] = None
    ) -> ProcessResult:
        """Ejecuta una herramienta de forma síncrona"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(
                self.run_tool_async(tool_name, command, target, timeout, cwd, env)
            )
        finally:
            loop.close()
    
    def stop_tool(self, tool_name: str) -> bool:
        """Detiene una herramienta en ejecución"""
        if tool_name in self.running_processes:
            process = self.running_processes[tool_name]
            try:
                if hasattr(process, 'terminate'):
                    process.terminate()
                else:
                    process.terminate()
                self.logger.update_tool_progress(tool_name, 0, "Detenido por usuario")
                self.logger.finish_tool(tool_name, False, "Detenido por usuario")
                return True
            except Exception as e:
                self.logger.log_tool_output(tool_name, f"Error deteniendo proceso: {e}", True)
                return False
        return False
    
    def stop_all_tools(self):
        """Detiene todas las herramientas en ejecución"""
        for tool_name in list(self.running_processes.keys()):
            self.stop_tool(tool_name)
    
    def get_running_tools(self) -> List[str]:
        """Obtiene lista de herramientas en ejecución"""
        return list(self.running_processes.keys())


# Instancia global del runner
_global_runner: Optional[ToolProcessRunner] = None


def get_process_runner(console: Optional[Console] = None) -> ToolProcessRunner:
    """Obtiene la instancia global del process runner"""
    global _global_runner
    if _global_runner is None:
        _global_runner = ToolProcessRunner(console)
    return _global_runner 