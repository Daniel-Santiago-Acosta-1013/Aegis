"""
Sistema de configuración para Aegis Pentest Automation
"""

import os
import yaml
import shutil
from pathlib import Path
from typing import Dict, Any, List
import platform


class Config:
    """Gestor de configuración de la aplicación"""
    
    _instance = None
    _config = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if self._config is None:
            self.load()
    
    @classmethod
    def load(cls, config_path: str = None):
        """Carga la configuración desde archivo"""
        if config_path:
            config_file = Path(config_path)
        else:
            config_file = cls._get_default_config_path()
        
        if not config_file.exists():
            cls._create_default_config(config_file)
        
        with open(config_file, 'r', encoding='utf-8') as f:
            cls._config = yaml.safe_load(f)
        
        # Validar configuración
        cls._validate_config()
        
        return cls._config
    
    @staticmethod
    def _get_default_config_path() -> Path:
        """Obtiene la ruta del archivo de configuración por defecto"""
        home = Path.home()
        config_dir = home / ".aegis"
        config_dir.mkdir(exist_ok=True)
        return config_dir / "config.yaml"
    
    @classmethod
    def _create_default_config(cls, config_path: Path):
        """Crea el archivo de configuración por defecto"""
        default_config = {
            'tools': {
                'nmap': {
                    'path': shutil.which('nmap') or '/usr/bin/nmap',
                    'timeout': 300,
                    'default_args': ['-sV', '-sC', '--version-light']
                },
                'nuclei': {
                    'path': shutil.which('nuclei') or '/usr/local/bin/nuclei',
                    'timeout': 600,
                    'templates_path': str(Path.home() / 'nuclei-templates'),
                    'default_args': ['-es', 'info,low,medium,high,critical']
                },
                'gobuster': {
                    'path': shutil.which('gobuster') or '/usr/bin/gobuster',
                    'timeout': 300,
                    'wordlist': '/usr/share/wordlists/dirb/common.txt',
                    'default_args': ['-t', '50', '-x', 'php,html,txt,js']
                },
                'nikto': {
                    'path': shutil.which('nikto') or '/usr/bin/nikto',
                    'timeout': 1800,
                    'default_args': ['-h']
                },
                'sqlmap': {
                    'path': shutil.which('sqlmap') or '/usr/bin/sqlmap',
                    'timeout': 900,
                    'default_args': ['--batch', '--smart']
                },
                'hydra': {
                    'path': shutil.which('hydra') or '/usr/bin/hydra',
                    'timeout': 300,
                    'default_args': ['-t', '4']
                },
                'subfinder': {
                    'path': shutil.which('subfinder') or '/usr/local/bin/subfinder',
                    'timeout': 300,
                    'default_args': ['-silent']
                }
            },
            'output': {
                'default_format': 'html',
                'save_path': str(Path.home() / 'aegis-reports'),
                'templates_path': 'resources/templates',
                'auto_save': True,
                'timestamp_format': '%Y%m%d_%H%M%S'
            },
            'threading': {
                'max_workers': 4,
                'timeout_multiplier': 1.5,
                'retry_attempts': 3
            },
            'logging': {
                'level': 'INFO',
                'file': str(Path.home() / '.aegis' / 'aegis.log'),
                'max_size': '10MB',
                'backup_count': 5
            },
            'ui': {
                'theme': 'dark',
                'window_size': [1200, 800],
                'auto_refresh': True,
                'refresh_interval': 5
            },
            'security': {
                'confirm_destructive': True,
                'max_target_size': 256,
                'allowed_target_types': ['domain', 'ip', 'url'],
                'blacklist_private': False
            }
        }
        
        # Crear directorio de reportes
        reports_dir = Path(default_config['output']['save_path'])
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        # Escribir configuración
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)
    
    @classmethod
    def _validate_config(cls):
        """Valida la configuración cargada"""
        if not cls._config:
            raise ValueError("Configuración no cargada")
        
        required_sections = ['tools', 'output', 'threading']
        for section in required_sections:
            if section not in cls._config:
                raise ValueError(f"Sección requerida '{section}' no encontrada en configuración")
    
    def get(self, key: str, default=None):
        """Obtiene un valor de configuración usando notación de punto"""
        keys = key.split('.')
        value = self._config
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any):
        """Establece un valor de configuración usando notación de punto"""
        keys = key.split('.')
        config = self._config
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def get_tool_config(self, tool_name: str) -> Dict[str, Any]:
        """Obtiene la configuración de una herramienta específica"""
        return self.get(f'tools.{tool_name}', {})
    
    def is_tool_available(self, tool_name: str) -> bool:
        """Verifica si una herramienta está disponible buscando dinámicamente"""
        # Primero buscar en PATH
        tool_path = shutil.which(tool_name)
        if tool_path and Path(tool_path).exists() and os.access(tool_path, os.X_OK):
            # Actualizar la configuración con la nueva ruta encontrada
            self.set(f'tools.{tool_name}.path', tool_path)
            return True
        
        # Buscar en rutas comunes basadas en el sistema operativo
        common_paths = []
        system = platform.system().lower()
        
        if system == 'darwin':  # macOS
            common_paths = [
                f"/usr/local/bin/{tool_name}",
                f"/opt/homebrew/bin/{tool_name}",
                f"/usr/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name)
            ]
        elif system == 'linux':
            common_paths = [
                f"/usr/bin/{tool_name}",
                f"/usr/local/bin/{tool_name}",
                f"/opt/{tool_name}/{tool_name}",
                f"/snap/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                str(Path.home() / ".local" / "bin" / tool_name)
            ]
        
        # Verificar cada ruta común
        for path in common_paths:
            if Path(path).exists() and os.access(path, os.X_OK):
                # Actualizar la configuración con la nueva ruta encontrada
                self.set(f'tools.{tool_name}.path', path)
                return True
        
        # Como último recurso, verificar la ruta configurada (puede ser obsoleta)
        tool_config = self.get_tool_config(tool_name)
        if tool_config:
            configured_path = tool_config.get('path')
            if configured_path and Path(configured_path).exists() and os.access(configured_path, os.X_OK):
                return True
        
        return False
    
    def get_available_tools(self) -> Dict[str, List[Dict[str, Any]]]:
        """Obtiene una lista de todas las herramientas organizadas por categoría"""
        tools = {
            'reconnaissance': [
                {'name': 'nmap', 'description': 'Escaneo de puertos y servicios'},
                {'name': 'subfinder', 'description': 'Enumeración de subdominios'},
                {'name': 'nuclei', 'description': 'Templates de vulnerabilidades'}
            ],
            'web_analysis': [
                {'name': 'gobuster', 'description': 'Fuzzing de directorios'},
                {'name': 'nikto', 'description': 'Escáner de vulnerabilidades web'},
                {'name': 'sqlmap', 'description': 'Detección de inyecciones SQL'}
            ],
            'brute_force': [
                {'name': 'hydra', 'description': 'Ataques de fuerza bruta'}
            ]
        }
        
        # Agregar estado de disponibilidad
        for category in tools:
            for tool in tools[category]:
                tool['available'] = self.is_tool_available(tool['name'])
        
        return tools
    
    def get_tool_path(self, tool_name: str) -> str:
        """Obtiene la ruta de una herramienta específica"""
        tool_config = self.get_tool_config(tool_name)
        return tool_config.get('path', '')
    
    def get_tool_version(self, tool_name: str) -> str:
        """Obtiene la versión de una herramienta específica"""
        tool_path = self.get_tool_path(tool_name)
        if not tool_path or not os.path.exists(tool_path):
            return "N/A"
        
        import subprocess
        try:
            # Intentar obtener versión con diferentes comandos comunes
            version_commands = [
                [tool_path, '--version'],
                [tool_path, '-version'],
                [tool_path, 'version'],
                [tool_path, '-V'],
                [tool_path, '-v']
            ]
            
            for cmd in version_commands:
                try:
                    result = subprocess.run(
                        cmd, 
                        capture_output=True, 
                        text=True, 
                        timeout=5
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        # Extraer primera línea que contenga números de versión
                        lines = result.stdout.strip().split('\n')
                        for line in lines:
                            if any(char.isdigit() for char in line):
                                return line.strip()[:50]  # Limitar a 50 caracteres
                        return result.stdout.strip().split('\n')[0][:50]
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
                    continue
            
            return "Disponible"
        except Exception:
            return "Error"
    
    def get_setting(self, setting_path: str, default=None) -> Any:
        """Obtiene un valor de configuración general"""
        return self.get(setting_path, default)
    
    def save(self, config_path: str = None):
        """Guarda la configuración actual"""
        if config_path:
            config_file = Path(config_path)
        else:
            config_file = self._get_default_config_path()
        
        with open(config_file, 'w', encoding='utf-8') as f:
            yaml.dump(self._config, f, default_flow_style=False, indent=2)
    
    def refresh_tools_detection(self):
        """Refresca la detección de herramientas para encontrar las recién instaladas"""
        tools_to_check = ['nmap', 'nuclei', 'gobuster', 'nikto', 'sqlmap', 'hydra', 'subfinder', 'openssl']
        
        for tool_name in tools_to_check:
            # Forzar re-detección buscando dinámicamente
            if tool_name in self._config.get('tools', {}):
                # Limpiar ruta anterior para forzar búsqueda
                old_path = self._config['tools'][tool_name].get('path')
                self._config['tools'][tool_name]['path'] = ''
                
                # Buscar nueva ruta
                if self.is_tool_available(tool_name):
                    new_path = self._config['tools'][tool_name].get('path')
                    if new_path != old_path:
                        self.save()  # Guardar configuración actualizada
    
    def force_tool_detection(self, tool_name: str) -> bool:
        """Fuerza la re-detección de una herramienta específica"""
        # Limpiar configuración existente
        if tool_name in self._config.get('tools', {}):
            self._config['tools'][tool_name]['path'] = ''
        
        # Buscar de nuevo
        return self.is_tool_available(tool_name)
    
    @property
    def reports_dir(self) -> Path:
        """Directorio de reportes"""
        return Path(self.get('output.save_path'))
    
    @property
    def max_workers(self) -> int:
        """Número máximo de workers"""
        return self.get('threading.max_workers', 4)
    
    @property
    def default_timeout(self) -> int:
        """Timeout por defecto para herramientas"""
        return self.get('threading.default_timeout', 300) 