"""
Sistema de configuración para Aegis Pentest Automation
"""

import os
import yaml
import shutil
from pathlib import Path
from typing import Dict, Any, List
import platform


class Config:
    """Gestor de configuración de la aplicación"""
    
    _instance = None
    _config = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if self._config is None:
            self.load()
    
    @classmethod
    def load(cls, config_path: str = None):
        """Carga la configuración desde archivo"""
        if config_path:
            config_file = Path(config_path)
        else:
            config_file = cls._get_default_config_path()
        
        if not config_file.exists():
            cls._create_default_config(config_file)
        
        with open(config_file, 'r', encoding='utf-8') as f:
            cls._config = yaml.safe_load(f)
        
        # Validar configuración
        cls._validate_config()
        
        return cls._config
    
    @staticmethod
    def _get_default_config_path() -> Path:
        """Obtiene la ruta del archivo de configuración por defecto"""
        home = Path.home()
        config_dir = home / ".aegis"
        config_dir.mkdir(exist_ok=True)
        return config_dir / "config.yaml"
    
    @classmethod
    def _create_default_config(cls, config_path: Path):
        """Crea el archivo de configuración por defecto"""
        default_config = {
            'tools': {
                'nmap': {
                    'path': shutil.which('nmap') or '/usr/bin/nmap',
                    'timeout': 300,
                    'default_args': ['-sV', '-sC', '--version-light']
                },
                'nuclei': {
                    'path': shutil.which('nuclei') or '/usr/local/bin/nuclei',
                    'timeout': 600,
                    'templates_path': str(Path.home() / 'nuclei-templates'),
                    'default_args': ['-es', 'info,low,medium,high,critical']
                },
                'gobuster': {
                    'path': shutil.which('gobuster') or '/usr/bin/gobuster',
                    'timeout': 300,
                    'wordlist': '/usr/share/wordlists/dirb/common.txt',
                    'default_args': ['-t', '50', '-x', 'php,html,txt,js']
                },
                'nikto': {
                    'path': shutil.which('nikto') or '/usr/bin/nikto',
                    'timeout': 1800,
                    'default_args': ['-h']
                },
                'sqlmap': {
                    'path': shutil.which('sqlmap') or '/usr/bin/sqlmap',
                    'timeout': 900,
                    'default_args': ['--batch', '--smart']
                },
                'hydra': {
                    'path': shutil.which('hydra') or '/usr/bin/hydra',
                    'timeout': 300,
                    'default_args': ['-t', '4']
                },
                'subfinder': {
                    'path': shutil.which('subfinder') or '/usr/local/bin/subfinder',
                    'timeout': 300,
                    'default_args': ['-silent']
                },
                'ffuf': {
                    'path': shutil.which('ffuf') or '/usr/local/bin/ffuf',
                    'timeout': 600,
                    'wordlist': '/usr/share/wordlists/dirb/common.txt',
                    'default_args': ['-c', '-sf', '-mc', '200,204,301,302,307,401,403']
                },
                'zaproxy': {
                    'path': shutil.which('zap-baseline.py') or '/usr/share/zaproxy/zap-baseline.py',
                    'timeout': 600,
                    'default_args': ['-J', '-', '-m', '5', '-z', '-config api.disablekey=true']
                },
                'nginxpwner': {
                    'path': './external-tools/nginxpwner/nginxpwner.py',
                    'timeout': 300,
                    'default_args': []
                },
                'shodan': {
                    'path': shutil.which('shodan') or '/usr/local/bin/shodan',
                    'timeout': 60,
                    'api_key': '',
                    'default_args': []
                },
                'traceroute': {
                    'path': shutil.which('traceroute') or '/usr/bin/traceroute',
                    'timeout': 120,
                    'default_args': ['-m', '30', '-q', '3']
                },
                'w3af': {
                    'path': './external-tools/w3af/w3af_console',
                    'timeout': 1800,
                    'default_args': []
                },
                'cloudsploit': {
                    'path': './cloudsploit/index.js',
                    'timeout': 900,
                    'aws_profile': 'default',
                    'default_args': []
                },
                'censys': {
                    'path': shutil.which('censys') or '/usr/local/bin/censys',
                    'timeout': 60,
                    'api_id': '',
                    'api_secret': '',
                    'default_args': ['--format', 'json']
                },
                'apache_vuln': {
                    'path': './poc_vulnerability_testing.py',
                    'timeout': 300,
                    'default_args': []
                }
            },
            'output': {
                'default_format': 'html',
                'save_path': str(Path.home() / 'aegis-reports'),
                'templates_path': 'resources/templates',
                'auto_save': True,
                'timestamp_format': '%Y%m%d_%H%M%S'
            },
            'threading': {
                'max_workers': 4,
                'timeout_multiplier': 1.5,
                'retry_attempts': 3
            },
            'logging': {
                'level': 'INFO',
                'file': str(Path.home() / '.aegis' / 'aegis.log'),
                'max_size': '10MB',
                'backup_count': 5
            },
            'ui': {
                'theme': 'dark',
                'window_size': [1200, 800],
                'auto_refresh': True,
                'refresh_interval': 5
            },
            'security': {
                'confirm_destructive': True,
                'max_target_size': 256,
                'allowed_target_types': ['domain', 'ip', 'url'],
                'blacklist_private': False
            }
        }
        
        # Crear directorio de reportes
        reports_dir = Path(default_config['output']['save_path'])
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        # Escribir configuración
        with open(config_path, 'w', encoding='utf-8') as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)
    
    @classmethod
    def _validate_config(cls):
        """Valida la configuración cargada"""
        if not cls._config:
            raise ValueError("Configuración no cargada")
        
        required_sections = ['tools', 'output', 'threading']
        for section in required_sections:
            if section not in cls._config:
                raise ValueError(f"Sección requerida '{section}' no encontrada en configuración")
    
    def get(self, key: str, default=None):
        """Obtiene un valor de configuración usando notación de punto"""
        keys = key.split('.')
        value = self._config
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def set(self, key: str, value: Any):
        """Establece un valor de configuración usando notación de punto"""
        keys = key.split('.')
        config = self._config
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def get_tool_config(self, tool_name: str) -> Dict[str, Any]:
        """Obtiene la configuración de una herramienta específica"""
        return self.get(f'tools.{tool_name}', {})
    
    def is_tool_available(self, tool_name: str) -> bool:
        """Verifica si una herramienta está disponible buscando dinámicamente"""
        # Primero buscar en PATH
        tool_path = shutil.which(tool_name)
        if tool_path and Path(tool_path).exists() and os.access(tool_path, os.X_OK):
            # Actualizar la configuración con la nueva ruta encontrada
            self.set(f'tools.{tool_name}.path', tool_path)
            return True
        
        # Buscar en rutas comunes basadas en el sistema operativo
        common_paths = []
        system = platform.system().lower()
        
        if system == 'darwin':  # macOS
            common_paths = [
                f"/usr/local/bin/{tool_name}",
                f"/opt/homebrew/bin/{tool_name}",
                f"/usr/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name)
            ]
        elif system == 'linux':
            common_paths = [
                f"/usr/bin/{tool_name}",
                f"/usr/local/bin/{tool_name}",
                f"/opt/{tool_name}/{tool_name}",
                f"/snap/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                str(Path.home() / ".local" / "bin" / tool_name)
            ]
        
        # Verificar cada ruta común
        for path in common_paths:
            if Path(path).exists() and os.access(path, os.X_OK):
                # Actualizar la configuración con la nueva ruta encontrada
                self.set(f'tools.{tool_name}.path', path)
                return True
        
        # Como último recurso, verificar la ruta configurada (puede ser obsoleta)
        tool_config = self.get_tool_config(tool_name)
        if tool_config:
            configured_path = tool_config.get('path')
            if configured_path and Path(configured_path).exists() and os.access(configured_path, os.X_OK):
                return True
        
        return False
    
    def get_available_tools(self) -> Dict[str, List[Dict[str, Any]]]:
        """Obtiene una lista de todas las herramientas organizadas por categoría"""
        tools = {
            'reconnaissance': [
                {'name': 'nmap', 'description': 'Escaneo de puertos y servicios'},
                {'name': 'subfinder', 'description': 'Enumeración de subdominios'},
                {'name': 'nuclei', 'description': 'Templates de vulnerabilidades'},
                {'name': 'shodan', 'description': 'Inteligencia de infraestructura global'},
                {'name': 'censys', 'description': 'Motor de búsqueda de dispositivos conectados'},
                {'name': 'traceroute', 'description': 'Análisis de rutas de red'}
            ],
            'web_analysis': [
                {'name': 'gobuster', 'description': 'Fuzzing de directorios y archivos'},
                {'name': 'nikto', 'description': 'Escáner de vulnerabilidades web'},
                {'name': 'sqlmap', 'description': 'Detección de inyecciones SQL'},
                {'name': 'ffuf', 'description': 'Fuzzer web rápido y flexible'},
                {'name': 'zaproxy', 'description': 'Proxy de seguridad OWASP ZAP'},
                {'name': 'w3af', 'description': 'Framework de auditoría web'}
            ],
            'server_analysis': [
                {'name': 'nginxpwner', 'description': 'Análisis de configuraciones Nginx'},
                {'name': 'apache_vuln', 'description': 'Testing de vulnerabilidades Apache'}
            ],
            'cloud_security': [
                {'name': 'cloudsploit', 'description': 'Auditoría de configuraciones cloud (AWS/Azure/GCP)'}
            ],
            'brute_force': [
                {'name': 'hydra', 'description': 'Ataques de fuerza bruta'}
            ]
        }
        
        # Agregar estado de disponibilidad
        for category in tools:
            for tool in tools[category]:
                tool['available'] = self.is_tool_available(tool['name'])
        
        return tools
    
    def get_tool_path(self, tool_name: str) -> str:
        """Obtiene la ruta de una herramienta específica"""
        tool_config = self.get_tool_config(tool_name)
        return tool_config.get('path', '')
    
    def get_tool_version(self, tool_name: str) -> str:
        """Obtiene la versión de una herramienta específica"""
        tool_path = self.get_tool_path(tool_name)
        if not tool_path or not os.path.exists(tool_path):
            return "N/A"
        
        import subprocess
        try:
            # Intentar obtener versión con diferentes comandos comunes
            version_commands = [
                [tool_path, '--version'],
                [tool_path, '-version'],
                [tool_path, 'version'],
                [tool_path, '-V'],
                [tool_path, '-v']
            ]
            
            for cmd in version_commands:
                try:
                    result = subprocess.run(
                        cmd, 
                        capture_output=True, 
                        text=True, 
                        timeout=5
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        # Extraer primera línea que contenga números de versión
                        lines = result.stdout.strip().split('\n')
                        for line in lines:
                            if any(char.isdigit() for char in line):
                                return line.strip()[:50]  # Limitar a 50 caracteres
                        return result.stdout.strip().split('\n')[0][:50]
                except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
                    continue
            
            return "Disponible"
        except Exception:
            return "Error"
    
    def get_setting(self, setting_path: str, default=None) -> Any:
        """Obtiene un valor de configuración general"""
        return self.get(setting_path, default)
    
    def save(self, config_path: str = None):
        """Guarda la configuración actual"""
        if config_path:
            config_file = Path(config_path)
        else:
            config_file = self._get_default_config_path()
        
        with open(config_file, 'w', encoding='utf-8') as f:
            yaml.dump(self._config, f, default_flow_style=False, indent=2)
    
    def refresh_tools_detection(self) -> Dict[str, bool]:
        """Refresca la detección de herramientas disponibles"""
        tools_to_check = [
            'nmap', 'nuclei', 'gobuster', 'nikto', 'sqlmap', 'hydra', 'subfinder',
            'ffuf', 'zap-baseline.py', 'shodan', 'traceroute', 'w3af_console',
            'censys', 'openssl', 'nginxpwner', 'apache_vuln', 'cloudsploit'
        ]
        
        results = {}
        for tool in tools_to_check:
            # Usar el mismo método que force_tool_detection
            tool_path = shutil.which(tool)
            if not tool_path:
                tool_path = self._manual_tool_search(tool)
            
            if tool_path:
                self._config['tools'][tool] = self._config['tools'].get(tool, {})
                self._config['tools'][tool]['path'] = tool_path
                results[tool] = True
            else:
                results[tool] = False
        
        self.save()
        return results

    def force_tool_detection(self, tool_name: str) -> bool:
        """Fuerza la detección de una herramienta específica recién instalada"""
        import time
        import shutil
        
        # Esperar un momento para que el sistema detecte cambios en PATH
        time.sleep(2)
        
        # Intentar múltiples métodos de detección
        tool_path = None
        
        # 1. Detección estándar usando shutil.which
        tool_path = shutil.which(tool_name)
        
        # 2. Si no se encuentra, forzar recarga de PATH y probar de nuevo
        if not tool_path:
            # Recargar PATH del shell actual
            import os
            if 'PATH' in os.environ:
                # Agregar rutas comunes
                common_paths = [
                    '/usr/local/bin',
                    '/opt/homebrew/bin', 
                    '/usr/bin',
                    str(Path.home() / 'go' / 'bin'),
                    str(Path.home() / '.local' / 'bin')
                ]
                
                current_path = os.environ['PATH']
                for path in common_paths:
                    if path not in current_path:
                        os.environ['PATH'] = f"{path}:{current_path}"
                
                # Probar detección de nuevo usando shutil.which
                tool_path = shutil.which(tool_name)
        
        # 3. Búsqueda manual en ubicaciones específicas
        if not tool_path:
            tool_path = self._manual_tool_search(tool_name)
        
        if tool_path:
            # Actualizar configuración
            if 'tools' not in self._config:
                self._config['tools'] = {}
            if tool_name not in self._config['tools']:
                self._config['tools'][tool_name] = {}
            
            self._config['tools'][tool_name]['path'] = tool_path
            self.save()
            return True
        
        return False
    
    def _manual_tool_search(self, tool_name: str) -> str:
        """Búsqueda manual de herramientas en ubicaciones específicas"""
        import shutil
        import glob
        import platform
        
        # Primero probar shutil.which de nuevo
        tool_path = shutil.which(tool_name)
        if tool_path:
            return tool_path
        
        # Mapeos específicos para herramientas con nombres diferentes - BUSCAR PRIMERO
        tool_mappings = {
            'zap-baseline.py': [
                '/Applications/ZAP.app/Contents/MacOS/zap-baseline.py',
                '/usr/share/zaproxy/zap-baseline.py',
                '/opt/zaproxy/zap-baseline.py'
            ],
            'w3af_console': [
                './external-tools/w3af/w3af_console',
                './external-tools/w3af/w3af_console.py',
                './external-tools/w3af/w3af'
            ],
            'nginxpwner': [
                './external-tools/nginxpwner/nginxpwner.py'
            ],
            'apache_vuln': [
                './poc_vulnerability_testing.py'
            ]
        }
        
        # Buscar primero en mapeos específicos
        if tool_name in tool_mappings:
            for path in tool_mappings[tool_name]:
                if Path(path).exists():
                    # Para scripts de Python, verificar que sean ejecutables o sean .py
                    if path.endswith('.py') or os.access(path, os.X_OK):
                        return path
        
        # Rutas adicionales específicas del sistema
        system = platform.system().lower()
        additional_paths = []
        
        if system == 'darwin':
            additional_paths = [
                f"/usr/local/bin/{tool_name}",
                f"/opt/homebrew/bin/{tool_name}",
                f"/usr/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                f"/usr/local/Cellar/*/bin/{tool_name}",
                f"/Applications/ZAP.app/Contents/MacOS/{tool_name}"  # Para ZAP
            ]
        elif system == 'linux':
            additional_paths = [
                f"/usr/bin/{tool_name}",
                f"/usr/local/bin/{tool_name}",
                f"/opt/{tool_name}/{tool_name}",
                f"/snap/bin/{tool_name}",
                str(Path.home() / "go" / "bin" / tool_name),
                str(Path.home() / ".local" / "bin" / tool_name)
            ]
        
        for path in additional_paths:
            if "*" in path:
                # Manejar rutas con wildcards
                matches = glob.glob(path)
                for match in matches:
                    if Path(match).exists() and os.access(match, os.X_OK):
                        return match
            else:
                if Path(path).exists():
                    # Para scripts de Python, verificar que sean ejecutables o sean .py
                    if path.endswith('.py') or os.access(path, os.X_OK):
                        return path
        
        return ""
    
    @property
    def reports_dir(self) -> Path:
        """Directorio de reportes"""
        return Path(self.get('output.save_path'))
    
    @property
    def max_workers(self) -> int:
        """Número máximo de workers"""
        return self.get('threading.max_workers', 4)
    
    @property
    def default_timeout(self) -> int:
        """Timeout por defecto para herramientas"""
        return self.get('threading.default_timeout', 300) 