"""
Funciones auxiliares y utilitarias para Aegis Pentest Automation
"""

import re
import ipaddress
import logging
import socket
from urllib.parse import urlparse
from typing import List, Tuple, Optional


def setup_logging(verbose: bool = False, log_file: str = None):
    """Configura el sistema de logging"""
    level = logging.DEBUG if verbose else logging.INFO
    
    # Formato de log
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Logger raíz
    logger = logging.getLogger()
    logger.setLevel(level)
    
    # Handler para consola
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # Handler para archivo si se especifica
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)


def validate_target(target: str) -> Tuple[bool, str, str]:
    """
    Valida un objetivo de pentesting
    
    Returns:
        Tuple[bool, str, str]: (is_valid, target_type, error_message)
    """
    if not target or len(target.strip()) == 0:
        return False, "", "Objetivo vacío"
    
    target = target.strip()
    
    # Verificar si es una URL
    if target.startswith(('http://', 'https://')):
        try:
            parsed = urlparse(target)
            if parsed.netloc:
                return True, "url", ""
            else:
                return False, "", "URL inválida"
        except Exception as e:
            return False, "", f"Error parseando URL: {str(e)}"
    
    # Verificar si es una dirección IP
    try:
        ip = ipaddress.ip_address(target)
        if ip.is_private:
            return True, "private_ip", "Dirección IP privada"
        elif ip.is_loopback:
            return True, "loopback_ip", "Dirección IP de loopback"
        else:
            return True, "public_ip", ""
    except ValueError:
        pass
    
    # Verificar si es un rango CIDR
    try:
        network = ipaddress.ip_network(target, strict=False)
        return True, "ip_range", ""
    except ValueError:
        pass
    
    # Verificar si es un dominio válido
    if is_valid_domain(target):
        return True, "domain", ""
    
    return False, "", "Formato de objetivo no reconocido"


def is_valid_domain(domain: str) -> bool:
    """Verifica si un string es un dominio válido"""
    if len(domain) > 253:
        return False
    
    # Regex para validar dominio
    domain_regex = re.compile(
        r'^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'
    )
    
    return bool(domain_regex.match(domain))


def parse_ports(port_string: str) -> List[int]:
    """
    Parsea una cadena de puertos y devuelve una lista de puertos
    
    Formatos soportados:
    - "80" -> [80]
    - "80,443,8080" -> [80, 443, 8080]
    - "1-1000" -> [1, 2, 3, ..., 1000]
    - "80,443,8000-8010" -> [80, 443, 8000, 8001, ..., 8010]
    """
    ports = []
    
    for part in port_string.split(','):
        part = part.strip()
        
        if '-' in part:
            # Rango de puertos
            try:
                start, end = part.split('-', 1)
                start, end = int(start.strip()), int(end.strip())
                
                if start > end:
                    start, end = end, start
                
                if start < 1 or end > 65535:
                    raise ValueError(f"Puerto fuera de rango: {part}")
                
                ports.extend(range(start, end + 1))
            except ValueError as e:
                raise ValueError(f"Rango de puertos inválido: {part}")
        else:
            # Puerto individual
            try:
                port = int(part)
                if port < 1 or port > 65535:
                    raise ValueError(f"Puerto fuera de rango: {port}")
                ports.append(port)
            except ValueError:
                raise ValueError(f"Puerto inválido: {part}")
    
    return sorted(list(set(ports)))  # Eliminar duplicados y ordenar


def resolve_domain(domain: str) -> Optional[str]:
    """Resuelve un dominio a su dirección IP"""
    try:
        return socket.gethostbyname(domain)
    except socket.gaierror:
        return None


def check_port_open(host: str, port: int, timeout: int = 5) -> bool:
    """Verifica si un puerto está abierto"""
    try:
        with socket.create_connection((host, port), timeout=timeout):
            return True
    except (socket.timeout, socket.error):
        return False


def format_file_size(size_bytes: int) -> str:
    """Formatea un tamaño de archivo en bytes a formato legible"""
    if size_bytes == 0:
        return "0B"
    
    size_names = ["B", "KB", "MB", "GB", "TB"]
    i = 0
    while size_bytes >= 1024 and i < len(size_names) - 1:
        size_bytes /= 1024.0
        i += 1
    
    return f"{size_bytes:.1f}{size_names[i]}"


def sanitize_filename(filename: str) -> str:
    """Sanitiza un nombre de archivo eliminando caracteres peligrosos"""
    # Caracteres no permitidos en nombres de archivo
    dangerous_chars = '<>:"/\\|?*'
    
    for char in dangerous_chars:
        filename = filename.replace(char, '_')
    
    # Eliminar espacios múltiples y al inicio/final
    filename = re.sub(r'\s+', ' ', filename).strip()
    
    # Limitar longitud
    if len(filename) > 255:
        name, ext = filename.rsplit('.', 1) if '.' in filename else (filename, '')
        max_name_len = 255 - len(ext) - 1 if ext else 255
        filename = name[:max_name_len] + ('.' + ext if ext else '')
    
    return filename


def extract_domain_from_url(url: str) -> Optional[str]:
    """Extrae el dominio de una URL"""
    try:
        parsed = urlparse(url)
        return parsed.netloc.lower()
    except Exception:
        return None


def is_private_ip(ip: str) -> bool:
    """Verifica si una IP es privada"""
    try:
        return ipaddress.ip_address(ip).is_private
    except ValueError:
        return False


def generate_report_filename(target: str, scan_type: str = "scan", extension: str = "html") -> str:
    """Genera un nombre de archivo para reportes"""
    from datetime import datetime
    
    # Sanitizar el objetivo
    safe_target = sanitize_filename(target)
    
    # Timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    return f"aegis_{scan_type}_{safe_target}_{timestamp}.{extension}"


def chunk_list(lst: List, chunk_size: int) -> List[List]:
    """Divide una lista en chunks de tamaño específico"""
    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]


def merge_port_ranges(ports: List[int]) -> str:
    """Convierte una lista de puertos en rangos compactos"""
    if not ports:
        return ""
    
    ports = sorted(set(ports))
    ranges = []
    start = end = ports[0]
    
    for port in ports[1:]:
        if port == end + 1:
            end = port
        else:
            if start == end:
                ranges.append(str(start))
            else:
                ranges.append(f"{start}-{end}")
            start = end = port
    
    # Agregar el último rango
    if start == end:
        ranges.append(str(start))
    else:
        ranges.append(f"{start}-{end}")
    
    return ",".join(ranges)


class ProgressCallback:
    """Callback para reportar progreso de operaciones largas"""
    
    def __init__(self, total_steps: int = 100):
        self.total_steps = total_steps
        self.current_step = 0
        self.callbacks = []
    
    def add_callback(self, callback):
        """Agrega un callback que será llamado en cada actualización"""
        self.callbacks.append(callback)
    
    def update(self, step: int = None, message: str = ""):
        """Actualiza el progreso"""
        if step is not None:
            self.current_step = step
        else:
            self.current_step += 1
        
        percentage = min(100, (self.current_step / self.total_steps) * 100)
        
        for callback in self.callbacks:
            callback(self.current_step, self.total_steps, percentage, message)
    
    def finish(self, message: str = "Completado"):
        """Marca el progreso como completado"""
        self.current_step = self.total_steps
        self.update(message=message) 