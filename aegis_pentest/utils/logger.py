"""
Sistema de logging avanzado para Aegis Pentest
Maneja logs unificados con display en tiempo real en CLI
"""
import logging
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box


class ToolLogger:
    """Logger especializado para herramientas de pentesting"""
    
    def __init__(self, console: Console, logs_dir: str = None):
        self.console = console
        
        # Si no se especifica logs_dir, usar el directorio logs en la raÃ­z del repo
        if logs_dir is None:
            # Obtener la ruta del directorio raÃ­z del repositorio
            current_file = Path(__file__)
            repo_root = current_file.parent.parent.parent  # aegis_pentest/utils/logger.py -> Aegis/
            logs_dir = repo_root / "logs"
        
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        
        # Archivo de log unificado con timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.logs_dir / f"aegis_analysis_{timestamp}.txt"
        
        # Estado de herramientas activas
        self.active_tools: Dict[str, Dict] = {}
        self.tool_outputs: Dict[str, List[str]] = {}
        self.tool_errors: Dict[str, List[str]] = {}
        
        # Live display para CLI
        self.live_display: Optional[Live] = None
        self.display_table = Table(box=box.ROUNDED)
        self._setup_display_table()
        
        # Setup logging
        self._setup_logging()
        
        # Lock para thread safety
        self._lock = threading.Lock()
    
    def _setup_logging(self):
        """Configura el sistema de logging"""
        # Logger principal
        self.logger = logging.getLogger("aegis_tools")
        self.logger.setLevel(logging.DEBUG)
        
        # Handler para archivo
        file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        file_formatter = logging.Formatter(
            '%(asctime)s | %(levelname)-8s | %(name)-15s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        file_handler.setFormatter(file_formatter)
        self.logger.addHandler(file_handler)
        
        # Escribir header del archivo
        self._write_log_header()
    
    def _write_log_header(self):
        """Escribe el header del archivo de log"""
        header = f"""
{'='*80}
AEGIS PENTEST AUTOMATION - ANÃLISIS LOG
{'='*80}
Fecha/Hora inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Archivo de log: {self.log_file.name}
{'='*80}

"""
        with open(self.log_file, 'w', encoding='utf-8') as f:
            f.write(header)
    
    def _setup_display_table(self):
        """Configura la tabla de display en vivo"""
        self.display_table.add_column("Herramienta", style="cyan", width=12)
        self.display_table.add_column("Estado", style="bold", width=10)
        self.display_table.add_column("Progreso", width=20)
        self.display_table.add_column("Ãšltima Actividad", style="dim", width=30)
    
    def start_live_display(self):
        """Inicia el display en vivo"""
        if self.live_display is None:
            self.live_display = Live(
                self._generate_display(),
                console=self.console,
                refresh_per_second=2,
                vertical_overflow="ellipsis"
            )
            self.live_display.start()
    
    def stop_live_display(self):
        """Detiene el display en vivo"""
        if self.live_display:
            self.live_display.stop()
            self.live_display = None
    
    def _generate_display(self):
        """Genera el contenido del display en vivo"""
        # Crear nueva tabla
        table = Table(box=box.ROUNDED, title="ðŸ” Monitoreo de Herramientas en Tiempo Real")
        table.add_column("Herramienta", style="cyan", width=12)
        table.add_column("Estado", style="bold", width=12)
        table.add_column("Progreso", width=25)
        table.add_column("Ãšltima Actividad", style="dim", width=35)
        
        with self._lock:
            for tool_name, info in self.active_tools.items():
                status_style = self._get_status_style(info['status'])
                progress_bar = self._create_progress_bar(info.get('progress', 0))
                
                table.add_row(
                    tool_name,
                    Text(info['status'], style=status_style),
                    progress_bar,
                    info.get('last_activity', 'Iniciando...')[:35]
                )
        
        if not self.active_tools:
            table.add_row("---", "Inactivo", "---", "No hay herramientas ejecutÃ¡ndose")
        
        return Panel(table, border_style="blue")
    
    def _get_status_style(self, status: str) -> str:
        """Obtiene el estilo para el estado"""
        styles = {
            'EJECUTANDO': 'green',
            'COMPLETADO': 'bold green',
            'ERROR': 'bold red',
            'TIMEOUT': 'bold yellow',
            'INICIANDO': 'blue',
            'DETENIDO': 'red'
        }
        return styles.get(status, 'white')
    
    def _create_progress_bar(self, progress: int) -> str:
        """Crea una barra de progreso simple"""
        filled = int(progress / 10)
        empty = 10 - filled
        return f"[{'â–ˆ' * filled}{'â–‘' * empty}] {progress}%"
    
    def start_tool(self, tool_name: str, command: str, target: str = "") -> str:
        """Inicia el logging para una herramienta"""
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'command': command,
                'target': target,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}..."
            }
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
        
        # Log al archivo
        self.logger.info(f"INICIO | {tool_name} | Target: {target}")
        self.logger.info(f"COMANDO | {tool_name} | {command}")
        
        return tool_id
    
    def log_tool_output(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        
        with self._lock:
            # Inicializar estructuras si no existen
            if tool_name not in self.tool_outputs:
                self.tool_outputs[tool_name] = []
            if tool_name not in self.tool_errors:
                self.tool_errors[tool_name] = []
            
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'EJECUTANDO'
                self.active_tools[tool_name]['last_activity'] = output[:50] + "..." if len(output) > 50 else output
            
            if is_error:
                self.tool_errors[tool_name].append(f"[{timestamp}] {output}")
                self.logger.error(f"ERROR | {tool_name} | {output}")
            else:
                self.tool_outputs[tool_name].append(f"[{timestamp}] {output}")
                self.logger.info(f"OUTPUT | {tool_name} | {output}")
        
        # Mostrar en CLI si no estÃ¡ en live mode
        if not self.live_display:
            style = "red" if is_error else "green"
            self.console.print(f"[{style}]{tool_name}:[/] {output}")
    
    def update_tool_progress(self, tool_name: str, progress: int, activity: str = ""):
        """Actualiza el progreso de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['progress'] = min(100, max(0, progress))
                if activity:
                    self.active_tools[tool_name]['last_activity'] = activity
        
        self.logger.info(f"PROGRESO | {tool_name} | {progress}% | {activity}")
    
    def finish_tool(self, tool_name: str, success: bool = True, error_msg: str = ""):
        """Finaliza el logging de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                tool_info = self.active_tools[tool_name]
                end_time = datetime.now()
                duration = end_time - tool_info['start_time']
                
                status = 'COMPLETADO' if success else 'ERROR'
                tool_info['status'] = status
                tool_info['progress'] = 100 if success else tool_info.get('progress', 0)
                tool_info['end_time'] = end_time
                tool_info['duration'] = duration
                
                if error_msg:
                    tool_info['last_activity'] = f"Error: {error_msg[:30]}..."
                    self.logger.error(f"FINAL ERROR | {tool_name} | {error_msg}")
                else:
                    tool_info['last_activity'] = "Completado exitosamente"
                
                self.logger.info(f"FIN | {tool_name} | Status: {status} | DuraciÃ³n: {duration}")
                
                # Escribir resumen al archivo
                self._write_tool_summary(tool_name, tool_info)
    
    def _write_tool_summary(self, tool_name: str, tool_info: Dict):
        """Escribe un resumen de la herramienta al archivo"""
        summary = f"""
{'-'*60}
RESUMEN DE HERRAMIENTA: {tool_name.upper()}
{'-'*60}
ID: {tool_info['id']}
Estado Final: {tool_info['status']}
Comando: {tool_info['command']}
Target: {tool_info.get('target', 'N/A')}
Inicio: {tool_info['start_time'].strftime('%Y-%m-%d %H:%M:%S')}
Fin: {tool_info.get('end_time', 'N/A')}
DuraciÃ³n: {tool_info.get('duration', 'N/A')}

OUTPUTS ({len(self.tool_outputs.get(tool_name, []))} lÃ­neas):
{chr(10).join(self.tool_outputs.get(tool_name, []))}

ERRORES ({len(self.tool_errors.get(tool_name, []))} lÃ­neas):
{chr(10).join(self.tool_errors.get(tool_name, []))}
{'-'*60}

"""
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(summary)
    
    def handle_tool_timeout(self, tool_name: str, timeout_duration: int):
        """Maneja timeout de herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'TIMEOUT'
                self.active_tools[tool_name]['last_activity'] = f"Timeout despuÃ©s de {timeout_duration}s"
        
        error_msg = f"Herramienta {tool_name} excediÃ³ timeout de {timeout_duration} segundos"
        self.logger.error(f"TIMEOUT | {tool_name} | {error_msg}")
        self.finish_tool(tool_name, False, error_msg)
    
    def handle_tool_not_found(self, tool_name: str, tool_path: str = ""):
        """Maneja herramienta no encontrada"""
        error_msg = f"Herramienta {tool_name} no encontrada"
        if tool_path:
            error_msg += f" en ruta: {tool_path}"
        
        self.logger.error(f"NOT_FOUND | {tool_name} | {error_msg}")
        
        # Mostrar error en CLI
        self.console.print(Panel(
            f"[bold red]âŒ Error: {error_msg}[/]\n\n"
            f"[yellow]Soluciones:[/]\n"
            f"â€¢ Verificar instalaciÃ³n: [cyan]which {tool_name}[/]\n"
            f"â€¢ Instalar herramienta desde el menÃº principal (opciÃ³n 6)\n"
            f"â€¢ Configurar ruta en ~/.aegis/config.yaml",
            title=f"Herramienta No Encontrada: {tool_name}",
            border_style="red"
        ))
    
    def get_tool_status(self, tool_name: str) -> Optional[Dict]:
        """Obtiene el estado actual de una herramienta"""
        with self._lock:
            return self.active_tools.get(tool_name)
    
    def get_log_file_path(self) -> Path:
        """Obtiene la ruta del archivo de log actual"""
        return self.log_file
    
    def cleanup(self):
        """Limpia recursos"""
        self.stop_live_display()
        
        # Escribir footer
        footer = f"""
{'='*80}
FIN DEL ANÃLISIS
{'='*80}
Fecha/Hora fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total de herramientas ejecutadas: {len(self.active_tools)}
Archivo de log: {self.log_file.name}
{'='*80}
"""
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(footer)


# Instancia global del logger (se inicializa cuando se necesita)
_global_logger: Optional[ToolLogger] = None


def get_logger(console: Optional[Console] = None) -> ToolLogger:
    """Obtiene la instancia global del logger"""
    global _global_logger
    if _global_logger is None:
        if console is None:
            console = Console()
        _global_logger = ToolLogger(console)
    return _global_logger


def cleanup_logger():
    """Limpia el logger global"""
    global _global_logger
    if _global_logger:
        _global_logger.cleanup()
        _global_logger = None 