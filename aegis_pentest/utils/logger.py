"""
Sistema de logging avanzado para Aegis Pentest
Maneja logs unificados con display en tiempo real en CLI
"""
import logging
import threading
import time
import re
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box


class ToolLogger:
    """Logger especializado para herramientas de pentesting"""
    
    def __init__(self, console: Console, logs_dir: str = None):
        self.console = console
        
        # Si no se especifica logs_dir, usar el directorio logs en la raÃ­z del repo
        if logs_dir is None:
            # Obtener la ruta del directorio raÃ­z del repositorio
            current_file = Path(__file__)
            repo_root = current_file.parent.parent.parent  # aegis_pentest/utils/logger.py -> Aegis/
            logs_dir = repo_root / "logs"
        
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        
        # NO crear el archivo de log inmediatamente - solo preparar para cuando se necesite
        self.log_file = None
        self._log_file_initialized = False
        
        # Estado de herramientas activas
        self.active_tools: Dict[str, Dict] = {}
        self.tool_outputs: Dict[str, List[str]] = {}
        self.tool_errors: Dict[str, List[str]] = {}
        
        # Live display para CLI
        self.live_display: Optional[Live] = None
        self.display_table = Table(box=box.ROUNDED)
        self._setup_display_table()
        
        # Setup logging solo para consola/debugging interno
        self._setup_logging()
        
        # Lock para thread safety
        self._lock = threading.Lock()
    
    def _setup_logging(self):
        """Configura el sistema de logging solo para consola/debugging interno"""
        # Logger principal solo para debugging interno, no para archivo
        self.logger = logging.getLogger("aegis_tools")
        self.logger.setLevel(logging.DEBUG)
        
        # Solo mantener el logger para debugging interno, no escribir al archivo de log principal
        # El archivo se manejarÃ¡ manualmente con los resÃºmenes limpios
    
    def _write_log_header(self):
        """Escribe el header del archivo de log"""
        header = f"""
AEGIS PENTEST AUTOMATION - ANÃLISIS LOG
Fecha/Hora inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Archivo de log: {self.log_file.name}
{'='*80}

"""
        with open(self.log_file, 'w', encoding='utf-8') as f:
            f.write(header)
    
    def _setup_display_table(self):
        """Configura la tabla de display en vivo"""
        self.display_table.add_column("Herramienta", style="cyan", width=12)
        self.display_table.add_column("Estado", style="bold", width=10)
        self.display_table.add_column("Progreso", width=20)
        self.display_table.add_column("Ãšltima Actividad", style="dim", width=30)
    
    def start_live_display(self):
        """Inicia el display en vivo"""
        if self.live_display is None:
            self.live_display = Live(
                self._generate_display(),
                console=self.console,
                refresh_per_second=2,
                vertical_overflow="ellipsis"
            )
            self.live_display.start()
    
    def stop_live_display(self):
        """Detiene el display en vivo"""
        if self.live_display:
            self.live_display.stop()
            self.live_display = None
    
    def _generate_display(self):
        """Genera el contenido del display en vivo"""
        # Crear nueva tabla
        table = Table(box=box.ROUNDED, title="ðŸ” Monitoreo de Herramientas en Tiempo Real")
        table.add_column("Herramienta", style="cyan", width=12)
        table.add_column("Estado", style="bold", width=12)
        table.add_column("Progreso", width=25)
        table.add_column("Ãšltima Actividad", style="dim", width=35)
        
        with self._lock:
            for tool_name, info in self.active_tools.items():
                status_style = self._get_status_style(info['status'])
                progress_bar = self._create_progress_bar(info.get('progress', 0))
                
                table.add_row(
                    tool_name,
                    Text(info['status'], style=status_style),
                    progress_bar,
                    info.get('last_activity', 'Iniciando...')[:35]
                )
        
        if not self.active_tools:
            table.add_row("---", "Inactivo", "---", "No hay herramientas ejecutÃ¡ndose")
        
        return Panel(table, border_style="blue")
    
    def _get_status_style(self, status: str) -> str:
        """Obtiene el estilo para el estado"""
        styles = {
            'EJECUTANDO': 'green',
            'COMPLETADO': 'bold green',
            'ERROR': 'bold red',
            'TIMEOUT': 'bold yellow',
            'INICIANDO': 'blue',
            'DETENIDO': 'red'
        }
        return styles.get(status, 'white')
    
    def _create_progress_bar(self, progress: int) -> str:
        """Crea una barra de progreso simple"""
        filled = int(progress / 10)
        empty = 10 - filled
        return f"[{'â–ˆ' * filled}{'â–‘' * empty}] {progress}%"
    
    def start_tool(self, tool_name: str, command: str, target: str = "") -> str:
        """Inicia el logging para una herramienta"""
        # Asegurar que el archivo de log estÃ© inicializado cuando realmente se use por primera vez
        self._ensure_log_file_initialized()
        
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'command': command,
                'target': target,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}..."
            }
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
        
        # Solo logging interno, no escribir al archivo
        return tool_id
    
    def log_tool_output(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta"""
        with self._lock:
            # Inicializar estructuras si no existen
            if tool_name not in self.tool_outputs:
                self.tool_outputs[tool_name] = []
            if tool_name not in self.tool_errors:
                self.tool_errors[tool_name] = []
            
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'EJECUTANDO'
                self.active_tools[tool_name]['last_activity'] = output[:50] + "..." if len(output) > 50 else output
            
            # Limpiar el output de timestamps redundantes si es necesario
            clean_output = self._clean_output_timestamps(output)
            
            # Formatear especÃ­ficamente para Nuclei si es JSON
            if tool_name.lower() == 'nuclei' and not is_error:
                formatted_output = self._format_nuclei_output(clean_output)
                if formatted_output:
                    clean_output = formatted_output
            
            # Para Nikto, filtrar quÃ© se guarda en archivo vs lo que se muestra en consola
            output_for_file = clean_output
            if tool_name.lower() == 'nikto' and not is_error:
                # Filtrar para archivo: solo hallazgos reales
                filtered_output = self._format_nikto_output(clean_output)
                if filtered_output:  # Solo guardar en archivo si es un hallazgo real
                    output_for_file = filtered_output
                else:
                    output_for_file = None  # No guardar en archivo
            
            # Almacenar el output filtrado para el resumen final (solo hallazgos)
            if is_error:
                self.tool_errors[tool_name].append(clean_output)
            else:
                if output_for_file:  # Solo agregar si hay contenido vÃ¡lido
                    self.tool_outputs[tool_name].append(output_for_file)
        
        # Mostrar en CLI si no estÃ¡ en live mode (siempre mostrar el output completo)
        if not self.live_display:
            style = "red" if is_error else "green"
            self.console.print(f"[{style}]{tool_name}:[/] {clean_output}")
    
    def _clean_output_timestamps(self, output: str) -> str:
        """Limpia timestamps redundantes del output de herramientas"""
        # Eliminar timestamps en formato [HH:MM:SS] del principio de la lÃ­nea
        output = re.sub(r'^\[\d{2}:\d{2}:\d{2}\]\s*', '', output)
        
        # TambiÃ©n limpiar timestamps en formato mÃ¡s largo si existen
        output = re.sub(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*[\|\-]*\s*', '', output)
        
        return output.strip()
    
    def _format_nuclei_output(self, output: str) -> str:
        """Formatea el output JSON de Nuclei para hacerlo mÃ¡s legible y completo en los logs"""
        if not output.strip():
            return output
        
        try:
            # Intentar parsear como JSON
            import json
            vuln_data = json.loads(output)
            
            # Extraer informaciÃ³n esencial
            template_id = vuln_data.get('template-id', 'N/A')
            template_name = vuln_data.get('template', 'N/A')
            info = vuln_data.get('info', {})
            vuln_name = info.get('name', 'N/A')
            severity = info.get('severity', 'unknown').upper()
            host = vuln_data.get('host', 'N/A')
            url = vuln_data.get('url', vuln_data.get('matched-at', 'N/A'))
            ip = vuln_data.get('ip', 'N/A')
            
            # Agregar emoji y color segÃºn severidad
            severity_icons = {
                'CRITICAL': 'ðŸ”´ CRITICAL',
                'HIGH': 'ðŸŸ  HIGH', 
                'MEDIUM': 'ðŸŸ¡ MEDIUM',
                'LOW': 'ðŸ”µ LOW',
                'INFO': 'âšª INFO'
            }
            severity_display = severity_icons.get(severity, f'âš« {severity}')
            
            # Obtener tags completos
            tags = info.get('tags', [])
            tags_str = ', '.join(tags) if tags else 'N/A'
            
            # Obtener descripciÃ³n COMPLETA (sin recortar)
            description = info.get('description', 'Sin descripciÃ³n disponible')
            
            # Obtener autores completos
            authors = info.get('author', [])
            author_str = ', '.join(authors) if authors else 'N/A'
            
            # InformaciÃ³n de clasificaciÃ³n y referencias
            classification = info.get('classification', {})
            references = info.get('reference', [])
            
            # Metadata del template
            metadata = info.get('metadata', {})
            
            # Crear formato legible y completo
            formatted = f"""
â”Œâ”€ ðŸ” [NUCLEI FINDING] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”‚ Template ID: {template_id}
â”‚ Template Path: {template_name}
â”‚ Vulnerability: {vuln_name}
â”‚ Severity: {severity_display}
â”‚ Authors: {author_str}
â”‚ Target Host: {host}"""
            
            # Agregar IP si es diferente del host
            if ip != 'N/A' and ip != host:
                formatted += f"\nâ”‚ IP Address: {ip}"
            
            formatted += f"\nâ”‚ Target URL: {url}"
            formatted += f"\nâ”‚ Tags: {tags_str}"
            
            # DescripciÃ³n completa sin recortes
            if description:
                # Dividir descripciÃ³n en lÃ­neas para mejor legibilidad
                desc_lines = description.replace('. ', '.\n').split('\n')
                formatted += f"\nâ”‚ Description:"
                for line in desc_lines:
                    line = line.strip()
                    if line:
                        formatted += f"\nâ”‚   {line}"
            
            # InformaciÃ³n de clasificaciÃ³n si existe
            if classification:
                formatted += f"\nâ”‚ Classification:"
                for key, value in classification.items():
                    if value:
                        formatted += f"\nâ”‚   {key.title()}: {value}"
            
            # CVE Information si existe
            cve_id = classification.get('cve-id') or info.get('cve')
            if cve_id:
                formatted += f"\nâ”‚ CVE ID: {cve_id}"
            
            # CVSS Information si existe
            cvss_metrics = classification.get('cvss-metrics')
            cvss_score = classification.get('cvss-score')
            if cvss_score:
                formatted += f"\nâ”‚ CVSS Score: {cvss_score}"
            if cvss_metrics:
                formatted += f"\nâ”‚ CVSS Metrics: {cvss_metrics}"
            
            # CWE Information si existe
            cwe_id = classification.get('cwe-id')
            if cwe_id:
                formatted += f"\nâ”‚ CWE ID: {cwe_id}"
            
            # Referencias si existen
            if references:
                formatted += f"\nâ”‚ References:"
                for ref in references[:5]:  # Mostrar hasta 5 referencias
                    formatted += f"\nâ”‚   â€¢ {ref}"
                if len(references) > 5:
                    formatted += f"\nâ”‚   â€¢ ... y {len(references) - 5} referencias mÃ¡s"
            
            # Metadata adicional Ãºtil
            if metadata:
                useful_metadata = {}
                for key, value in metadata.items():
                    if key in ['max-request', 'shodan-query', 'product', 'vendor', 'verified']:
                        useful_metadata[key] = value
                
                if useful_metadata:
                    formatted += f"\nâ”‚ Metadata:"
                    for key, value in useful_metadata.items():
                        formatted += f"\nâ”‚   {key.replace('-', ' ').title()}: {value}"
            
            # InformaciÃ³n extractada si existe
            extracted_results = vuln_data.get('extracted-results', [])
            if extracted_results:
                formatted += f"\nâ”‚ Extracted Data:"
                for i, result in enumerate(extracted_results[:10]):  # Mostrar hasta 10 resultados
                    formatted += f"\nâ”‚   â€¢ {str(result)}"
                if len(extracted_results) > 10:
                    formatted += f"\nâ”‚   â€¢ ... y {len(extracted_results) - 10} resultados mÃ¡s"
            
            # InformaciÃ³n del request/response para anÃ¡lisis profundo
            request = vuln_data.get('request', '')
            response = vuln_data.get('response', '')
            
            if request:
                formatted += f"\nâ”‚ HTTP Request Analysis:"
                request_lines = request.split('\n')
                method_line = request_lines[0] if request_lines else ''
                formatted += f"\nâ”‚   Method & Path: {method_line.strip()}"
                
                # Extraer headers importantes del request
                important_req_headers = ['User-Agent', 'Content-Type', 'Authorization', 'Cookie', 'X-Forwarded-For']
                for line in request_lines[1:]:
                    for header in important_req_headers:
                        if line.strip().lower().startswith(f'{header.lower()}:'):
                            header_value = line.split(':', 1)[1].strip()
                            if len(header_value) > 80:
                                header_value = header_value[:77] + "..."
                            formatted += f"\nâ”‚   {header}: {header_value}"
                            break
            
            if response:
                formatted += f"\nâ”‚ HTTP Response Analysis:"
                response_lines = response.split('\n')
                
                # Status line
                status_line = next((line for line in response_lines if line.startswith('HTTP/')), '')
                if status_line:
                    formatted += f"\nâ”‚   Status: {status_line.strip()}"
                
                # Headers importantes de respuesta
                important_resp_headers = ['Server', 'X-Powered-By', 'Location', 'Set-Cookie', 'Content-Type', 'X-Frame-Options', 'X-XSS-Protection']
                for line in response_lines:
                    for header in important_resp_headers:
                        if line.strip().lower().startswith(f'{header.lower()}:'):
                            header_value = line.split(':', 1)[1].strip()
                            if len(header_value) > 80:
                                header_value = header_value[:77] + "..."
                            formatted += f"\nâ”‚   {header}: {header_value}"
                            break
                
                # Content length si existe
                content_length = next((line for line in response_lines if line.lower().startswith('content-length:')), '')
                if content_length:
                    length = content_length.split(':', 1)[1].strip()
                    formatted += f"\nâ”‚   Content-Length: {length} bytes"
            
            # InformaciÃ³n del tipo de matcher que detectÃ³ la vulnerabilidad
            matcher_status = vuln_data.get('matcher-status')
            if matcher_status:
                formatted += f"\nâ”‚ Detection Method: Pattern Match Successful"
            
            # InformaciÃ³n del protocolo/tipo
            protocol_type = vuln_data.get('type', 'unknown')
            if protocol_type != 'unknown':
                formatted += f"\nâ”‚ Protocol Type: {protocol_type.upper()}"
            
            # Puerto si estÃ¡ disponible
            port = vuln_data.get('port')
            if port:
                formatted += f"\nâ”‚ Port: {port}"
            
            # Scheme (http/https)
            scheme = vuln_data.get('scheme')
            if scheme:
                formatted += f"\nâ”‚ Scheme: {scheme.upper()}"
            
            # Curl command si estÃ¡ disponible (Ãºtil para reproducir)
            curl_command = vuln_data.get('curl-command')
            if curl_command and len(curl_command) < 200:
                formatted += f"\nâ”‚ Reproduction:"
                formatted += f"\nâ”‚   {curl_command}"
            
            formatted += "\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            
            return formatted
            
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            # Si no es JSON vÃ¡lido o falta informaciÃ³n, devolver el output original
            # Pero si parece ser JSON pero con error, intentar parsear parcialmente
            if output.strip().startswith('{') and output.strip().endswith('}'):
                return f"[NUCLEI] Raw JSON (parse error): {output[:300]}..."
            return output
    
    def _format_nikto_output(self, output: str) -> str:
        """Filtro optimizado para logs de Nikto - solo hallazgos importantes"""
        if not output.strip():
            return None
        
        # PATRONES A FILTRAR (NO guardar en archivo)
        filter_patterns = [
            r'^\s*[-=]+\s*$',                                      # Separadores
            r'^\s*[-+]\s*(Target|Start Time|End Time|SSL Info)',   # Headers de info
            r'^\s*[-+]\s*Nikto\s+v\d',                            # VersiÃ³n
            r'^\s*[-+]\s*\d+\s+(host|requests|error)',            # EstadÃ­sticas
            r'^\s*V:.*\d{3}\s+for\s+(GET|POST)',                  # Verbose HTTP
            r'ERROR.*error limit.*reached',                        # LÃ­mite de errores  
            r'ERROR.*Host maximum execution time',                 # Timeout
            r'Scan terminated:',                                   # TerminaciÃ³n
            r'^\s*$',                                             # VacÃ­as
            r'^\s*#',                                             # Comentarios
        ]
        
        # Si coincide con filtros, NO guardar en archivo
        for pattern in filter_patterns:
            if re.match(pattern, output, re.IGNORECASE):
                return None
        
        # PATRONES DE HALLAZGOS IMPORTANTES (SÃ guardar en archivo)
        finding_patterns = [
            # Hallazgos generales (no headers/estadÃ­sticas)
            r'^\s*\+\s*(?!Target|Server|Start|End|SSL|\d+\s+(host|requests))',
            # Vulnerabilidades especÃ­ficas
            r'OSVDB|CVE|vulnerability|security|injection|xss|clickjacking|content-type',
            # Problemas de headers de seguridad
            r'X-Frame-Options|X-Content-Type-Options|access-control|banner.*changed',
            # IPs mÃºltiples encontradas
            r'Multiple IPs found',
        ]
        
        # Si es un hallazgo importante, guardarlo con formato simple
        for pattern in finding_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                # Formato simple sin decoraciÃ³n excesiva para reducir tokens
                return f"[NIKTO] {output.strip()}"
        
        # Si contiene informaciÃ³n potencialmente Ãºtil pero no crÃ­tica
        if any(keyword in output.lower() for keyword in ['directory', 'file', 'method', 'allowed', 'server']):
            return f"[NIKTO-INFO] {output.strip()}"
        
        # No es relevante, filtrar completamente
        return None
    
    def update_tool_progress(self, tool_name: str, progress: int, activity: str = ""):
        """Actualiza el progreso de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['progress'] = min(100, max(0, progress))
                if activity:
                    self.active_tools[tool_name]['last_activity'] = activity
        
        # Solo actualizar display en vivo, no escribir al archivo
    
    def finish_tool(self, tool_name: str, success: bool = True, error_msg: str = ""):
        """Finaliza el logging de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                tool_info = self.active_tools[tool_name]
                end_time = datetime.now()
                duration = end_time - tool_info['start_time']
                
                status = 'COMPLETADO' if success else 'ERROR'
                tool_info['status'] = status
                tool_info['progress'] = 100 if success else tool_info.get('progress', 0)
                tool_info['end_time'] = end_time
                tool_info['duration'] = duration
                
                if error_msg:
                    tool_info['last_activity'] = f"Error: {error_msg[:30]}..."
                    # Agregar el error a la lista de errores
                    if tool_name not in self.tool_errors:
                        self.tool_errors[tool_name] = []
                    self.tool_errors[tool_name].append(error_msg)
                else:
                    tool_info['last_activity'] = "Completado exitosamente"
                
                # Escribir resumen limpio al archivo
                self._write_tool_summary(tool_name, tool_info)
    
    def _write_tool_summary(self, tool_name: str, tool_info: Dict):
        """Escribe un resumen limpio de la herramienta al archivo"""
        # Asegurar que el archivo de log estÃ© inicializado
        self._ensure_log_file_initialized()
        
        # Formatear duraciÃ³n
        duration = tool_info.get('duration', 'N/A')
        if duration != 'N/A':
            total_seconds = int(duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "N/A"
        
        # Formatear las fechas
        start_time_str = tool_info['start_time'].strftime('%Y-%m-%d %H:%M:%S')
        end_time = tool_info.get('end_time', 'N/A')
        end_time_str = end_time.strftime('%Y-%m-%d %H:%M:%S') if end_time != 'N/A' else 'N/A'
        
        # Resumen estÃ¡ndar para todas las herramientas (incluyendo Nuclei)
        summary = f"""
{'='*60}
{tool_name.upper()}
{'='*60}
Target: {tool_info.get('target', 'N/A')}
Inicio: {start_time_str}
Fin: {end_time_str}
DuraciÃ³n: {duration_str}

OUTPUTS ({len(self.tool_outputs.get(tool_name, []))} lÃ­neas):
{chr(10).join(self.tool_outputs.get(tool_name, []))}

ERRORES ({len(self.tool_errors.get(tool_name, []))} lÃ­neas):
{chr(10).join(self.tool_errors.get(tool_name, []))}

{'='*60}

"""
        
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(summary)
    
    def handle_tool_timeout(self, tool_name: str, timeout_duration: int):
        """Maneja timeout de herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'TIMEOUT'
                self.active_tools[tool_name]['last_activity'] = f"Timeout despuÃ©s de {timeout_duration}s"
        
        error_msg = f"Herramienta {tool_name} excediÃ³ timeout de {timeout_duration} segundos"
        self.finish_tool(tool_name, False, error_msg)
    
    def handle_tool_not_found(self, tool_name: str, tool_path: str = ""):
        """Maneja herramienta no encontrada"""
        error_msg = f"Herramienta {tool_name} no encontrada"
        if tool_path:
            error_msg += f" en ruta: {tool_path}"
        
        # Mostrar error en CLI
        self.console.print(Panel(
            f"[bold red]âŒ Error: {error_msg}[/]\n\n"
            f"[yellow]Soluciones:[/]\n"
            f"â€¢ Verificar instalaciÃ³n: [cyan]which {tool_name}[/]\n"
            f"â€¢ Instalar herramienta desde el menÃº principal (opciÃ³n 6)\n"
            f"â€¢ Configurar ruta en ~/.aegis/config.yaml",
            title=f"Herramienta No Encontrada: {tool_name}",
            border_style="red"
        ))
    
    def get_tool_status(self, tool_name: str) -> Optional[Dict]:
        """Obtiene el estado actual de una herramienta"""
        with self._lock:
            return self.active_tools.get(tool_name)
    
    def get_log_file_path(self) -> Path:
        """Obtiene la ruta del archivo de log actual"""
        if not self._log_file_initialized:
            # Si no se ha inicializado, devolver una ruta temporal para mostrar
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            return self.logs_dir / f"aegis_analysis_{timestamp}.txt"
        return self.log_file
    
    def cleanup(self):
        """Limpia recursos"""
        self.stop_live_display()
        
        # Escribir footer solo si el archivo fue inicializado
        if self._log_file_initialized and self.log_file:
            footer = f"""
{'='*80}
FIN DEL ANÃLISIS
{'='*80}
Fecha/Hora fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total de herramientas ejecutadas: {len(self.active_tools)}
Archivo de log: {self.log_file.name}
{'='*80}
"""
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(footer)

    def _ensure_log_file_initialized(self):
        """Asegura que el archivo de log estÃ© inicializado cuando se necesite por primera vez"""
        if not self._log_file_initialized:
            # Crear el archivo de log solo cuando realmente se vaya a usar
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.log_file = self.logs_dir / f"aegis_analysis_{timestamp}.txt"
            
            # Escribir header del archivo
            self._write_log_header()
            self._log_file_initialized = True


# Singleton para el logger global
_global_logger: Optional[ToolLogger] = None

def get_logger(console: Optional[Console] = None) -> ToolLogger:
    """Obtiene la instancia global del logger"""
    global _global_logger
    if _global_logger is None:
        if console is None:
            console = Console()
        _global_logger = ToolLogger(console)
    return _global_logger

def cleanup_logger():
    """Limpia la instancia global del logger"""
    global _global_logger
    if _global_logger:
        _global_logger.cleanup()
        _global_logger = None 