"""
Sistema de logging avanzado para Aegis Pentest
Maneja logs unificados con display en tiempo real en CLI
"""
import logging
import threading
import time
import re
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box


class ToolLogger:
    """Logger especializado para herramientas de pentesting"""
    
    def __init__(self, console: Console, logs_dir: str = None):
        self.console = console
        
        # Si no se especifica logs_dir, usar el directorio logs en la ra√≠z del repo
        if logs_dir is None:
            # Obtener la ruta del directorio ra√≠z del repositorio
            current_file = Path(__file__)
            repo_root = current_file.parent.parent.parent  # aegis_pentest/utils/logger.py -> Aegis/
            logs_dir = repo_root / "logs"
        
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        
        # Archivo de log unificado con timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_file = self.logs_dir / f"aegis_analysis_{timestamp}.txt"
        
        # Estado de herramientas activas
        self.active_tools: Dict[str, Dict] = {}
        self.tool_outputs: Dict[str, List[str]] = {}
        self.tool_errors: Dict[str, List[str]] = {}
        
        # Live display para CLI
        self.live_display: Optional[Live] = None
        self.display_table = Table(box=box.ROUNDED)
        self._setup_display_table()
        
        # Setup logging solo para consola/debugging interno
        self._setup_logging()
        
        # Lock para thread safety
        self._lock = threading.Lock()
        
        # Escribir header del archivo
        self._write_log_header()
    
    def _setup_logging(self):
        """Configura el sistema de logging solo para consola/debugging interno"""
        # Logger principal solo para debugging interno, no para archivo
        self.logger = logging.getLogger("aegis_tools")
        self.logger.setLevel(logging.DEBUG)
        
        # Solo mantener el logger para debugging interno, no escribir al archivo de log principal
        # El archivo se manejar√° manualmente con los res√∫menes limpios
    
    def _write_log_header(self):
        """Escribe el header del archivo de log"""
        header = f"""
AEGIS PENTEST AUTOMATION - AN√ÅLISIS LOG
Fecha/Hora inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Archivo de log: {self.log_file.name}
{'='*80}

"""
        with open(self.log_file, 'w', encoding='utf-8') as f:
            f.write(header)
    
    def _setup_display_table(self):
        """Configura la tabla de display en vivo"""
        self.display_table.add_column("Herramienta", style="cyan", width=12)
        self.display_table.add_column("Estado", style="bold", width=10)
        self.display_table.add_column("Progreso", width=20)
        self.display_table.add_column("√öltima Actividad", style="dim", width=30)
    
    def start_live_display(self):
        """Inicia el display en vivo"""
        if self.live_display is None:
            self.live_display = Live(
                self._generate_display(),
                console=self.console,
                refresh_per_second=2,
                vertical_overflow="ellipsis"
            )
            self.live_display.start()
    
    def stop_live_display(self):
        """Detiene el display en vivo"""
        if self.live_display:
            self.live_display.stop()
            self.live_display = None
    
    def _generate_display(self):
        """Genera el contenido del display en vivo"""
        # Crear nueva tabla
        table = Table(box=box.ROUNDED, title="üîç Monitoreo de Herramientas en Tiempo Real")
        table.add_column("Herramienta", style="cyan", width=12)
        table.add_column("Estado", style="bold", width=12)
        table.add_column("Progreso", width=25)
        table.add_column("√öltima Actividad", style="dim", width=35)
        
        with self._lock:
            for tool_name, info in self.active_tools.items():
                status_style = self._get_status_style(info['status'])
                progress_bar = self._create_progress_bar(info.get('progress', 0))
                
                table.add_row(
                    tool_name,
                    Text(info['status'], style=status_style),
                    progress_bar,
                    info.get('last_activity', 'Iniciando...')[:35]
                )
        
        if not self.active_tools:
            table.add_row("---", "Inactivo", "---", "No hay herramientas ejecut√°ndose")
        
        return Panel(table, border_style="blue")
    
    def _get_status_style(self, status: str) -> str:
        """Obtiene el estilo para el estado"""
        styles = {
            'EJECUTANDO': 'green',
            'COMPLETADO': 'bold green',
            'ERROR': 'bold red',
            'TIMEOUT': 'bold yellow',
            'INICIANDO': 'blue',
            'DETENIDO': 'red'
        }
        return styles.get(status, 'white')
    
    def _create_progress_bar(self, progress: int) -> str:
        """Crea una barra de progreso simple"""
        filled = int(progress / 10)
        empty = 10 - filled
        return f"[{'‚ñà' * filled}{'‚ñë' * empty}] {progress}%"
    
    def start_tool(self, tool_name: str, command: str, target: str = "") -> str:
        """Inicia el logging para una herramienta"""
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'command': command,
                'target': target,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}..."
            }
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
        
        # Solo logging interno, no escribir al archivo
        return tool_id
    
    def log_tool_output(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta"""
        with self._lock:
            # Inicializar estructuras si no existen
            if tool_name not in self.tool_outputs:
                self.tool_outputs[tool_name] = []
            if tool_name not in self.tool_errors:
                self.tool_errors[tool_name] = []
            
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'EJECUTANDO'
                self.active_tools[tool_name]['last_activity'] = output[:50] + "..." if len(output) > 50 else output
            
            # Limpiar el output de timestamps redundantes si es necesario
            clean_output = self._clean_output_timestamps(output)
            
            # Almacenar el output limpio para el resumen final
            if is_error:
                self.tool_errors[tool_name].append(clean_output)
            else:
                self.tool_outputs[tool_name].append(clean_output)
        
        # Mostrar en CLI si no est√° en live mode
        if not self.live_display:
            style = "red" if is_error else "green"
            self.console.print(f"[{style}]{tool_name}:[/] {clean_output}")
    
    def _clean_output_timestamps(self, output: str) -> str:
        """Limpia timestamps redundantes del output de herramientas"""
        # Eliminar timestamps en formato [HH:MM:SS] del principio de la l√≠nea
        output = re.sub(r'^\[\d{2}:\d{2}:\d{2}\]\s*', '', output)
        
        # Tambi√©n limpiar timestamps en formato m√°s largo si existen
        output = re.sub(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*[\|\-]*\s*', '', output)
        
        return output.strip()
    
    def update_tool_progress(self, tool_name: str, progress: int, activity: str = ""):
        """Actualiza el progreso de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['progress'] = min(100, max(0, progress))
                if activity:
                    self.active_tools[tool_name]['last_activity'] = activity
        
        # Solo actualizar display en vivo, no escribir al archivo
    
    def finish_tool(self, tool_name: str, success: bool = True, error_msg: str = ""):
        """Finaliza el logging de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                tool_info = self.active_tools[tool_name]
                end_time = datetime.now()
                duration = end_time - tool_info['start_time']
                
                status = 'COMPLETADO' if success else 'ERROR'
                tool_info['status'] = status
                tool_info['progress'] = 100 if success else tool_info.get('progress', 0)
                tool_info['end_time'] = end_time
                tool_info['duration'] = duration
                
                if error_msg:
                    tool_info['last_activity'] = f"Error: {error_msg[:30]}..."
                    # Agregar el error a la lista de errores
                    if tool_name not in self.tool_errors:
                        self.tool_errors[tool_name] = []
                    self.tool_errors[tool_name].append(error_msg)
                else:
                    tool_info['last_activity'] = "Completado exitosamente"
                
                # Escribir resumen limpio al archivo
                self._write_tool_summary(tool_name, tool_info)
    
    def _write_tool_summary(self, tool_name: str, tool_info: Dict):
        """Escribe un resumen limpio de la herramienta al archivo"""
        # Formatear duraci√≥n
        duration = tool_info.get('duration', 'N/A')
        if duration != 'N/A':
            total_seconds = int(duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "N/A"
        
        # Formatear las fechas
        start_time_str = tool_info['start_time'].strftime('%Y-%m-%d %H:%M:%S')
        end_time = tool_info.get('end_time', 'N/A')
        end_time_str = end_time.strftime('%Y-%m-%d %H:%M:%S') if end_time != 'N/A' else 'N/A'
        
        summary = f"""
{'='*60}
{tool_name.upper()}
{'='*60}
Target: {tool_info.get('target', 'N/A')}
Inicio: {start_time_str}
Fin: {end_time_str}
Duraci√≥n: {duration_str}

OUTPUTS ({len(self.tool_outputs.get(tool_name, []))} l√≠neas):
{chr(10).join(self.tool_outputs.get(tool_name, []))}

ERRORES ({len(self.tool_errors.get(tool_name, []))} l√≠neas):
{chr(10).join(self.tool_errors.get(tool_name, []))}

{'='*60}

"""
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(summary)
    
    def handle_tool_timeout(self, tool_name: str, timeout_duration: int):
        """Maneja timeout de herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'TIMEOUT'
                self.active_tools[tool_name]['last_activity'] = f"Timeout despu√©s de {timeout_duration}s"
        
        error_msg = f"Herramienta {tool_name} excedi√≥ timeout de {timeout_duration} segundos"
        self.finish_tool(tool_name, False, error_msg)
    
    def handle_tool_not_found(self, tool_name: str, tool_path: str = ""):
        """Maneja herramienta no encontrada"""
        error_msg = f"Herramienta {tool_name} no encontrada"
        if tool_path:
            error_msg += f" en ruta: {tool_path}"
        
        # Mostrar error en CLI
        self.console.print(Panel(
            f"[bold red]‚ùå Error: {error_msg}[/]\n\n"
            f"[yellow]Soluciones:[/]\n"
            f"‚Ä¢ Verificar instalaci√≥n: [cyan]which {tool_name}[/]\n"
            f"‚Ä¢ Instalar herramienta desde el men√∫ principal (opci√≥n 6)\n"
            f"‚Ä¢ Configurar ruta en ~/.aegis/config.yaml",
            title=f"Herramienta No Encontrada: {tool_name}",
            border_style="red"
        ))
    
    def get_tool_status(self, tool_name: str) -> Optional[Dict]:
        """Obtiene el estado actual de una herramienta"""
        with self._lock:
            return self.active_tools.get(tool_name)
    
    def get_log_file_path(self) -> Path:
        """Obtiene la ruta del archivo de log actual"""
        return self.log_file
    
    def cleanup(self):
        """Limpia recursos"""
        self.stop_live_display()
        
        # Escribir footer
        footer = f"""
{'='*80}
FIN DEL AN√ÅLISIS
{'='*80}
Fecha/Hora fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total de herramientas ejecutadas: {len(self.active_tools)}
Archivo de log: {self.log_file.name}
{'='*80}
"""
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(footer)


# Singleton para el logger global
_global_logger: Optional[ToolLogger] = None

def get_logger(console: Optional[Console] = None) -> ToolLogger:
    """Obtiene la instancia global del logger"""
    global _global_logger
    if _global_logger is None:
        if console is None:
            console = Console()
        _global_logger = ToolLogger(console)
    return _global_logger

def cleanup_logger():
    """Limpia la instancia global del logger"""
    global _global_logger
    if _global_logger:
        _global_logger.cleanup()
        _global_logger = None 