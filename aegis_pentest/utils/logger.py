"""
Sistema de logging avanzado para Aegis Pentest
Maneja logs unificados con display en tiempo real en CLI
"""
import logging
import threading
import time
import re
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box


class ToolLogger:
    """Logger especializado para herramientas de pentesting"""
    
    def __init__(self, console: Console, logs_dir: str = None):
        self.console = console
        
        # Si no se especifica logs_dir, usar el directorio logs en la raíz del repo
        if logs_dir is None:
            # Obtener la ruta del directorio raíz del repositorio
            current_file = Path(__file__)
            repo_root = current_file.parent.parent.parent  # aegis_pentest/utils/logger.py -> Aegis/
            logs_dir = repo_root / "logs"
        
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        
        # Archivos de log individuales por herramienta
        self.tool_log_files: Dict[str, Path] = {}
        
        # Estado de herramientas activas
        self.active_tools: Dict[str, Dict] = {}
        self.tool_outputs: Dict[str, List[str]] = {}
        self.tool_errors: Dict[str, List[str]] = {}
        
        # Live display para CLI
        self.live_display: Optional[Live] = None
        self.display_table = Table(box=box.ROUNDED)
        self._setup_display_table()
        
        # Setup logging solo para consola/debugging interno
        self._setup_logging()
        
        # Lock para thread safety
        self._lock = threading.Lock()
    
    def _setup_logging(self):
        """Configura el sistema de logging solo para consola/debugging interno"""
        # Logger principal solo para debugging interno, no para archivo
        self.logger = logging.getLogger("aegis_tools")
        self.logger.setLevel(logging.DEBUG)
        
        # Solo mantener el logger para debugging interno, no escribir al archivo de log principal
        # El archivo se manejará manualmente con los resúmenes limpios
    
    def _setup_display_table(self):
        """Configura la tabla de display en vivo"""
        self.display_table.add_column("Herramienta", style="cyan", width=12)
        self.display_table.add_column("Estado", style="bold", width=10)
        self.display_table.add_column("Progreso", width=20)
        self.display_table.add_column("Última Actividad", style="dim", width=30)
    
    def start_live_display(self):
        """Inicia el display en vivo"""
        if self.live_display is None:
            self.live_display = Live(
                self._generate_display(),
                console=self.console,
                refresh_per_second=2,
                vertical_overflow="ellipsis"
            )
            self.live_display.start()
    
    def stop_live_display(self):
        """Detiene el display en vivo"""
        if self.live_display:
            self.live_display.stop()
            self.live_display = None
    
    def _generate_display(self):
        """Genera el contenido del display en vivo"""
        # Crear nueva tabla
        table = Table(box=box.ROUNDED, title="🔍 Monitoreo de Herramientas en Tiempo Real")
        table.add_column("Herramienta", style="cyan", width=12)
        table.add_column("Estado", style="bold", width=12)
        table.add_column("Progreso", width=25)
        table.add_column("Última Actividad", style="dim", width=35)
        
        with self._lock:
            for tool_name, info in self.active_tools.items():
                status_style = self._get_status_style(info['status'])
                progress_bar = self._create_progress_bar(info.get('progress', 0))
                
                table.add_row(
                    tool_name,
                    Text(info['status'], style=status_style),
                    progress_bar,
                    info.get('last_activity', 'Iniciando...')[:35]
                )
        
        if not self.active_tools:
            table.add_row("---", "Inactivo", "---", "No hay herramientas ejecutándose")
        
        return Panel(table, border_style="blue")
    
    def _get_status_style(self, status: str) -> str:
        """Obtiene el estilo para el estado"""
        styles = {
            'EJECUTANDO': 'green',
            'COMPLETADO': 'bold green',
            'ERROR': 'bold red',
            'TIMEOUT': 'bold yellow',
            'INICIANDO': 'blue',
            'DETENIDO': 'red'
        }
        return styles.get(status, 'white')
    
    def _create_progress_bar(self, progress: int) -> str:
        """Crea una barra de progreso simple"""
        filled = int(progress / 10)
        empty = 10 - filled
        return f"[{'█' * filled}{'░' * empty}] {progress}%"
    
    def _create_tool_log_file(self, tool_name: str, target: str = "", characteristics: Dict[str, str] = None) -> Path:
        """Crea un archivo de log individual para una herramienta"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_filename = f"{tool_name}_{timestamp}.txt"
        tool_log_file = self.logs_dir / log_filename
        
        # Información de características del análisis
        if characteristics is None:
            characteristics = {}
        
        # Header simplificado del log
        header = f"""AEGIS PENTEST - {tool_name.upper()} LOG
Herramienta: {tool_name.upper()}
Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Target: {target if target else 'No especificado'}
Archivo: {log_filename}

CARACTERÍSTICAS:
"""
        
        # Agregar características específicas
        for key, value in characteristics.items():
            header += f"{key}: {value}\n"
        
        header += f"\nINICIO ANÁLISIS:\n\n"
        
        # Escribir header al archivo
        with open(tool_log_file, 'w', encoding='utf-8') as f:
            f.write(header)
        
        return tool_log_file
    
    def start_tool_with_individual_log(self, tool_name: str, command: str, target: str = "", characteristics: Dict[str, str] = None) -> str:
        """Inicia el logging para una herramienta con archivo individual"""
        # Crear archivo de log individual
        tool_log_file = self._create_tool_log_file(tool_name, target, characteristics)
        
        # YA NO CREAR EL ARCHIVO DE LOG UNIFICADO - solo logs individuales
        # self._ensure_log_file_initialized()  # DESHABILITADO
        
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'target': target,
                'command': command,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}...",
                'characteristics': characteristics or {}
            }
            
            # Inicializar outputs y errores para esta herramienta
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
            
            # Registrar el archivo de log individual
            self.tool_log_files[tool_name] = tool_log_file
        
        return tool_id
    
    def log_tool_output_to_individual_file(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta en su archivo individual"""
        with self._lock:
            # Verificar que existe el archivo individual
            if tool_name not in self.tool_log_files:
                return
            
            tool_log_file = self.tool_log_files[tool_name]
            
            # Escribir output puro sin decoraciones (sin timestamps para ahorrar tokens)
            if is_error:
                formatted_output = f"ERROR: {output}\n"
            else:
                formatted_output = f"{output}\n"
            
            # Escribir al archivo individual
            with open(tool_log_file, 'a', encoding='utf-8') as f:
                f.write(formatted_output)
            
            # También mantener el logging unificado existente
            self.log_tool_output(tool_name, output, is_error)
    
    def start_tool(self, tool_name: str, command: str, target: str = "") -> str:
        """Inicia el logging para una herramienta"""
        # YA NO USAR ARCHIVO DE LOG GENERAL - solo logs individuales
        # self._ensure_log_file_initialized()  # DESHABILITADO
        
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'command': command,
                'target': target,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}..."
            }
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
        
        # Solo logging interno, no escribir al archivo general
        return tool_id
    
    def log_tool_output(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta"""
        with self._lock:
            # Inicializar estructuras si no existen
            if tool_name not in self.tool_outputs:
                self.tool_outputs[tool_name] = []
            if tool_name not in self.tool_errors:
                self.tool_errors[tool_name] = []
            
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'EJECUTANDO'
                self.active_tools[tool_name]['last_activity'] = output[:50] + "..." if len(output) > 50 else output
            
            # Limpiar el output de timestamps redundantes si es necesario
            clean_output = self._clean_output_timestamps(output)
            
            # Para Nuclei, NO formatear nada - usar output tal como viene
            if tool_name.lower() == 'nuclei':
                output_for_file = clean_output  # Raw output, sin filtros ni formateo
            elif tool_name.lower() == 'nikto' and not is_error:
                # Formatear y filtrar output de Nikto
                filtered_output = self._format_nikto_output(clean_output)
                if filtered_output:  # Solo guardar en archivo si es un hallazgo real
                    output_for_file = filtered_output
                else:
                    output_for_file = None  # Filtrado, no guardar en archivo
            else:
                output_for_file = clean_output
            
            # Almacenar el output (para Nuclei, almacenar TODO)
            if is_error:
                self.tool_errors[tool_name].append(clean_output)
            else:
                if tool_name.lower() == 'nuclei':
                    # Para Nuclei, guardar TODO el output sin filtrar
                    self.tool_outputs[tool_name].append(clean_output)
                elif output_for_file is not None:  # Para otras herramientas, solo si no fue filtrado
                    self.tool_outputs[tool_name].append(output_for_file)
        
        # Mostrar en CLI si no está en live mode (siempre mostrar el output completo para debug)
        if not self.live_display:
            style = "red" if is_error else "green"
            self.console.print(f"[{style}]{tool_name}:[/] {clean_output}")
    
    def _clean_output_timestamps(self, output: str) -> str:
        """Limpia timestamps redundantes del output de herramientas"""
        # Eliminar timestamps en formato [HH:MM:SS] del principio de la línea
        output = re.sub(r'^\[\d{2}:\d{2}:\d{2}\]\s*', '', output)
        
        # También limpiar timestamps en formato más largo si existen
        output = re.sub(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*[\|\-]*\s*', '', output)
        
        return output.strip()
    
    def _format_nuclei_output(self, output: str) -> str:
        """NO formatear - devolver output de Nuclei tal como viene"""
        # Devolver el output exactamente como viene de Nuclei, sin filtrar ni formatear nada
        return output
    
    def _format_nikto_output(self, output: str) -> str:
        """Filtro optimizado para logs de Nikto - solo hallazgos importantes"""
        if not output.strip():
            return None
        
        # PATRONES A FILTRAR (NO guardar en archivo)
        filter_patterns = [
            r'^\s*[-=]+\s*$',                                      # Separadores
            r'^\s*[-+]\s*(Target|Start Time|End Time|SSL Info)',   # Headers de info
            r'^\s*[-+]\s*Nikto\s+v\d',                            # Versión
            r'^\s*[-+]\s*\d+\s+(host|requests|error)',            # Estadísticas
            r'^\s*V:.*\d{3}\s+for\s+(GET|POST)',                  # Verbose HTTP
            r'ERROR.*error limit.*reached',                        # Límite de errores  
            r'ERROR.*Host maximum execution time',                 # Timeout
            r'Scan terminated:',                                   # Terminación
            r'^\s*$',                                             # Vacías
            r'^\s*#',                                             # Comentarios
        ]
        
        # Si coincide con filtros, NO guardar en archivo
        for pattern in filter_patterns:
            if re.match(pattern, output, re.IGNORECASE):
                return None
        
        # PATRONES DE HALLAZGOS IMPORTANTES (SÍ guardar en archivo)
        finding_patterns = [
            # Hallazgos generales (no headers/estadísticas)
            r'^\s*\+\s*(?!Target|Server|Start|End|SSL|\d+\s+(host|requests))',
            # Vulnerabilidades específicas
            r'OSVDB|CVE|vulnerability|security|injection|xss|clickjacking|content-type',
            # Problemas de headers de seguridad
            r'X-Frame-Options|X-Content-Type-Options|access-control|banner.*changed',
            # IPs múltiples encontradas
            r'Multiple IPs found',
        ]
        
        # Si es un hallazgo importante, guardarlo con formato simple
        for pattern in finding_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                # Formato simple sin decoración excesiva para reducir tokens
                return f"[NIKTO] {output.strip()}"
        
        # Si contiene información potencialmente útil pero no crítica
        if any(keyword in output.lower() for keyword in ['directory', 'file', 'method', 'allowed', 'server']):
            return f"[NIKTO-INFO] {output.strip()}"
        
        # No es relevante, filtrar completamente
        return None
    
    def update_tool_progress(self, tool_name: str, progress: int, activity: str = ""):
        """Actualiza el progreso de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['progress'] = min(100, max(0, progress))
                if activity:
                    self.active_tools[tool_name]['last_activity'] = activity
        
        # Solo actualizar display en vivo, no escribir al archivo
    
    def finish_tool(self, tool_name: str, success: bool = True, error_msg: str = ""):
        """Finaliza el logging de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                tool_info = self.active_tools[tool_name]
                end_time = datetime.now()
                duration = end_time - tool_info['start_time']
                
                status = 'COMPLETADO' if success else 'ERROR'
                tool_info['status'] = status
                tool_info['progress'] = 100 if success else tool_info.get('progress', 0)
                tool_info['end_time'] = end_time
                tool_info['duration'] = duration
                
                if error_msg:
                    tool_info['last_activity'] = f"Error: {error_msg[:30]}..."
                    # Agregar el error a la lista de errores
                    if tool_name not in self.tool_errors:
                        self.tool_errors[tool_name] = []
                    self.tool_errors[tool_name].append(error_msg)
                else:
                    tool_info['last_activity'] = "Completado exitosamente"
                
                # Finalizar archivo individual si existe
                self._finish_individual_log(tool_name, tool_info, success, error_msg)
    
    def _finish_individual_log(self, tool_name: str, tool_info: Dict, success: bool, error_msg: str = ""):
        """Finaliza el archivo de log individual de una herramienta"""
        if tool_name not in self.tool_log_files:
            return
        
        tool_log_file = self.tool_log_files[tool_name]
        
        # Formatear duración
        duration = tool_info.get('duration')
        if duration:
            total_seconds = int(duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "N/A"
        
        # Footer simplificado del log individual
        footer = f"""
FIN ANÁLISIS - {tool_name.upper()}
Estado: {'EXITOSO' if success else 'ERROR'}
Inicio: {tool_info['start_time'].strftime('%Y-%m-%d %H:%M:%S')}
Fin: {tool_info.get('end_time', datetime.now()).strftime('%Y-%m-%d %H:%M:%S')}
Duración: {duration_str}
Target: {tool_info.get('target', 'No especificado')}
"""
        
        if error_msg:
            footer += f"Error: {error_msg}\n"
        
        footer += f"Outputs: {len(self.tool_outputs.get(tool_name, []))}\n"
        footer += f"Errores: {len(self.tool_errors.get(tool_name, []))}\n"
        
        # Escribir footer al archivo individual
        with open(tool_log_file, 'a', encoding='utf-8') as f:
            f.write(footer)
    
    def handle_tool_timeout(self, tool_name: str, timeout_duration: int):
        """Maneja timeout de herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'TIMEOUT'
                self.active_tools[tool_name]['last_activity'] = f"Timeout después de {timeout_duration}s"
        
        error_msg = f"Herramienta {tool_name} excedió timeout de {timeout_duration} segundos"
        self.finish_tool(tool_name, False, error_msg)
    
    def handle_tool_not_found(self, tool_name: str, tool_path: str = ""):
        """Maneja herramienta no encontrada"""
        error_msg = f"Herramienta {tool_name} no encontrada"
        if tool_path:
            error_msg += f" en ruta: {tool_path}"
        
        # Mostrar error en CLI
        self.console.print(Panel(
            f"[bold red]❌ Error: {error_msg}[/]\n\n"
            f"[yellow]Soluciones:[/]\n"
            f"• Verificar instalación: [cyan]which {tool_name}[/]\n"
            f"• Instalar herramienta desde el menú principal (opción 6)\n"
            f"• Configurar ruta en ~/.aegis/config.yaml",
            title=f"Herramienta No Encontrada: {tool_name}",
            border_style="red"
        ))
    
    def get_tool_status(self, tool_name: str) -> Optional[Dict]:
        """Obtiene el estado actual de una herramienta"""
        with self._lock:
            return self.active_tools.get(tool_name)
    
    def get_log_file_path(self) -> Path:
        """Obtiene la ruta del archivo de log actual"""
        # YA NO USAR ARCHIVOS DE LOG GENERALES - solo logs individuales por herramienta
        # Devolver None o una ruta vacía para indicar que no hay log general
        return None
    
    def cleanup(self):
        """Limpia recursos"""
        self.stop_live_display()
    
    def get_tool_individual_log_path(self, tool_name: str) -> Optional[Path]:
        """Obtiene la ruta del archivo de log individual de una herramienta"""
        return self.tool_log_files.get(tool_name)


# Singleton para el logger global
_global_logger: Optional[ToolLogger] = None

def get_logger(console: Optional[Console] = None) -> ToolLogger:
    """Obtiene la instancia global del logger"""
    global _global_logger
    if _global_logger is None:
        if console is None:
            console = Console()
        _global_logger = ToolLogger(console)
    return _global_logger

def cleanup_logger():
    """Limpia la instancia global del logger"""
    global _global_logger
    if _global_logger:
        _global_logger.cleanup()
        _global_logger = None 