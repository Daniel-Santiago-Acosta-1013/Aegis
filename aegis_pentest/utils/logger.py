"""
Sistema de logging avanzado para Aegis Pentest
Maneja logs unificados con display en tiempo real en CLI
"""
import logging
import threading
import time
import re
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.live import Live
from rich.table import Table
from rich import box


class ToolLogger:
    """Logger especializado para herramientas de pentesting"""
    
    def __init__(self, console: Console, logs_dir: str = None):
        self.console = console
        
        # Si no se especifica logs_dir, usar el directorio logs en la ra√≠z del repo
        if logs_dir is None:
            # Obtener la ruta del directorio ra√≠z del repositorio
            current_file = Path(__file__)
            repo_root = current_file.parent.parent.parent  # aegis_pentest/utils/logger.py -> Aegis/
            logs_dir = repo_root / "logs"
        
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        
        # NO crear el archivo de log inmediatamente - solo preparar para cuando se necesite
        self.log_file = None
        self._log_file_initialized = False
        
        # Estado de herramientas activas
        self.active_tools: Dict[str, Dict] = {}
        self.tool_outputs: Dict[str, List[str]] = {}
        self.tool_errors: Dict[str, List[str]] = {}
        
        # Live display para CLI
        self.live_display: Optional[Live] = None
        self.display_table = Table(box=box.ROUNDED)
        self._setup_display_table()
        
        # Setup logging solo para consola/debugging interno
        self._setup_logging()
        
        # Lock para thread safety
        self._lock = threading.Lock()
    
    def _setup_logging(self):
        """Configura el sistema de logging solo para consola/debugging interno"""
        # Logger principal solo para debugging interno, no para archivo
        self.logger = logging.getLogger("aegis_tools")
        self.logger.setLevel(logging.DEBUG)
        
        # Solo mantener el logger para debugging interno, no escribir al archivo de log principal
        # El archivo se manejar√° manualmente con los res√∫menes limpios
    
    def _write_log_header(self):
        """Escribe el header del archivo de log"""
        header = f"""
AEGIS PENTEST AUTOMATION - AN√ÅLISIS LOG
Fecha/Hora inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Archivo de log: {self.log_file.name}
{'='*80}

"""
        with open(self.log_file, 'w', encoding='utf-8') as f:
            f.write(header)
    
    def _setup_display_table(self):
        """Configura la tabla de display en vivo"""
        self.display_table.add_column("Herramienta", style="cyan", width=12)
        self.display_table.add_column("Estado", style="bold", width=10)
        self.display_table.add_column("Progreso", width=20)
        self.display_table.add_column("√öltima Actividad", style="dim", width=30)
    
    def start_live_display(self):
        """Inicia el display en vivo"""
        if self.live_display is None:
            self.live_display = Live(
                self._generate_display(),
                console=self.console,
                refresh_per_second=2,
                vertical_overflow="ellipsis"
            )
            self.live_display.start()
    
    def stop_live_display(self):
        """Detiene el display en vivo"""
        if self.live_display:
            self.live_display.stop()
            self.live_display = None
    
    def _generate_display(self):
        """Genera el contenido del display en vivo"""
        # Crear nueva tabla
        table = Table(box=box.ROUNDED, title="üîç Monitoreo de Herramientas en Tiempo Real")
        table.add_column("Herramienta", style="cyan", width=12)
        table.add_column("Estado", style="bold", width=12)
        table.add_column("Progreso", width=25)
        table.add_column("√öltima Actividad", style="dim", width=35)
        
        with self._lock:
            for tool_name, info in self.active_tools.items():
                status_style = self._get_status_style(info['status'])
                progress_bar = self._create_progress_bar(info.get('progress', 0))
                
                table.add_row(
                    tool_name,
                    Text(info['status'], style=status_style),
                    progress_bar,
                    info.get('last_activity', 'Iniciando...')[:35]
                )
        
        if not self.active_tools:
            table.add_row("---", "Inactivo", "---", "No hay herramientas ejecut√°ndose")
        
        return Panel(table, border_style="blue")
    
    def _get_status_style(self, status: str) -> str:
        """Obtiene el estilo para el estado"""
        styles = {
            'EJECUTANDO': 'green',
            'COMPLETADO': 'bold green',
            'ERROR': 'bold red',
            'TIMEOUT': 'bold yellow',
            'INICIANDO': 'blue',
            'DETENIDO': 'red'
        }
        return styles.get(status, 'white')
    
    def _create_progress_bar(self, progress: int) -> str:
        """Crea una barra de progreso simple"""
        filled = int(progress / 10)
        empty = 10 - filled
        return f"[{'‚ñà' * filled}{'‚ñë' * empty}] {progress}%"
    
    def start_tool(self, tool_name: str, command: str, target: str = "") -> str:
        """Inicia el logging para una herramienta"""
        # Asegurar que el archivo de log est√© inicializado cuando realmente se use por primera vez
        self._ensure_log_file_initialized()
        
        tool_id = f"{tool_name}_{int(time.time())}"
        
        with self._lock:
            self.active_tools[tool_name] = {
                'id': tool_id,
                'status': 'INICIANDO',
                'start_time': datetime.now(),
                'command': command,
                'target': target,
                'progress': 0,
                'last_activity': f"Iniciando {tool_name}..."
            }
            self.tool_outputs[tool_name] = []
            self.tool_errors[tool_name] = []
        
        # Solo logging interno, no escribir al archivo
        return tool_id
    
    def log_tool_output(self, tool_name: str, output: str, is_error: bool = False):
        """Registra output de herramienta"""
        with self._lock:
            # Inicializar estructuras si no existen
            if tool_name not in self.tool_outputs:
                self.tool_outputs[tool_name] = []
            if tool_name not in self.tool_errors:
                self.tool_errors[tool_name] = []
            
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'EJECUTANDO'
                self.active_tools[tool_name]['last_activity'] = output[:50] + "..." if len(output) > 50 else output
            
            # Limpiar el output de timestamps redundantes si es necesario
            clean_output = self._clean_output_timestamps(output)
            
            # Formatear espec√≠ficamente para Nuclei si es JSON
            if tool_name.lower() == 'nuclei' and not is_error:
                formatted_output = self._format_nuclei_output(clean_output)
                if formatted_output:
                    clean_output = formatted_output
            
            # Para Nikto, filtrar qu√© se guarda en archivo vs lo que se muestra en consola
            output_for_file = clean_output
            if tool_name.lower() == 'nikto' and not is_error:
                # Filtrar para archivo: solo hallazgos reales
                filtered_output = self._format_nikto_output(clean_output)
                if filtered_output:  # Solo guardar en archivo si es un hallazgo real
                    output_for_file = filtered_output
                else:
                    output_for_file = None  # No guardar en archivo
            
            # Almacenar el output filtrado para el resumen final (solo hallazgos)
            if is_error:
                self.tool_errors[tool_name].append(clean_output)
            else:
                if output_for_file:  # Solo agregar si hay contenido v√°lido
                    self.tool_outputs[tool_name].append(output_for_file)
        
        # Mostrar en CLI si no est√° en live mode (siempre mostrar el output completo)
        if not self.live_display:
            style = "red" if is_error else "green"
            self.console.print(f"[{style}]{tool_name}:[/] {clean_output}")
    
    def _clean_output_timestamps(self, output: str) -> str:
        """Limpia timestamps redundantes del output de herramientas"""
        # Eliminar timestamps en formato [HH:MM:SS] del principio de la l√≠nea
        output = re.sub(r'^\[\d{2}:\d{2}:\d{2}\]\s*', '', output)
        
        # Tambi√©n limpiar timestamps en formato m√°s largo si existen
        output = re.sub(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s*[\|\-]*\s*', '', output)
        
        return output.strip()
    
    def _format_nuclei_output(self, output: str) -> str:
        """Formatea el output JSON de Nuclei para hacerlo m√°s legible y completo en los logs"""
        if not output.strip():
            return output
        
        try:
            # Intentar parsear como JSON
            import json
            vuln_data = json.loads(output)
            
            # Extraer informaci√≥n esencial
            template_id = vuln_data.get('template-id', 'N/A')
            template_name = vuln_data.get('template', 'N/A')
            info = vuln_data.get('info', {})
            vuln_name = info.get('name', 'N/A')
            severity = info.get('severity', 'unknown').upper()
            host = vuln_data.get('host', 'N/A')
            url = vuln_data.get('url', vuln_data.get('matched-at', 'N/A'))
            ip = vuln_data.get('ip', 'N/A')
            
            # Agregar emoji y color seg√∫n severidad
            severity_icons = {
                'CRITICAL': 'üî¥ CRITICAL',
                'HIGH': 'üü† HIGH', 
                'MEDIUM': 'üü° MEDIUM',
                'LOW': 'üîµ LOW',
                'INFO': '‚ö™ INFO'
            }
            severity_display = severity_icons.get(severity, f'‚ö´ {severity}')
            
            # Obtener tags completos
            tags = info.get('tags', [])
            tags_str = ', '.join(tags) if tags else 'N/A'
            
            # Obtener descripci√≥n COMPLETA (sin recortar)
            description = info.get('description', 'Sin descripci√≥n disponible')
            
            # Obtener autores completos
            authors = info.get('author', [])
            author_str = ', '.join(authors) if authors else 'N/A'
            
            # Informaci√≥n de clasificaci√≥n y referencias
            classification = info.get('classification', {})
            references = info.get('reference', [])
            
            # Metadata del template
            metadata = info.get('metadata', {})
            
            # Crear formato legible y completo
            formatted = f"""
‚îå‚îÄ üîç [NUCLEI FINDING] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ Template ID: {template_id}
‚îÇ Template Path: {template_name}
‚îÇ Vulnerability: {vuln_name}
‚îÇ Severity: {severity_display}
‚îÇ Authors: {author_str}
‚îÇ Target Host: {host}"""
            
            # Agregar IP si es diferente del host
            if ip != 'N/A' and ip != host:
                formatted += f"\n‚îÇ IP Address: {ip}"
            
            formatted += f"\n‚îÇ Target URL: {url}"
            formatted += f"\n‚îÇ Tags: {tags_str}"
            
            # Descripci√≥n completa sin recortes
            if description:
                # Dividir descripci√≥n en l√≠neas para mejor legibilidad
                desc_lines = description.replace('. ', '.\n').split('\n')
                formatted += f"\n‚îÇ Description:"
                for line in desc_lines:
                    line = line.strip()
                    if line:
                        formatted += f"\n‚îÇ   {line}"
            
            # Informaci√≥n de clasificaci√≥n si existe
            if classification:
                formatted += f"\n‚îÇ Classification:"
                for key, value in classification.items():
                    if value:
                        formatted += f"\n‚îÇ   {key.title()}: {value}"
            
            # CVE Information si existe
            cve_id = classification.get('cve-id') or info.get('cve')
            if cve_id:
                formatted += f"\n‚îÇ CVE ID: {cve_id}"
            
            # CVSS Information si existe
            cvss_metrics = classification.get('cvss-metrics')
            cvss_score = classification.get('cvss-score')
            if cvss_score:
                formatted += f"\n‚îÇ CVSS Score: {cvss_score}"
            if cvss_metrics:
                formatted += f"\n‚îÇ CVSS Metrics: {cvss_metrics}"
            
            # CWE Information si existe
            cwe_id = classification.get('cwe-id')
            if cwe_id:
                formatted += f"\n‚îÇ CWE ID: {cwe_id}"
            
            # Referencias si existen
            if references:
                formatted += f"\n‚îÇ References:"
                for ref in references[:5]:  # Mostrar hasta 5 referencias
                    formatted += f"\n‚îÇ   ‚Ä¢ {ref}"
                if len(references) > 5:
                    formatted += f"\n‚îÇ   ‚Ä¢ ... y {len(references) - 5} referencias m√°s"
            
            # Metadata adicional √∫til
            if metadata:
                useful_metadata = {}
                for key, value in metadata.items():
                    if key in ['max-request', 'shodan-query', 'product', 'vendor', 'verified']:
                        useful_metadata[key] = value
                
                if useful_metadata:
                    formatted += f"\n‚îÇ Metadata:"
                    for key, value in useful_metadata.items():
                        formatted += f"\n‚îÇ   {key.replace('-', ' ').title()}: {value}"
            
            # Informaci√≥n extractada si existe
            extracted_results = vuln_data.get('extracted-results', [])
            if extracted_results:
                formatted += f"\n‚îÇ Extracted Data:"
                for i, result in enumerate(extracted_results[:10]):  # Mostrar hasta 10 resultados
                    formatted += f"\n‚îÇ   ‚Ä¢ {str(result)}"
                if len(extracted_results) > 10:
                    formatted += f"\n‚îÇ   ‚Ä¢ ... y {len(extracted_results) - 10} resultados m√°s"
            
            # Informaci√≥n del request/response para an√°lisis profundo
            request = vuln_data.get('request', '')
            response = vuln_data.get('response', '')
            
            if request:
                formatted += f"\n‚îÇ HTTP Request Analysis:"
                request_lines = request.split('\n')
                method_line = request_lines[0] if request_lines else ''
                formatted += f"\n‚îÇ   Method & Path: {method_line.strip()}"
                
                # Extraer headers importantes del request
                important_req_headers = ['User-Agent', 'Content-Type', 'Authorization', 'Cookie', 'X-Forwarded-For']
                for line in request_lines[1:]:
                    for header in important_req_headers:
                        if line.strip().lower().startswith(f'{header.lower()}:'):
                            header_value = line.split(':', 1)[1].strip()
                            if len(header_value) > 80:
                                header_value = header_value[:77] + "..."
                            formatted += f"\n‚îÇ   {header}: {header_value}"
                            break
            
            if response:
                formatted += f"\n‚îÇ HTTP Response Analysis:"
                response_lines = response.split('\n')
                
                # Status line
                status_line = next((line for line in response_lines if line.startswith('HTTP/')), '')
                if status_line:
                    formatted += f"\n‚îÇ   Status: {status_line.strip()}"
                
                # Headers importantes de respuesta
                important_resp_headers = ['Server', 'X-Powered-By', 'Location', 'Set-Cookie', 'Content-Type', 'X-Frame-Options', 'X-XSS-Protection']
                for line in response_lines:
                    for header in important_resp_headers:
                        if line.strip().lower().startswith(f'{header.lower()}:'):
                            header_value = line.split(':', 1)[1].strip()
                            if len(header_value) > 80:
                                header_value = header_value[:77] + "..."
                            formatted += f"\n‚îÇ   {header}: {header_value}"
                            break
                
                # Content length si existe
                content_length = next((line for line in response_lines if line.lower().startswith('content-length:')), '')
                if content_length:
                    length = content_length.split(':', 1)[1].strip()
                    formatted += f"\n‚îÇ   Content-Length: {length} bytes"
            
            # Informaci√≥n del tipo de matcher que detect√≥ la vulnerabilidad
            matcher_status = vuln_data.get('matcher-status')
            if matcher_status:
                formatted += f"\n‚îÇ Detection Method: Pattern Match Successful"
            
            # Informaci√≥n del protocolo/tipo
            protocol_type = vuln_data.get('type', 'unknown')
            if protocol_type != 'unknown':
                formatted += f"\n‚îÇ Protocol Type: {protocol_type.upper()}"
            
            # Puerto si est√° disponible
            port = vuln_data.get('port')
            if port:
                formatted += f"\n‚îÇ Port: {port}"
            
            # Scheme (http/https)
            scheme = vuln_data.get('scheme')
            if scheme:
                formatted += f"\n‚îÇ Scheme: {scheme.upper()}"
            
            # Curl command si est√° disponible (√∫til para reproducir)
            curl_command = vuln_data.get('curl-command')
            if curl_command and len(curl_command) < 200:
                formatted += f"\n‚îÇ Reproduction:"
                formatted += f"\n‚îÇ   {curl_command}"
            
            formatted += "\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            
            return formatted
            
        except (json.JSONDecodeError, KeyError, ValueError) as e:
            # Si no es JSON v√°lido o falta informaci√≥n, devolver el output original
            # Pero si parece ser JSON pero con error, intentar parsear parcialmente
            if output.strip().startswith('{') and output.strip().endswith('}'):
                return f"[NUCLEI] Raw JSON (parse error): {output[:300]}..."
            return output
    
    def _format_nikto_output(self, output: str) -> str:
        """Filtro optimizado para logs de Nikto - solo hallazgos importantes"""
        if not output.strip():
            return None
        
        # PATRONES A FILTRAR (NO guardar en archivo)
        filter_patterns = [
            r'^\s*[-=]+\s*$',                                      # Separadores
            r'^\s*[-+]\s*(Target|Start Time|End Time|SSL Info)',   # Headers de info
            r'^\s*[-+]\s*Nikto\s+v\d',                            # Versi√≥n
            r'^\s*[-+]\s*\d+\s+(host|requests|error)',            # Estad√≠sticas
            r'^\s*V:.*\d{3}\s+for\s+(GET|POST)',                  # Verbose HTTP
            r'ERROR.*error limit.*reached',                        # L√≠mite de errores  
            r'ERROR.*Host maximum execution time',                 # Timeout
            r'Scan terminated:',                                   # Terminaci√≥n
            r'^\s*$',                                             # Vac√≠as
            r'^\s*#',                                             # Comentarios
        ]
        
        # Si coincide con filtros, NO guardar en archivo
        for pattern in filter_patterns:
            if re.match(pattern, output, re.IGNORECASE):
                return None
        
        # PATRONES DE HALLAZGOS IMPORTANTES (S√ç guardar en archivo)
        finding_patterns = [
            # Hallazgos generales (no headers/estad√≠sticas)
            r'^\s*\+\s*(?!Target|Server|Start|End|SSL|\d+\s+(host|requests))',
            # Vulnerabilidades espec√≠ficas
            r'OSVDB|CVE|vulnerability|security|injection|xss|clickjacking|content-type',
            # Problemas de headers de seguridad
            r'X-Frame-Options|X-Content-Type-Options|access-control|banner.*changed',
            # IPs m√∫ltiples encontradas
            r'Multiple IPs found',
        ]
        
        # Si es un hallazgo importante, guardarlo con formato simple
        for pattern in finding_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                # Formato simple sin decoraci√≥n excesiva para reducir tokens
                return f"[NIKTO] {output.strip()}"
        
        # Si contiene informaci√≥n potencialmente √∫til pero no cr√≠tica
        if any(keyword in output.lower() for keyword in ['directory', 'file', 'method', 'allowed', 'server']):
            return f"[NIKTO-INFO] {output.strip()}"
        
        # No es relevante, filtrar completamente
        return None
    
    def update_tool_progress(self, tool_name: str, progress: int, activity: str = ""):
        """Actualiza el progreso de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['progress'] = min(100, max(0, progress))
                if activity:
                    self.active_tools[tool_name]['last_activity'] = activity
        
        # Solo actualizar display en vivo, no escribir al archivo
    
    def finish_tool(self, tool_name: str, success: bool = True, error_msg: str = ""):
        """Finaliza el logging de una herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                tool_info = self.active_tools[tool_name]
                end_time = datetime.now()
                duration = end_time - tool_info['start_time']
                
                status = 'COMPLETADO' if success else 'ERROR'
                tool_info['status'] = status
                tool_info['progress'] = 100 if success else tool_info.get('progress', 0)
                tool_info['end_time'] = end_time
                tool_info['duration'] = duration
                
                if error_msg:
                    tool_info['last_activity'] = f"Error: {error_msg[:30]}..."
                    # Agregar el error a la lista de errores
                    if tool_name not in self.tool_errors:
                        self.tool_errors[tool_name] = []
                    self.tool_errors[tool_name].append(error_msg)
                else:
                    tool_info['last_activity'] = "Completado exitosamente"
                
                # Escribir resumen limpio al archivo
                self._write_tool_summary(tool_name, tool_info)
    
    def _write_tool_summary(self, tool_name: str, tool_info: Dict):
        """Escribe un resumen limpio de la herramienta al archivo"""
        # Asegurar que el archivo de log est√© inicializado
        self._ensure_log_file_initialized()
        
        # Formatear duraci√≥n
        duration = tool_info.get('duration', 'N/A')
        if duration != 'N/A':
            total_seconds = int(duration.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "N/A"
        
        # Formatear las fechas
        start_time_str = tool_info['start_time'].strftime('%Y-%m-%d %H:%M:%S')
        end_time = tool_info.get('end_time', 'N/A')
        end_time_str = end_time.strftime('%Y-%m-%d %H:%M:%S') if end_time != 'N/A' else 'N/A'
        
        # Resumen est√°ndar para todas las herramientas (incluyendo Nuclei)
        summary = f"""
{'='*60}
{tool_name.upper()}
{'='*60}
Target: {tool_info.get('target', 'N/A')}
Inicio: {start_time_str}
Fin: {end_time_str}
Duraci√≥n: {duration_str}

OUTPUTS ({len(self.tool_outputs.get(tool_name, []))} l√≠neas):
{chr(10).join(self.tool_outputs.get(tool_name, []))}

ERRORES ({len(self.tool_errors.get(tool_name, []))} l√≠neas):
{chr(10).join(self.tool_errors.get(tool_name, []))}

{'='*60}

"""
        
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(summary)
    
    def handle_tool_timeout(self, tool_name: str, timeout_duration: int):
        """Maneja timeout de herramienta"""
        with self._lock:
            if tool_name in self.active_tools:
                self.active_tools[tool_name]['status'] = 'TIMEOUT'
                self.active_tools[tool_name]['last_activity'] = f"Timeout despu√©s de {timeout_duration}s"
        
        error_msg = f"Herramienta {tool_name} excedi√≥ timeout de {timeout_duration} segundos"
        self.finish_tool(tool_name, False, error_msg)
    
    def handle_tool_not_found(self, tool_name: str, tool_path: str = ""):
        """Maneja herramienta no encontrada"""
        error_msg = f"Herramienta {tool_name} no encontrada"
        if tool_path:
            error_msg += f" en ruta: {tool_path}"
        
        # Mostrar error en CLI
        self.console.print(Panel(
            f"[bold red]‚ùå Error: {error_msg}[/]\n\n"
            f"[yellow]Soluciones:[/]\n"
            f"‚Ä¢ Verificar instalaci√≥n: [cyan]which {tool_name}[/]\n"
            f"‚Ä¢ Instalar herramienta desde el men√∫ principal (opci√≥n 6)\n"
            f"‚Ä¢ Configurar ruta en ~/.aegis/config.yaml",
            title=f"Herramienta No Encontrada: {tool_name}",
            border_style="red"
        ))
    
    def get_tool_status(self, tool_name: str) -> Optional[Dict]:
        """Obtiene el estado actual de una herramienta"""
        with self._lock:
            return self.active_tools.get(tool_name)
    
    def get_log_file_path(self) -> Path:
        """Obtiene la ruta del archivo de log actual"""
        if not self._log_file_initialized:
            # Si no se ha inicializado, devolver una ruta temporal para mostrar
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            return self.logs_dir / f"aegis_analysis_{timestamp}.txt"
        return self.log_file
    
    def cleanup(self):
        """Limpia recursos"""
        self.stop_live_display()
        
        # Escribir footer solo si el archivo fue inicializado
        if self._log_file_initialized and self.log_file:
            footer = f"""
{'='*80}
FIN DEL AN√ÅLISIS
{'='*80}
Fecha/Hora fin: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total de herramientas ejecutadas: {len(self.active_tools)}
Archivo de log: {self.log_file.name}
{'='*80}
"""
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(footer)

    def _ensure_log_file_initialized(self):
        """Asegura que el archivo de log est√© inicializado cuando se necesite por primera vez"""
        if not self._log_file_initialized:
            # Crear el archivo de log solo cuando realmente se vaya a usar
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.log_file = self.logs_dir / f"aegis_analysis_{timestamp}.txt"
            
            # Escribir header del archivo
            self._write_log_header()
            self._log_file_initialized = True


# Singleton para el logger global
_global_logger: Optional[ToolLogger] = None

def get_logger(console: Optional[Console] = None) -> ToolLogger:
    """Obtiene la instancia global del logger"""
    global _global_logger
    if _global_logger is None:
        if console is None:
            console = Console()
        _global_logger = ToolLogger(console)
    return _global_logger

def cleanup_logger():
    """Limpia la instancia global del logger"""
    global _global_logger
    if _global_logger:
        _global_logger.cleanup()
        _global_logger = None 