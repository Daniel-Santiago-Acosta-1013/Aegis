"""
Gestor de proyectos para Aegis Pentest Automation
Organiza y persiste los resultados de escaneo
"""

import json
import yaml
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

from aegis_pentest.core.scanner import ScanResult
from aegis_pentest.utils.config import Config
from aegis_pentest.utils.helpers import sanitize_filename


class ProjectManager:
    """Gestor de proyectos de pentesting"""
    
    def __init__(self, config: Config):
        self.config = config
        self.projects_dir = Path.home() / ".aegis" / "projects"
        self.projects_dir.mkdir(parents=True, exist_ok=True)
        
        self.current_project: Optional[str] = None
        self.project_data: Dict[str, Any] = {}
    
    def create_project(self, name: str, description: str = "", target: str = "") -> bool:
        """
        Crea un nuevo proyecto
        
        Args:
            name: Nombre del proyecto
            description: Descripción del proyecto
            target: Objetivo principal del proyecto
            
        Returns:
            bool: True si el proyecto se creó exitosamente
        """
        safe_name = sanitize_filename(name)
        project_dir = self.projects_dir / safe_name
        
        if project_dir.exists():
            return False  # El proyecto ya existe
        
        project_dir.mkdir(parents=True)
        
        # Crear estructura de directorios
        (project_dir / "scans").mkdir()
        (project_dir / "reports").mkdir()
        (project_dir / "notes").mkdir()
        
        # Crear archivo de metadatos del proyecto
        project_metadata = {
            "name": name,
            "description": description,
            "target": target,
            "created_at": datetime.now().isoformat(),
            "last_modified": datetime.now().isoformat(),
            "scan_count": 0,
            "tags": []
        }
        
        metadata_file = project_dir / "project.yaml"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            yaml.dump(project_metadata, f, default_flow_style=False)
        
        return True
    
    def load_project(self, name: str) -> bool:
        """
        Carga un proyecto existente
        
        Args:
            name: Nombre del proyecto a cargar
            
        Returns:
            bool: True si el proyecto se cargó exitosamente
        """
        safe_name = sanitize_filename(name)
        project_dir = self.projects_dir / safe_name
        metadata_file = project_dir / "project.yaml"
        
        if not metadata_file.exists():
            return False
        
        try:
            with open(metadata_file, 'r', encoding='utf-8') as f:
                self.project_data = yaml.safe_load(f)
            
            self.current_project = safe_name
            return True
        except Exception:
            return False
    
    def save_scan_result(self, scan_result: ScanResult) -> str:
        """
        Guarda un resultado de escaneo en el proyecto actual
        
        Args:
            scan_result: Resultado del escaneo a guardar
            
        Returns:
            str: ID del escaneo guardado
        """
        if not self.current_project:
            raise ValueError("No hay proyecto cargado")
        
        project_dir = self.projects_dir / self.current_project
        scans_dir = project_dir / "scans"
        
        # Generar ID único para el escaneo
        scan_id = f"{scan_result.scan_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        scan_file = scans_dir / f"{scan_id}.json"
        
        # Convertir resultado a diccionario serializable
        scan_data = {
            "id": scan_id,
            "target": scan_result.target,
            "scan_type": scan_result.scan_type,
            "start_time": scan_result.start_time.isoformat(),
            "end_time": scan_result.end_time.isoformat() if scan_result.end_time else None,
            "status": scan_result.status,
            "duration": scan_result.duration,
            "metadata": scan_result.metadata,
            "errors": scan_result.errors,
            "nmap_results": self._serialize_nmap_results(scan_result.nmap_results),
            "nuclei_results": scan_result.nuclei_results,
            "gobuster_results": scan_result.gobuster_results,
            "nikto_results": scan_result.nikto_results,
            "sqlmap_results": scan_result.sqlmap_results
        }
        
        # Guardar en archivo JSON
        with open(scan_file, 'w', encoding='utf-8') as f:
            json.dump(scan_data, f, indent=2, ensure_ascii=False)
        
        # Actualizar metadatos del proyecto
        self._update_project_metadata()
        
        return scan_id
    
    def get_scan_history(self) -> List[Dict[str, Any]]:
        """
        Obtiene el historial de escaneos del proyecto actual
        
        Returns:
            List[Dict]: Lista de escaneos realizados
        """
        if not self.current_project:
            return []
        
        project_dir = self.projects_dir / self.current_project
        scans_dir = project_dir / "scans"
        
        scans = []
        for scan_file in scans_dir.glob("*.json"):
            try:
                with open(scan_file, 'r', encoding='utf-8') as f:
                    scan_data = json.load(f)
                
                # Crear resumen del escaneo
                summary = {
                    "id": scan_data.get("id"),
                    "target": scan_data.get("target"),
                    "scan_type": scan_data.get("scan_type"),
                    "start_time": scan_data.get("start_time"),
                    "status": scan_data.get("status"),
                    "duration": scan_data.get("duration"),
                    "file": str(scan_file)
                }
                scans.append(summary)
            except Exception:
                continue
        
        # Ordenar por fecha (más reciente primero)
        scans.sort(key=lambda x: x.get("start_time", ""), reverse=True)
        return scans
    
    def load_scan_result(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """
        Carga un resultado de escaneo específico
        
        Args:
            scan_id: ID del escaneo a cargar
            
        Returns:
            Dict: Datos del escaneo o None si no se encuentra
        """
        if not self.current_project:
            return None
        
        project_dir = self.projects_dir / self.current_project
        scan_file = project_dir / "scans" / f"{scan_id}.json"
        
        if not scan_file.exists():
            return None
        
        try:
            with open(scan_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None
    
    def list_projects(self) -> List[Dict[str, Any]]:
        """
        Lista todos los proyectos disponibles
        
        Returns:
            List[Dict]: Lista de proyectos con sus metadatos
        """
        projects = []
        
        for project_dir in self.projects_dir.iterdir():
            if not project_dir.is_dir():
                continue
            
            metadata_file = project_dir / "project.yaml"
            if not metadata_file.exists():
                continue
            
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = yaml.safe_load(f)
                
                # Contar escaneos
                scans_dir = project_dir / "scans"
                scan_count = len(list(scans_dir.glob("*.json"))) if scans_dir.exists() else 0
                metadata["scan_count"] = scan_count
                metadata["folder_name"] = project_dir.name
                
                projects.append(metadata)
            except Exception:
                continue
        
        # Ordenar por fecha de modificación
        projects.sort(key=lambda x: x.get("last_modified", ""), reverse=True)
        return projects
    
    def delete_project(self, name: str) -> bool:
        """
        Elimina un proyecto y todos sus datos
        
        Args:
            name: Nombre del proyecto a eliminar
            
        Returns:
            bool: True si se eliminó exitosamente
        """
        safe_name = sanitize_filename(name)
        project_dir = self.projects_dir / safe_name
        
        if not project_dir.exists():
            return False
        
        try:
            import shutil
            shutil.rmtree(project_dir)
            
            if self.current_project == safe_name:
                self.current_project = None
                self.project_data = {}
            
            return True
        except Exception:
            return False
    
    def add_note(self, content: str, title: str = None) -> str:
        """
        Agrega una nota al proyecto actual
        
        Args:
            content: Contenido de la nota
            title: Título opcional de la nota
            
        Returns:
            str: ID de la nota creada
        """
        if not self.current_project:
            raise ValueError("No hay proyecto cargado")
        
        project_dir = self.projects_dir / self.current_project
        notes_dir = project_dir / "notes"
        
        note_id = datetime.now().strftime('%Y%m%d_%H%M%S')
        note_file = notes_dir / f"{note_id}.md"
        
        note_content = f"# {title or 'Nota'}\n\n"
        note_content += f"**Fecha:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        note_content += content
        
        with open(note_file, 'w', encoding='utf-8') as f:
            f.write(note_content)
        
        return note_id
    
    def _serialize_nmap_results(self, nmap_results) -> Optional[Dict]:
        """Serializa los resultados de Nmap para JSON"""
        if not nmap_results:
            return None
        
        return {
            "host": nmap_results.host,
            "state": nmap_results.state,
            "ports": nmap_results.ports,
            "services": nmap_results.services,
            "os_info": nmap_results.os_info,
            "script_results": nmap_results.script_results,
            "scan_stats": nmap_results.scan_stats
        }
    
    def _update_project_metadata(self):
        """Actualiza los metadatos del proyecto actual"""
        if not self.current_project:
            return
        
        project_dir = self.projects_dir / self.current_project
        metadata_file = project_dir / "project.yaml"
        
        # Actualizar timestamp y contador de escaneos
        self.project_data["last_modified"] = datetime.now().isoformat()
        
        scans_dir = project_dir / "scans"
        if scans_dir.exists():
            self.project_data["scan_count"] = len(list(scans_dir.glob("*.json")))
        
        with open(metadata_file, 'w', encoding='utf-8') as f:
            yaml.dump(self.project_data, f, default_flow_style=False)
    
    @property
    def current_project_info(self) -> Optional[Dict[str, Any]]:
        """Obtiene información del proyecto actual"""
        return self.project_data.copy() if self.current_project else None 