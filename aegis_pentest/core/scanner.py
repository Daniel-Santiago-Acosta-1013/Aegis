"""
Motor principal de escaneo de Aegis Pentest Automation
Coordina la ejecución de múltiples herramientas de pentesting
Con sistema de logging en tiempo real
"""

import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field

from aegis_pentest.tools.nmap_wrapper import NmapWrapper, NmapResult
from aegis_pentest.tools.nuclei_wrapper import NucleiWrapper
from aegis_pentest.tools.gobuster_wrapper import GobusterWrapper
from aegis_pentest.tools.nikto_wrapper import NiktoWrapper
from aegis_pentest.tools.sqlmap_wrapper import SqlMapWrapper

# Nuevas herramientas implementadas
from aegis_pentest.tools.ffuf_wrapper import FfufWrapper
from aegis_pentest.tools.zaproxy_wrapper import ZapWrapper
from aegis_pentest.tools.nginxpwner_wrapper import NginxpwnerWrapper
from aegis_pentest.tools.shodan_wrapper import ShodanWrapper
from aegis_pentest.tools.traceroute_wrapper import TracerouteWrapper
from aegis_pentest.tools.w3af_wrapper import W3afWrapper
from aegis_pentest.tools.censys_wrapper import CensysWrapper
from aegis_pentest.tools.apache_vuln_wrapper import ApacheVulnWrapper

from aegis_pentest.utils.config import Config
from aegis_pentest.utils.helpers import validate_target
from aegis_pentest.utils.logger import get_logger, ToolLogger
from aegis_pentest.utils.process_runner import get_process_runner, ToolProcessRunner


@dataclass
class ScanResult:
    """Resultado consolidado de un escaneo"""
    target: str
    scan_type: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    nmap_results: Optional[NmapResult] = None
    nuclei_results: List[Dict] = field(default_factory=list)
    gobuster_results: List[Dict] = field(default_factory=list)
    nikto_results: List[Dict] = field(default_factory=list)
    sqlmap_results: List[Dict] = field(default_factory=list)
    
    # Nuevas herramientas
    ffuf_results: List[Dict] = field(default_factory=list)
    zap_results: List[Dict] = field(default_factory=list)
    nginxpwner_results: List[Dict] = field(default_factory=list)
    shodan_results: Optional[Dict] = None
    traceroute_results: Optional[Dict] = None
    w3af_results: List[Dict] = field(default_factory=list)
    censys_results: List[Dict] = field(default_factory=list)
    apache_vuln_results: List[Dict] = field(default_factory=list)
    
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    log_file_path: Optional[str] = None
    
    @property
    def duration(self) -> Optional[float]:
        """Duración del escaneo en segundos"""
        if self.end_time and self.start_time:
            return (self.end_time - self.start_time).total_seconds()
        return None
    
    @property
    def open_ports(self) -> List[Dict]:
        """Lista de puertos abiertos encontrados"""
        if not self.nmap_results:
            return []
        
        return [port for port in self.nmap_results.ports if port.get('state') == 'open']
    
    @property
    def services(self) -> List[Dict]:
        """Lista de servicios detectados"""
        if not self.nmap_results:
            return []
        
        return self.nmap_results.services
    
    @property
    def vulnerabilities(self) -> List[Dict]:
        """Lista consolidada de vulnerabilidades"""
        vulns = []
        
        # Vulnerabilidades de Nuclei
        if self.nuclei_results:
            if isinstance(self.nuclei_results, list):
                vulns.extend(self.nuclei_results)
            elif hasattr(self.nuclei_results, 'vulnerabilities'):
                vulns.extend(self.nuclei_results.vulnerabilities)
        
        # Vulnerabilidades de Nikto
        if self.nikto_results:
            if isinstance(self.nikto_results, list):
                vulns.extend(self.nikto_results)
            else:
                # Si es un objeto NiktoResult, acceder a sus vulnerabilidades
                for result in self.nikto_results if isinstance(self.nikto_results, list) else [self.nikto_results]:
                    if hasattr(result, 'vulnerabilities'):
                        vulns.extend(result.vulnerabilities)
                    elif isinstance(result, dict):
                        vulns.append(result)
        
        # Vulnerabilidades de SQLMap  
        if self.sqlmap_results:
            if isinstance(self.sqlmap_results, list):
                vulns.extend(self.sqlmap_results)
            elif hasattr(self.sqlmap_results, 'vulnerabilities'):
                vulns.extend(self.sqlmap_results.vulnerabilities)
            elif hasattr(self.sqlmap_results, 'injections'):
                vulns.extend(self.sqlmap_results.injections)
        
        # Vulnerabilidades de OWASP ZAP
        if self.zap_results:
            if isinstance(self.zap_results, list):
                vulns.extend(self.zap_results)
            elif hasattr(self.zap_results, 'vulnerabilities'):
                vulns.extend(self.zap_results.vulnerabilities)
        
        # Vulnerabilidades de Nginxpwner
        if self.nginxpwner_results:
            if isinstance(self.nginxpwner_results, list):
                vulns.extend(self.nginxpwner_results)
            elif hasattr(self.nginxpwner_results, 'vulnerabilities'):
                vulns.extend(self.nginxpwner_results.vulnerabilities)
        
        # Vulnerabilidades de w3af
        if self.w3af_results:
            if isinstance(self.w3af_results, list):
                vulns.extend(self.w3af_results)
            elif hasattr(self.w3af_results, 'vulnerabilities'):
                vulns.extend(self.w3af_results.vulnerabilities)
        
        # Vulnerabilidades de Apache Vulnerability Testing Tool
        if self.apache_vuln_results:
            if isinstance(self.apache_vuln_results, list):
                vulns.extend(self.apache_vuln_results)
            elif hasattr(self.apache_vuln_results, 'vulnerabilities'):
                vulns.extend(self.apache_vuln_results.vulnerabilities)
        
        # Vulnerabilidades de Shodan
        if self.shodan_results and hasattr(self.shodan_results, 'vulnerabilities'):
            vulns.extend(self.shodan_results.vulnerabilities)
        
        # Información de Censys (no es vulnerabilidades per se, pero puede incluir datos útiles)
        if self.censys_results and hasattr(self.censys_results, 'vulnerabilities'):
            vulns.extend(self.censys_results.vulnerabilities)
        
        return vulns


class AegisScanner:
    """Motor principal de escaneo que coordina todas las herramientas con logging en tiempo real"""
    
    def __init__(self, config: Config, console=None):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Inicializar sistema de logging
        self.tool_logger = get_logger(console)
        self.process_runner = get_process_runner(console)
        
        # Inicializar wrappers de herramientas originales
        self.nmap = NmapWrapper(config)
        self.nuclei = NucleiWrapper(config)
        self.gobuster = GobusterWrapper(config)
        self.nikto = NiktoWrapper(config)
        self.sqlmap = SqlMapWrapper(config)
        
        # Inicializar nuevas herramientas
        self.ffuf = FfufWrapper(config)
        self.zaproxy = ZapWrapper(config)
        self.nginxpwner = NginxpwnerWrapper(config)
        self.shodan = ShodanWrapper(config)
        self.traceroute = TracerouteWrapper(config)
        self.w3af = W3afWrapper(config)
        self.censys = CensysWrapper(config)
        self.apache_vuln = ApacheVulnWrapper(config)
        
        # Estado del escaneo
        self.current_scan: Optional[ScanResult] = None
        self.is_scanning = False
        
        # Callbacks para progreso
        self.progress_callbacks: List[Callable] = []
    
    def add_progress_callback(self, callback: Callable):
        """Agrega un callback para recibir actualizaciones de progreso"""
        self.progress_callbacks.append(callback)
    
    def _update_progress(self, step: int, total: int, message: str):
        """Actualiza el progreso y notifica a los callbacks"""
        percentage = (step / total) * 100 if total > 0 else 0
        
        for callback in self.progress_callbacks:
            try:
                callback(step, total, percentage, message)
            except Exception as e:
                self.logger.error(f"Error en callback de progreso: {e}")
    
    def start_live_monitoring(self):
        """Inicia el monitoreo en vivo de herramientas"""
        self.tool_logger.start_live_display()
    
    def stop_live_monitoring(self):
        """Detiene el monitoreo en vivo de herramientas"""
        self.tool_logger.stop_live_display()
    
    def get_log_file_path(self) -> str:
        """Obtiene la ruta del archivo de log actual"""
        return str(self.tool_logger.get_log_file_path())
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> ScanResult:
        """
        Realiza un escaneo básico usando Nmap con logging en tiempo real
        
        Args:
            target: Objetivo a escanear
            ports: Puertos a escanear
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="basic",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'ports': ports
            },
            log_file_path=self.get_log_file_path()
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            # Iniciar monitoreo en vivo
            self.start_live_monitoring()
            
            self._update_progress(1, 4, "Validando objetivo...")
            
            # Verificar que Nmap esté disponible
            if not self.nmap.is_available():
                self.tool_logger.handle_tool_not_found("nmap")
                raise RuntimeError("Nmap no está disponible")
            
            self._update_progress(2, 4, "Iniciando escaneo de puertos...")
            
            # Ejecutar escaneo Nmap con logging integrado
            nmap_result = await self.nmap.basic_scan(target, ports)
            scan_result.nmap_results = nmap_result
            
            self._update_progress(3, 4, "Procesando resultados...")
            
            # Verificar si hubo errores en el proceso
            if nmap_result.process_result and not nmap_result.process_result.success:
                scan_result.errors.append(f"Error en Nmap: {nmap_result.process_result.error_message}")
                if nmap_result.process_result.timeout_occurred:
                    scan_result.errors.append("Timeout en escaneo Nmap")
            
            # Procesar resultados
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self._update_progress(4, 4, "Escaneo completado")
            
            # Log de finalización exitosa
            if nmap_result.process_result:
                self.logger.info(f"Escaneo básico completado en {scan_result.duration:.2f} segundos")
                self.logger.info(f"Puertos encontrados: {len(scan_result.open_ports)}")
                self.logger.info(f"Servicios detectados: {len(scan_result.services)}")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo básico: {e}")
            
            # Log del error en el sistema de logging
            self.tool_logger.log_tool_output("scanner", f"Error en escaneo básico: {e}", True)
            
            raise
            
        finally:
            self.is_scanning = False
            # Detener monitoreo en vivo después de un breve delay para ver resultados finales
            import asyncio
            await asyncio.sleep(2)
            self.stop_live_monitoring()
    
    async def comprehensive_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo comprensivo usando múltiples herramientas
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="comprehensive",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            },
            log_file_path=self.get_log_file_path()
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 16  # Aumentar para incluir w3af
            current_step = 0
            
            # Paso 1: Validación y detección de herramientas disponibles
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo y herramientas...")
            
            # Verificar herramientas disponibles
            available_tools = []
            unavailable_tools = []
            
            # Herramientas originales
            tools_to_check = ['nmap', 'nuclei', 'gobuster', 'nikto', 'sqlmap']
            # Nuevas herramientas - corrigiendo nombres para que coincidan con la configuración
            new_tools = ['ffuf', 'zap-baseline.py', 'nginxpwner', 'shodan', 'traceroute', 'w3af_console', 'censys', 'apache_vuln']
            tools_to_check.extend(new_tools)
            
            # Mapeo entre nombres de herramientas y atributos del scanner
            tool_attribute_mapping = {
                'nmap': 'nmap',
                'nuclei': 'nuclei',
                'gobuster': 'gobuster',
                'nikto': 'nikto',
                'sqlmap': 'sqlmap',
                'ffuf': 'ffuf',
                'zap-baseline.py': 'zaproxy',
                'nginxpwner': 'nginxpwner',
                'shodan': 'shodan',
                'traceroute': 'traceroute',
                'w3af_console': 'w3af',
                'censys': 'censys',
                'apache_vuln': 'apache_vuln'
            }
            
            for tool in tools_to_check:
                # Obtener el atributo correspondiente del scanner
                scanner_attr = tool_attribute_mapping.get(tool, tool)
                tool_wrapper = getattr(self, scanner_attr, None)
                
                if tool_wrapper and tool_wrapper.is_available():
                    available_tools.append(tool)
                    self.logger.info(f"✅ {tool.upper()} disponible")
                else:
                    unavailable_tools.append(tool)
                    self.logger.warning(f"❌ {tool.upper()} no disponible")
            
            self.tool_logger.log_tool_output("scanner", f"Herramientas disponibles: {', '.join(available_tools)}", False)
            if unavailable_tools:
                self.tool_logger.log_tool_output("scanner", f"Herramientas no disponibles: {', '.join(unavailable_tools)}", True)
            
            # Determinar estrategia de escaneo basada en tipo de target
            scan_strategy = self._determine_scan_strategy(target, target_type, available_tools)
            self.tool_logger.log_tool_output("scanner", f"Estrategia de escaneo: {scan_strategy['description']}", False)
            
            # Paso 2: Escaneo de puertos
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando puertos con Nmap...")
            
            if 'nmap' in available_tools:
                try:
                    ports = options.get('ports', scan_strategy.get('ports', '1-1000'))
                    self.logger.info(f"Iniciando escaneo Nmap comprensivo en puertos {ports}")
                    
                    nmap_result = await self.nmap.comprehensive_scan(target, ports)
                    scan_result.nmap_results = nmap_result
                    
                    self.logger.info(f"Escaneo Nmap completado exitosamente")
                    
                    # Analizar resultados para determinar servicios web
                    web_ports = self._detect_web_services(nmap_result)
                    scan_result.metadata['web_ports'] = web_ports
                    scan_result.metadata['is_web_target'] = len(web_ports) > 0
                    
                except Exception as e:
                    error_msg = f"Error en Nmap comprensivo: {str(e)}"
                    self.logger.error(error_msg)
                    scan_result.errors.append(error_msg)
                    
                    # Log del error detallado
                    import traceback
                    full_traceback = traceback.format_exc()
                    self.tool_logger.log_tool_output("nmap", f"Error detallado: {full_traceback}", True)
                    
                    # Continuar con otras herramientas aunque Nmap falle
                    self.logger.warning("Continuando con otras herramientas a pesar del error en Nmap")
            else:
                error_msg = "Nmap no disponible para escaneo comprensivo"
                scan_result.errors.append(error_msg)
                self.logger.error(error_msg)
                # Solo fallar si Nmap no está disponible en absoluto
                raise RuntimeError(error_msg)
            
            # Determinar si es un target web basado en Nmap y tipo
            is_web_target = (target_type in ['url', 'domain'] or 
                           scan_result.metadata.get('is_web_target', False))
            
            # Si es un dominio/URL pero no se detectaron servicios web, asumir que es web
            if target_type in ['url', 'domain'] and not scan_result.metadata.get('is_web_target', False):
                is_web_target = True
                self.logger.info("Target es dominio/URL - asumiendo servicios web disponibles")
            
            # Preparar URL para herramientas web
            web_target = target
            if target_type == 'domain' and not target.startswith(('http://', 'https://')):
                # Intentar HTTPS primero, luego HTTP
                web_target = f"https://{target}"
                scan_result.metadata['web_target'] = web_target
                self.logger.info(f"Preparando target web: {web_target}")
            
            # Paso 3: Detección de vulnerabilidades con Nuclei
            current_step += 1
            self._update_progress(current_step, total_steps, "Detectando vulnerabilidades con Nuclei...")
            
            if 'nuclei' in available_tools:
                try:
                    self.logger.info("=== INICIANDO NUCLEI ===")
                    # Usar web_target para herramientas web si está disponible
                    nuclei_target = scan_result.metadata.get('web_target', target)
                    nuclei_result = await self.nuclei.scan(nuclei_target)
                    scan_result.nuclei_results = nuclei_result.vulnerabilities if hasattr(nuclei_result, 'vulnerabilities') else nuclei_result
                    self.logger.info(f"=== NUCLEI COMPLETADO: {len(scan_result.nuclei_results)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en Nuclei: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== NUCLEI ERROR: {error_msg} ===")
            else:
                self.logger.info("=== NUCLEI NO DISPONIBLE - SALTANDO ===")
            
            # Paso 4: Escaneo de directorios web (solo si es target web)
            current_step += 1
            if is_web_target and 'gobuster' in available_tools:
                self._update_progress(current_step, total_steps, "Escaneando directorios web con Gobuster...")
                try:
                    self.logger.info("=== INICIANDO GOBUSTER ===")
                    # Usar web_target para herramientas web
                    gobuster_target = scan_result.metadata.get('web_target', target)
                    # Usar el método correcto dir_scan en lugar de directory_scan
                    gobuster_result = await self.gobuster.dir_scan(gobuster_target)
                    # Manejar el resultado como objeto GobusterResult
                    if hasattr(gobuster_result, 'found_paths'):
                        scan_result.gobuster_results = gobuster_result.found_paths
                    else:
                        scan_result.gobuster_results = gobuster_result if isinstance(gobuster_result, list) else [gobuster_result]
                    self.logger.info(f"=== GOBUSTER COMPLETADO: {len(scan_result.gobuster_results)} directorios encontrados ===")
                except Exception as e:
                    error_msg = f"Error en Gobuster: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== GOBUSTER ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Gobuster (no es target web o no disponible)")
                if is_web_target:
                    self.logger.info("=== GOBUSTER NO DISPONIBLE ===")
                else:
                    self.logger.info("=== SALTANDO GOBUSTER - NO ES TARGET WEB ===")
            
            # Paso 5: Análisis de vulnerabilidades web con Nikto (solo si es target web)
            current_step += 1
            if is_web_target and 'nikto' in available_tools:
                self._update_progress(current_step, total_steps, "Analizando vulnerabilidades web con Nikto...")
                try:
                    self.logger.info("=== INICIANDO NIKTO ===")
                    # Usar web_target para herramientas web
                    nikto_target = scan_result.metadata.get('web_target', target)
                    nikto_result = await self.nikto.scan(nikto_target)
                    # Manejar el resultado como objeto NiktoResult
                    if hasattr(nikto_result, 'vulnerabilities'):
                        scan_result.nikto_results = nikto_result.vulnerabilities
                    else:
                        scan_result.nikto_results = nikto_result if isinstance(nikto_result, list) else [nikto_result]
                    self.logger.info(f"=== NIKTO COMPLETADO: {len(scan_result.nikto_results)} problemas encontrados ===")
                except Exception as e:
                    error_msg = f"Error en Nikto: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== NIKTO ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Nikto (no es target web o no disponible)")
                if is_web_target:
                    self.logger.info("=== NIKTO NO DISPONIBLE ===")
                else:
                    self.logger.info("=== SALTANDO NIKTO - NO ES TARGET WEB ===")
            
            # Paso 6: Detección de inyecciones SQL con SQLMap (solo si es target web)
            current_step += 1
            if is_web_target and 'sqlmap' in available_tools:
                self._update_progress(current_step, total_steps, "Detectando inyecciones SQL con SQLMap...")
                try:
                    self.logger.info("=== INICIANDO SQLMAP ===")
                    # Usar web_target para herramientas web
                    sqlmap_target = scan_result.metadata.get('web_target', target)
                    sqlmap_result = await self.sqlmap.scan(sqlmap_target)
                    # Manejar el resultado como objeto SQLMapResult
                    if hasattr(sqlmap_result, 'vulnerabilities'):
                        scan_result.sqlmap_results = sqlmap_result.vulnerabilities
                    elif hasattr(sqlmap_result, 'injections'):
                        scan_result.sqlmap_results = sqlmap_result.injections
                    else:
                        scan_result.sqlmap_results = sqlmap_result if isinstance(sqlmap_result, list) else [sqlmap_result]
                    self.logger.info(f"=== SQLMAP COMPLETADO: {len(scan_result.sqlmap_results)} inyecciones encontradas ===")
                except Exception as e:
                    error_msg = f"Error en SQLMap: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== SQLMAP ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando SQLMap (no es target web o no disponible)")
                if is_web_target:
                    self.logger.info("=== SQLMAP NO DISPONIBLE ===")
                else:
                    self.logger.info("=== SALTANDO SQLMAP - NO ES TARGET WEB ===")
            
            # ==================== NUEVAS HERRAMIENTAS ====================
            
            # Paso 7: Reconocimiento con Shodan (solo en fase de reconocimiento)
            current_step += 1
            if 'shodan' in available_tools and self.shodan.should_run_against_target(target, target_type, 'reconnaissance'):
                self._update_progress(current_step, total_steps, "Recopilando inteligencia con Shodan...")
                try:
                    self.logger.info("=== INICIANDO SHODAN ===")
                    shodan_result = await self.shodan.host_lookup(target)
                    scan_result.shodan_results = shodan_result.__dict__ if hasattr(shodan_result, '__dict__') else shodan_result
                    self.logger.info(f"=== SHODAN COMPLETADO: {shodan_result.scan_stats.get('total_vulnerabilities', 0)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en Shodan: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== SHODAN ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Shodan (no disponible o no aplicable)")
                self.logger.info("=== SALTANDO SHODAN ===")
            
            # Paso 8: Reconocimiento con Censys (solo en fase de reconocimiento)
            current_step += 1
            if 'censys' in available_tools and self.censys.should_run_against_target(target, target_type, 'reconnaissance'):
                self._update_progress(current_step, total_steps, "Recopilando inteligencia con Censys...")
                try:
                    self.logger.info("=== INICIANDO CENSYS ===")
                    censys_result = await self.censys.host_lookup(target)
                    scan_result.censys_results = censys_result.__dict__ if hasattr(censys_result, '__dict__') else censys_result
                    self.logger.info(f"=== CENSYS COMPLETADO: {censys_result.scan_stats.get('total_services', 0)} servicios encontrados ===")
                except Exception as e:
                    error_msg = f"Error en Censys: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== CENSYS ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Censys (no disponible o no aplicable)")
                self.logger.info("=== SALTANDO CENSYS ===")
            
            # Paso 9: Análisis de rutas de red con Traceroute
            current_step += 1
            if 'traceroute' in available_tools and self.traceroute.should_run_against_target(target, target_type, 'reconnaissance'):
                self._update_progress(current_step, total_steps, "Analizando rutas de red con Traceroute...")
                try:
                    self.logger.info("=== INICIANDO TRACEROUTE ===")
                    traceroute_result = await self.traceroute.trace(target)
                    scan_result.traceroute_results = traceroute_result.__dict__ if hasattr(traceroute_result, '__dict__') else traceroute_result
                    self.logger.info(f"=== TRACEROUTE COMPLETADO: {traceroute_result.scan_stats.get('total_hops', 0)} saltos analizados ===")
                except Exception as e:
                    error_msg = f"Error en Traceroute: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== TRACEROUTE ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Traceroute (no disponible o no aplicable)")
                self.logger.info("=== SALTANDO TRACEROUTE ===")
            
            # Paso 10: Fuzzing de directorios con ffuf (solo si es target web)
            current_step += 1
            if is_web_target and 'ffuf' in available_tools and self.ffuf.should_run_against_target(target, target_type, scan_result.nmap_results):
                self._update_progress(current_step, total_steps, "Fuzzing de directorios con ffuf...")
                try:
                    self.logger.info("=== INICIANDO FFUF ===")
                    ffuf_target = scan_result.metadata.get('web_target', target)
                    ffuf_result = await self.ffuf.scan_directories(ffuf_target)
                    if hasattr(ffuf_result, 'directories') and hasattr(ffuf_result, 'files'):
                        scan_result.ffuf_results = ffuf_result.directories + ffuf_result.files
                    else:
                        scan_result.ffuf_results = ffuf_result if isinstance(ffuf_result, list) else [ffuf_result]
                    self.logger.info(f"=== FFUF COMPLETADO: {len(scan_result.ffuf_results)} elementos encontrados ===")
                except Exception as e:
                    error_msg = f"Error en ffuf: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== FFUF ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando ffuf (no es target web o no disponible)")
                self.logger.info("=== SALTANDO FFUF ===")
            
            # Paso 11: Análisis web con OWASP ZAP (solo si es target web)
            current_step += 1
            if is_web_target and 'zap-baseline.py' in available_tools and self.zaproxy.should_run_against_target(target, target_type, scan_result.nmap_results):
                self._update_progress(current_step, total_steps, "Analizando aplicación web con OWASP ZAP...")
                try:
                    self.logger.info("=== INICIANDO OWASP ZAP ===")
                    zap_target = scan_result.metadata.get('web_target', target)
                    zap_result = await self.zaproxy.quick_scan(zap_target)
                    if hasattr(zap_result, 'vulnerabilities'):
                        scan_result.zap_results = zap_result.vulnerabilities
                    else:
                        scan_result.zap_results = zap_result if isinstance(zap_result, list) else [zap_result]
                    self.logger.info(f"=== ZAP COMPLETADO: {len(scan_result.zap_results)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en OWASP ZAP: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== ZAP ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando OWASP ZAP (no es target web o no disponible)")
                self.logger.info("=== SALTANDO ZAP ===")
            
            # Paso 12: Análisis de vulnerabilidades Nginx específicas
            current_step += 1
            if is_web_target and 'nginxpwner' in available_tools and self.nginxpwner.should_run_against_target(target, target_type, scan_result.nmap_results, scan_result.nikto_results):
                self._update_progress(current_step, total_steps, "Analizando vulnerabilidades Nginx con Nginxpwner...")
                try:
                    self.logger.info("=== INICIANDO NGINXPWNER ===")
                    nginxpwner_target = scan_result.metadata.get('web_target', target)
                    nginxpwner_result = await self.nginxpwner.scan(nginxpwner_target)
                    if hasattr(nginxpwner_result, 'vulnerabilities'):
                        scan_result.nginxpwner_results = nginxpwner_result.vulnerabilities
                    else:
                        scan_result.nginxpwner_results = nginxpwner_result if isinstance(nginxpwner_result, list) else [nginxpwner_result]
                    self.logger.info(f"=== NGINXPWNER COMPLETADO: {len(scan_result.nginxpwner_results)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en Nginxpwner: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== NGINXPWNER ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Nginxpwner (no es target web o Nginx no detectado)")
                self.logger.info("=== SALTANDO NGINXPWNER ===")
            
            # Paso 13: Análisis de vulnerabilidades Apache específicas
            current_step += 1
            if is_web_target and 'apache_vuln' in available_tools and self.apache_vuln.should_run_against_target(target, target_type, scan_result.nmap_results, scan_result.nikto_results):
                self._update_progress(current_step, total_steps, "Analizando vulnerabilidades Apache...")
                try:
                    self.logger.info("=== INICIANDO APACHE VULNERABILITY TESTING ===")
                    apache_target = scan_result.metadata.get('web_target', target)
                    apache_result = await self.apache_vuln.scan(apache_target)
                    if hasattr(apache_result, 'vulnerabilities'):
                        scan_result.apache_vuln_results = apache_result.vulnerabilities
                    else:
                        scan_result.apache_vuln_results = apache_result if isinstance(apache_result, list) else [apache_result]
                    self.logger.info(f"=== APACHE VULN COMPLETADO: {len(scan_result.apache_vuln_results)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en Apache Vulnerability Testing: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== APACHE VULN ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando Apache Vulnerability Testing (no es target web o Apache no detectado)")
                self.logger.info("=== SALTANDO APACHE VULN ===")
            
            # Paso 14: Análisis comprehensivo con w3af (solo si es target web)
            current_step += 1
            if is_web_target and 'w3af_console' in available_tools and self.w3af.should_run_against_target(target, target_type, 'comprehensive'):
                self._update_progress(current_step, total_steps, "Analizando aplicación web con w3af...")
                try:
                    self.logger.info("=== INICIANDO W3AF ===")
                    w3af_target = scan_result.metadata.get('web_target', target)
                    w3af_result = await self.w3af.quick_scan(w3af_target)
                    if hasattr(w3af_result, 'vulnerabilities'):
                        scan_result.w3af_results = w3af_result.vulnerabilities
                    else:
                        scan_result.w3af_results = w3af_result if isinstance(w3af_result, list) else [w3af_result]
                    self.logger.info(f"=== W3AF COMPLETADO: {len(scan_result.w3af_results)} vulnerabilidades encontradas ===")
                except Exception as e:
                    error_msg = f"Error en w3af: {str(e)}"
                    scan_result.errors.append(error_msg)
                    self.logger.error(f"=== W3AF ERROR: {error_msg} ===")
            else:
                self._update_progress(current_step, total_steps, "Saltando w3af (no es target web o no disponible)")
                self.logger.info("=== SALTANDO W3AF ===")
            
            # Paso 15: Análisis y correlación de resultados
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando y correlacionando resultados...")
            
            # Agregar análisis inteligente de resultados
            self._analyze_scan_results(scan_result)
            
            # Paso 16: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando escaneo comprensivo...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            # Log de resumen
            total_vulns = len(scan_result.vulnerabilities)
            self.logger.info(f"Escaneo comprensivo completado en {scan_result.duration:.2f} segundos")
            self.logger.info(f"Herramientas ejecutadas: {len(available_tools)}")
            self.logger.info(f"Vulnerabilidades encontradas: {total_vulns}")
            self.logger.info(f"Puertos abiertos: {len(scan_result.open_ports)}")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            
            # Asegurar que el error se registre correctamente
            error_msg = str(e)
            if error_msg not in scan_result.errors:
                scan_result.errors.append(error_msg)
            
            self.logger.error(f"Error en escaneo comprensivo: {e}")
            
            # Log del traceback completo
            import traceback
            full_traceback = traceback.format_exc()
            self.tool_logger.log_tool_output("scanner", f"Error completo en comprehensive_scan: {full_traceback}", True)
            
            raise
            
        finally:
            self.is_scanning = False
            # Detener monitoreo en vivo después de un breve delay para ver resultados finales
            import asyncio
            await asyncio.sleep(2)
            self.stop_live_monitoring()
    
    async def vulnerability_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo enfocado en vulnerabilidades
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="vulnerability",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 4
            current_step = 0
            
            # Paso 1: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo...")
            
            # Paso 2: Escaneo de vulnerabilidades con Nmap
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando vulnerabilidades...")
            
            if self.nmap.is_available():
                ports = options.get('ports', '1-1000')
                nmap_result = await self.nmap.vulnerability_scan(target, ports)
                scan_result.nmap_results = nmap_result
            else:
                scan_result.errors.append("Nmap no disponible")
            
            # Paso 3: Análisis con herramientas especializadas
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando con herramientas especializadas...")
            
            # Ejecutar Nuclei si está disponible
            if self.nuclei.is_available():
                try:
                    nuclei_result = await self.nuclei.scan(target)
                    scan_result.nuclei_results = nuclei_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nuclei: {str(e)}")
                    self.logger.error(f"Error en Nuclei: {e}")
            
            # Ejecutar Nikto si es un target web
            if self.nikto.is_available() and target_type in ['url', 'domain']:
                try:
                    nikto_result = await self.nikto.scan(target)
                    scan_result.nikto_results = nikto_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nikto: {str(e)}")
                    self.logger.error(f"Error en Nikto: {e}")
            
            # Ejecutar SQLMap si se detectan puertos web y se solicita
            if (self.sqlmap.is_available() and 
                target_type in ['url', 'domain'] and 
                options.get('run_sqlmap', False)):
                try:
                    sqlmap_result = await self.sqlmap.scan(target)
                    scan_result.sqlmap_results = sqlmap_result
                except Exception as e:
                    scan_result.errors.append(f"Error en SQLMap: {str(e)}")
                    self.logger.error(f"Error en SQLMap: {e}")
            
            # Paso 4: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando análisis...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo de vulnerabilidades completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo de vulnerabilidades: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def custom_scan(self, target: str, tools: List[str], options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo personalizado con herramientas específicas
        
        Args:
            target: Objetivo a escanear
            tools: Lista de herramientas a usar
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo personalizado de {target} con herramientas: {tools}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="custom",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'tools': tools,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = len(tools) + 1
            current_step = 0
            
            # Paso inicial: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando configuración...")
            
            # Ejecutar herramientas seleccionadas
            for tool in tools:
                current_step += 1
                self._update_progress(current_step, total_steps, f"Ejecutando {tool}...")
                
                if tool == "nmap" and self.nmap.is_available():
                    ports = options.get('ports', '1-1000')
                    scan_type = options.get('nmap_scan_type', 'basic')
                    
                    if scan_type == 'basic':
                        result = await self.nmap.basic_scan(target, ports)
                    elif scan_type == 'comprehensive':
                        result = await self.nmap.comprehensive_scan(target, ports)
                    elif scan_type == 'vulnerability':
                        result = await self.nmap.vulnerability_scan(target, ports)
                    else:
                        result = await self.nmap.basic_scan(target, ports)
                    
                    scan_result.nmap_results = result
                
                # Aquí se agregarían otros wrappers de herramientas
                
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo personalizado completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo personalizado: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    def stop_scan(self):
        """Detiene el escaneo actual"""
        if self.is_scanning and self.current_scan:
            self.logger.info("Deteniendo escaneo actual...")
            self.current_scan.status = "stopped"
            self.current_scan.end_time = datetime.now()
            self.is_scanning = False
    
    def get_scan_status(self) -> Dict[str, Any]:
        """Obtiene el estado actual del escaneo"""
        if not self.current_scan:
            return {"status": "idle"}
        
        return {
            "status": self.current_scan.status,
            "target": self.current_scan.target,
            "scan_type": self.current_scan.scan_type,
            "start_time": self.current_scan.start_time.isoformat(),
            "duration": self.current_scan.duration,
            "is_scanning": self.is_scanning
        }
    
    def get_available_scan_types(self) -> Dict[str, Dict[str, str]]:
        """Obtiene los tipos de escaneo disponibles"""
        return {
            "basic": {
                "name": "Escaneo Básico",
                "description": "Escaneo rápido de puertos usando Nmap",
                "duration": "5-15 minutos",
                "tools": ["nmap"]
            },
            "comprehensive": {
                "name": "Escaneo Comprensivo",
                "description": "Escaneo completo con múltiples herramientas",
                "duration": "30-60 minutos",
                "tools": ["nmap", "gobuster", "nikto", "nuclei"]
            },
            "vulnerability": {
                "name": "Escaneo de Vulnerabilidades",
                "description": "Escaneo enfocado en detectar vulnerabilidades",
                "duration": "20-45 minutos",
                "tools": ["nmap", "nuclei", "nikto"]
            },
            "custom": {
                "name": "Escaneo Personalizado",
                "description": "Escaneo con herramientas seleccionadas manualmente",
                "duration": "Variable",
                "tools": ["seleccionables"]
            }
        }
    
    def save_results(self, scan_result: ScanResult, output_path: str):
        """Guarda los resultados del escaneo"""
        # Placeholder para guardar resultados
        # Aquí se implementaría la serialización y guardado
        self.logger.info(f"Guardando resultados en {output_path}")
    
    def print_results(self, scan_result: ScanResult):
        """Imprime los resultados del escaneo en consola"""
        print(f"\n=== Resultados del Escaneo ===")
        print(f"Objetivo: {scan_result.target}")
        print(f"Tipo: {scan_result.scan_type}")
        print(f"Estado: {scan_result.status}")
        print(f"Duración: {scan_result.duration:.2f} segundos" if scan_result.duration else "N/A")
        
        if scan_result.nmap_results:
            print(f"\nPuertos abiertos: {len(scan_result.open_ports)}")
            print(f"Servicios detectados: {len(scan_result.services)}")
        
        if scan_result.vulnerabilities:
            print(f"Vulnerabilidades encontradas: {len(scan_result.vulnerabilities)}")
        
        if scan_result.errors:
            print(f"\nErrores:")
            for error in scan_result.errors:
                print(f"  - {error}")
    
    async def full_audit(self, target: str, threads: int = 4) -> ScanResult:
        """
        Realiza un audit completo del objetivo usando todas las herramientas disponibles
        
        Args:
            target: Objetivo a auditar
            threads: Número de threads a usar
            
        Returns:
            ScanResult: Resultado del audit
        """
        return await self.comprehensive_scan(target, {
            'ports': '1-65535',
            'threads': threads,
            'intensive': True
        })
    
    def _determine_scan_strategy(self, target: str, target_type: str, available_tools: List[str]) -> Dict[str, Any]:
        """Determina la estrategia de escaneo basada en el target y herramientas disponibles"""
        strategy = {
            'description': 'Escaneo básico',
            'ports': '1-1000',
            'tools': available_tools,
            'web_focused': False
        }
        
        if target_type in ['url', 'domain']:
            strategy.update({
                'description': 'Escaneo web comprensivo',
                'ports': '80,443,8080,8443,3000,5000,8000,9000',
                'web_focused': True
            })
        elif target_type == 'ip':
            strategy.update({
                'description': 'Escaneo de infraestructura',
                'ports': '1-1000,3389,5432,3306,1433,27017,6379,11211',
                'web_focused': False
            })
        
        return strategy
    
    def _detect_web_services(self, nmap_result: NmapResult) -> List[Dict]:
        """Detecta servicios web en los resultados de Nmap"""
        web_ports = []
        
        if not nmap_result or not nmap_result.ports:
            return web_ports
        
        web_indicators = ['http', 'https', 'ssl/http', 'http-proxy', 'http-alt', 'apache', 'nginx', 'iis', 'lighttpd', 'tomcat']
        web_port_numbers = [80, 443, 8080, 8443, 3000, 5000, 8000, 9000, 8888, 8081, 8082, 8090, 9090, 9443]
        
        for port in nmap_result.ports:
            if port.get('state') == 'open':
                port_num = port.get('port')
                service = port.get('service', '').lower()
                version = port.get('version', '').lower()
                
                # Detectar por servicio
                is_web_service = any(indicator in service for indicator in web_indicators)
                
                # Detectar por versión/banner
                is_web_version = any(indicator in version for indicator in web_indicators)
                
                # Detectar por número de puerto común
                is_web_port = port_num in web_port_numbers
                
                if is_web_service or is_web_version or is_web_port:
                    web_ports.append({
                        'port': port_num,
                        'service': service,
                        'version': version,
                        'protocol': port.get('protocol', 'tcp'),
                        'is_ssl': 'ssl' in service or 'https' in service or port_num == 443 or port_num == 8443 or port_num == 9443
                    })
        
        return web_ports
    
    def _analyze_scan_results(self, scan_result: ScanResult):
        """Analiza y correlaciona los resultados del escaneo"""
        analysis = {
            'risk_level': 'low',
            'recommendations': [],
            'summary': {},
            'correlations': []
        }
        
        # Analizar puertos abiertos
        open_ports = scan_result.open_ports
        analysis['summary']['open_ports'] = len(open_ports)
        
        # Analizar vulnerabilidades
        total_vulns = len(scan_result.vulnerabilities)
        analysis['summary']['vulnerabilities'] = total_vulns
        
        # Determinar nivel de riesgo
        if total_vulns > 10 or len(open_ports) > 20:
            analysis['risk_level'] = 'high'
        elif total_vulns > 5 or len(open_ports) > 10:
            analysis['risk_level'] = 'medium'
        
        # Recomendaciones básicas
        if len(open_ports) > 10:
            analysis['recommendations'].append("Revisar puertos abiertos innecesarios")
        
        if total_vulns > 0:
            analysis['recommendations'].append("Parchear vulnerabilidades encontradas")
        
        # Correlaciones entre herramientas
        if scan_result.gobuster_results and scan_result.nikto_results:
            analysis['correlations'].append("Directorios encontrados correlacionados con vulnerabilidades web")
        
        # Guardar análisis en metadata
        scan_result.metadata['analysis'] = analysis
        
        self.logger.info(f"Análisis completado - Nivel de riesgo: {analysis['risk_level']}")
        self.logger.info(f"Recomendaciones: {len(analysis['recommendations'])}") 