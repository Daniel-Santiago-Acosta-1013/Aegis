"""
Motor principal de escaneo de Aegis Pentest Automation
Coordina la ejecución de múltiples herramientas de pentesting
Con sistema de logging en tiempo real
"""

import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field

from aegis_pentest.tools.nmap_wrapper import NmapWrapper, NmapResult
from aegis_pentest.tools.nuclei_wrapper import NucleiWrapper
from aegis_pentest.tools.gobuster_wrapper import GobusterWrapper
from aegis_pentest.tools.nikto_wrapper import NiktoWrapper
from aegis_pentest.tools.sqlmap_wrapper import SqlMapWrapper
from aegis_pentest.utils.config import Config
from aegis_pentest.utils.helpers import validate_target
from aegis_pentest.utils.logger import get_logger, ToolLogger
from aegis_pentest.utils.process_runner import get_process_runner, ToolProcessRunner


@dataclass
class ScanResult:
    """Resultado consolidado de un escaneo"""
    target: str
    scan_type: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    nmap_results: Optional[NmapResult] = None
    nuclei_results: List[Dict] = field(default_factory=list)
    gobuster_results: List[Dict] = field(default_factory=list)
    nikto_results: List[Dict] = field(default_factory=list)
    sqlmap_results: List[Dict] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    log_file_path: Optional[str] = None
    
    @property
    def duration(self) -> Optional[float]:
        """Duración del escaneo en segundos"""
        if self.end_time and self.start_time:
            return (self.end_time - self.start_time).total_seconds()
        return None
    
    @property
    def open_ports(self) -> List[Dict]:
        """Lista de puertos abiertos encontrados"""
        if not self.nmap_results:
            return []
        
        return [port for port in self.nmap_results.ports if port.get('state') == 'open']
    
    @property
    def services(self) -> List[Dict]:
        """Lista de servicios detectados"""
        if not self.nmap_results:
            return []
        
        return self.nmap_results.services
    
    @property
    def vulnerabilities(self) -> List[Dict]:
        """Lista consolidada de vulnerabilidades"""
        vulns = []
        
        # Vulnerabilidades de Nuclei
        vulns.extend(self.nuclei_results)
        
        # Vulnerabilidades de Nikto
        vulns.extend(self.nikto_results)
        
        # Vulnerabilidades de SQLMap
        vulns.extend(self.sqlmap_results)
        
        return vulns


class AegisScanner:
    """Motor principal de escaneo que coordina todas las herramientas con logging en tiempo real"""
    
    def __init__(self, config: Config, console=None):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Inicializar sistema de logging
        self.tool_logger = get_logger(console)
        self.process_runner = get_process_runner(console)
        
        # Inicializar wrappers de herramientas
        self.nmap = NmapWrapper(config)
        self.nuclei = NucleiWrapper(config)
        self.gobuster = GobusterWrapper(config)
        self.nikto = NiktoWrapper(config)
        self.sqlmap = SqlMapWrapper(config)
        # Aquí se inicializarían otros wrappers cuando estén disponibles
        
        # Estado del escaneo
        self.current_scan: Optional[ScanResult] = None
        self.is_scanning = False
        
        # Callbacks para progreso
        self.progress_callbacks: List[Callable] = []
    
    def add_progress_callback(self, callback: Callable):
        """Agrega un callback para recibir actualizaciones de progreso"""
        self.progress_callbacks.append(callback)
    
    def _update_progress(self, step: int, total: int, message: str):
        """Actualiza el progreso y notifica a los callbacks"""
        percentage = (step / total) * 100 if total > 0 else 0
        
        for callback in self.progress_callbacks:
            try:
                callback(step, total, percentage, message)
            except Exception as e:
                self.logger.error(f"Error en callback de progreso: {e}")
    
    def start_live_monitoring(self):
        """Inicia el monitoreo en vivo de herramientas"""
        self.tool_logger.start_live_display()
    
    def stop_live_monitoring(self):
        """Detiene el monitoreo en vivo de herramientas"""
        self.tool_logger.stop_live_display()
    
    def get_log_file_path(self) -> Optional[str]:
        """Obtiene la ruta del archivo de log actual"""
        return str(self.tool_logger.get_log_file_path())
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> ScanResult:
        """
        Realiza un escaneo básico usando Nmap con logging en tiempo real
        
        Args:
            target: Objetivo a escanear
            ports: Puertos a escanear
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="basic",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'ports': ports
            },
            log_file_path=self.get_log_file_path()
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            # Iniciar monitoreo en vivo
            self.start_live_monitoring()
            
            self._update_progress(1, 4, "Validando objetivo...")
            
            # Verificar que Nmap esté disponible
            if not self.nmap.is_available():
                self.tool_logger.handle_tool_not_found("nmap")
                raise RuntimeError("Nmap no está disponible")
            
            self._update_progress(2, 4, "Iniciando escaneo de puertos...")
            
            # Ejecutar escaneo Nmap con logging integrado
            nmap_result = await self.nmap.basic_scan(target, ports)
            scan_result.nmap_results = nmap_result
            
            self._update_progress(3, 4, "Procesando resultados...")
            
            # Verificar si hubo errores en el proceso
            if nmap_result.process_result and not nmap_result.process_result.success:
                scan_result.errors.append(f"Error en Nmap: {nmap_result.process_result.error_message}")
                if nmap_result.process_result.timeout_occurred:
                    scan_result.errors.append("Timeout en escaneo Nmap")
            
            # Procesar resultados
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self._update_progress(4, 4, "Escaneo completado")
            
            # Log de finalización exitosa
            if nmap_result.process_result:
                self.logger.info(f"Escaneo básico completado en {scan_result.duration:.2f} segundos")
                self.logger.info(f"Puertos encontrados: {len(scan_result.open_ports)}")
                self.logger.info(f"Servicios detectados: {len(scan_result.services)}")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo básico: {e}")
            
            # Log del error en el sistema de logging
            self.tool_logger.log_tool_output("scanner", f"Error en escaneo básico: {e}", True)
            
            raise
            
        finally:
            self.is_scanning = False
            # Detener monitoreo en vivo después de un breve delay para ver resultados finales
            import asyncio
            await asyncio.sleep(2)
            self.stop_live_monitoring()
    
    async def comprehensive_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo comprensivo usando múltiples herramientas
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="comprehensive",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 6  # Número total de pasos
            current_step = 0
            
            # Paso 1: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo...")
            
            # Paso 2: Escaneo de puertos
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando puertos...")
            
            if self.nmap.is_available():
                ports = options.get('ports', '1-1000')
                nmap_result = await self.nmap.comprehensive_scan(target, ports)
                scan_result.nmap_results = nmap_result
            else:
                scan_result.errors.append("Nmap no disponible")
            
            # Paso 3: Escaneo de directorios
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando directorios...")
            
            # Ejecutar Gobuster si está disponible y es un target web
            if self.gobuster.is_available() and target_type in ['url', 'domain']:
                try:
                    gobuster_result = await self.gobuster.directory_scan(target)
                    scan_result.gobuster_results = gobuster_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Gobuster: {str(e)}")
                    self.logger.error(f"Error en Gobuster: {e}")
            
            # Paso 4: Análisis de vulnerabilidades web
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando vulnerabilidades web...")
            
            # Ejecutar Nikto si está disponible y es un target web
            if self.nikto.is_available() and target_type in ['url', 'domain']:
                try:
                    nikto_result = await self.nikto.scan(target)
                    scan_result.nikto_results = nikto_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nikto: {str(e)}")
                    self.logger.error(f"Error en Nikto: {e}")
            
            # Paso 5: Detección de vulnerabilidades
            current_step += 1
            self._update_progress(current_step, total_steps, "Detectando vulnerabilidades...")
            
            # Ejecutar Nuclei si está disponible
            if self.nuclei.is_available():
                try:
                    nuclei_result = await self.nuclei.scan(target)
                    scan_result.nuclei_results = nuclei_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nuclei: {str(e)}")
                    self.logger.error(f"Error en Nuclei: {e}")
            
            # Paso 6: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando escaneo...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo comprensivo completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo comprensivo: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def vulnerability_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo enfocado en vulnerabilidades
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="vulnerability",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 4
            current_step = 0
            
            # Paso 1: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo...")
            
            # Paso 2: Escaneo de vulnerabilidades con Nmap
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando vulnerabilidades...")
            
            if self.nmap.is_available():
                ports = options.get('ports', '1-1000')
                nmap_result = await self.nmap.vulnerability_scan(target, ports)
                scan_result.nmap_results = nmap_result
            else:
                scan_result.errors.append("Nmap no disponible")
            
            # Paso 3: Análisis con herramientas especializadas
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando con herramientas especializadas...")
            
            # Ejecutar Nuclei si está disponible
            if self.nuclei.is_available():
                try:
                    nuclei_result = await self.nuclei.scan(target)
                    scan_result.nuclei_results = nuclei_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nuclei: {str(e)}")
                    self.logger.error(f"Error en Nuclei: {e}")
            
            # Ejecutar Nikto si es un target web
            if self.nikto.is_available() and target_type in ['url', 'domain']:
                try:
                    nikto_result = await self.nikto.scan(target)
                    scan_result.nikto_results = nikto_result
                except Exception as e:
                    scan_result.errors.append(f"Error en Nikto: {str(e)}")
                    self.logger.error(f"Error en Nikto: {e}")
            
            # Ejecutar SQLMap si se detectan puertos web y se solicita
            if (self.sqlmap.is_available() and 
                target_type in ['url', 'domain'] and 
                options.get('run_sqlmap', False)):
                try:
                    sqlmap_result = await self.sqlmap.scan(target)
                    scan_result.sqlmap_results = sqlmap_result
                except Exception as e:
                    scan_result.errors.append(f"Error en SQLMap: {str(e)}")
                    self.logger.error(f"Error en SQLMap: {e}")
            
            # Paso 4: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando análisis...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo de vulnerabilidades completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo de vulnerabilidades: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def custom_scan(self, target: str, tools: List[str], options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo personalizado con herramientas específicas
        
        Args:
            target: Objetivo a escanear
            tools: Lista de herramientas a usar
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo personalizado de {target} con herramientas: {tools}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="custom",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'tools': tools,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = len(tools) + 1
            current_step = 0
            
            # Paso inicial: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando configuración...")
            
            # Ejecutar herramientas seleccionadas
            for tool in tools:
                current_step += 1
                self._update_progress(current_step, total_steps, f"Ejecutando {tool}...")
                
                if tool == "nmap" and self.nmap.is_available():
                    ports = options.get('ports', '1-1000')
                    scan_type = options.get('nmap_scan_type', 'basic')
                    
                    if scan_type == 'basic':
                        result = await self.nmap.basic_scan(target, ports)
                    elif scan_type == 'comprehensive':
                        result = await self.nmap.comprehensive_scan(target, ports)
                    elif scan_type == 'vulnerability':
                        result = await self.nmap.vulnerability_scan(target, ports)
                    else:
                        result = await self.nmap.basic_scan(target, ports)
                    
                    scan_result.nmap_results = result
                
                # Aquí se agregarían otros wrappers de herramientas
                
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo personalizado completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo personalizado: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    def stop_scan(self):
        """Detiene el escaneo actual"""
        if self.is_scanning and self.current_scan:
            self.logger.info("Deteniendo escaneo actual...")
            self.current_scan.status = "stopped"
            self.current_scan.end_time = datetime.now()
            self.is_scanning = False
    
    def get_scan_status(self) -> Dict[str, Any]:
        """Obtiene el estado actual del escaneo"""
        if not self.current_scan:
            return {"status": "idle"}
        
        return {
            "status": self.current_scan.status,
            "target": self.current_scan.target,
            "scan_type": self.current_scan.scan_type,
            "start_time": self.current_scan.start_time.isoformat(),
            "duration": self.current_scan.duration,
            "is_scanning": self.is_scanning
        }
    
    def get_available_scan_types(self) -> Dict[str, Dict[str, str]]:
        """Obtiene los tipos de escaneo disponibles"""
        return {
            "basic": {
                "name": "Escaneo Básico",
                "description": "Escaneo rápido de puertos usando Nmap",
                "duration": "5-15 minutos",
                "tools": ["nmap"]
            },
            "comprehensive": {
                "name": "Escaneo Comprensivo",
                "description": "Escaneo completo con múltiples herramientas",
                "duration": "30-60 minutos",
                "tools": ["nmap", "gobuster", "nikto", "nuclei"]
            },
            "vulnerability": {
                "name": "Escaneo de Vulnerabilidades",
                "description": "Escaneo enfocado en detectar vulnerabilidades",
                "duration": "20-45 minutos",
                "tools": ["nmap", "nuclei", "nikto"]
            },
            "custom": {
                "name": "Escaneo Personalizado",
                "description": "Escaneo con herramientas seleccionadas manualmente",
                "duration": "Variable",
                "tools": ["seleccionables"]
            }
        }
    
    def save_results(self, scan_result: ScanResult, output_path: str):
        """Guarda los resultados del escaneo"""
        # Placeholder para guardar resultados
        # Aquí se implementaría la serialización y guardado
        self.logger.info(f"Guardando resultados en {output_path}")
    
    def print_results(self, scan_result: ScanResult):
        """Imprime los resultados del escaneo en consola"""
        print(f"\n=== Resultados del Escaneo ===")
        print(f"Objetivo: {scan_result.target}")
        print(f"Tipo: {scan_result.scan_type}")
        print(f"Estado: {scan_result.status}")
        print(f"Duración: {scan_result.duration:.2f} segundos" if scan_result.duration else "N/A")
        
        if scan_result.nmap_results:
            print(f"\nPuertos abiertos: {len(scan_result.open_ports)}")
            print(f"Servicios detectados: {len(scan_result.services)}")
        
        if scan_result.vulnerabilities:
            print(f"Vulnerabilidades encontradas: {len(scan_result.vulnerabilities)}")
        
        if scan_result.errors:
            print(f"\nErrores:")
            for error in scan_result.errors:
                print(f"  - {error}")
    
    async def full_audit(self, target: str, threads: int = 4) -> ScanResult:
        """
        Realiza una auditoría completa del objetivo
        
        Args:
            target: Objetivo a auditar
            threads: Número de hilos para ejecución paralela
            
        Returns:
            ScanResult: Resultado de la auditoría
        """
        options = {
            'ports': '1-65535',
            'threads': threads,
            'deep_scan': True
        }
        
        return await self.comprehensive_scan(target, options) 