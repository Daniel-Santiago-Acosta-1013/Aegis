"""
Motor principal de escaneo de Aegis Pentest Automation
Coordina la ejecución de múltiples herramientas de pentesting
"""

import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field

from aegis_pentest.tools.nmap_wrapper import NmapWrapper, NmapResult
from aegis_pentest.utils.config import Config
from aegis_pentest.utils.helpers import validate_target


@dataclass
class ScanResult:
    """Resultado consolidado de un escaneo"""
    target: str
    scan_type: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    nmap_results: Optional[NmapResult] = None
    nuclei_results: List[Dict] = field(default_factory=list)
    gobuster_results: List[Dict] = field(default_factory=list)
    nikto_results: List[Dict] = field(default_factory=list)
    sqlmap_results: List[Dict] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def duration(self) -> Optional[float]:
        """Duración del escaneo en segundos"""
        if self.end_time and self.start_time:
            return (self.end_time - self.start_time).total_seconds()
        return None
    
    @property
    def open_ports(self) -> List[Dict]:
        """Lista de puertos abiertos encontrados"""
        if not self.nmap_results:
            return []
        
        return [port for port in self.nmap_results.ports if port.get('state') == 'open']
    
    @property
    def services(self) -> List[Dict]:
        """Lista de servicios detectados"""
        if not self.nmap_results:
            return []
        
        return self.nmap_results.services
    
    @property
    def vulnerabilities(self) -> List[Dict]:
        """Lista consolidada de vulnerabilidades"""
        vulns = []
        
        # Vulnerabilidades de Nuclei
        vulns.extend(self.nuclei_results)
        
        # Vulnerabilidades de Nikto
        vulns.extend(self.nikto_results)
        
        # Vulnerabilidades de SQLMap
        vulns.extend(self.sqlmap_results)
        
        return vulns


class AegisScanner:
    """Motor principal de escaneo que coordina todas las herramientas"""
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Inicializar wrappers de herramientas
        self.nmap = NmapWrapper(config)
        # Aquí se inicializarían otros wrappers cuando estén disponibles
        
        # Estado del escaneo
        self.current_scan: Optional[ScanResult] = None
        self.is_scanning = False
        
        # Callbacks para progreso
        self.progress_callbacks: List[Callable] = []
    
    def add_progress_callback(self, callback: Callable):
        """Agrega un callback para recibir actualizaciones de progreso"""
        self.progress_callbacks.append(callback)
    
    def _update_progress(self, step: int, total: int, message: str):
        """Actualiza el progreso y notifica a los callbacks"""
        percentage = (step / total) * 100 if total > 0 else 0
        
        for callback in self.progress_callbacks:
            try:
                callback(step, total, percentage, message)
            except Exception as e:
                self.logger.error(f"Error en callback de progreso: {e}")
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> ScanResult:
        """
        Realiza un escaneo básico usando Nmap
        
        Args:
            target: Objetivo a escanear
            ports: Puertos a escanear
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="basic",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'ports': ports
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            self._update_progress(1, 4, "Validando objetivo...")
            
            # Verificar que Nmap esté disponible
            if not self.nmap.is_available():
                raise RuntimeError("Nmap no está disponible")
            
            self._update_progress(2, 4, "Iniciando escaneo de puertos...")
            
            # Ejecutar escaneo Nmap
            nmap_result = await self.nmap.basic_scan(target, ports)
            scan_result.nmap_results = nmap_result
            
            self._update_progress(3, 4, "Procesando resultados...")
            
            # Procesar resultados
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self._update_progress(4, 4, "Escaneo completado")
            
            self.logger.info(f"Escaneo básico completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo básico: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def comprehensive_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo comprensivo usando múltiples herramientas
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="comprehensive",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 6  # Número total de pasos
            current_step = 0
            
            # Paso 1: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo...")
            
            # Paso 2: Escaneo de puertos
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando puertos...")
            
            if self.nmap.is_available():
                ports = options.get('ports', '1-1000')
                nmap_result = await self.nmap.comprehensive_scan(target, ports)
                scan_result.nmap_results = nmap_result
            else:
                scan_result.errors.append("Nmap no disponible")
            
            # Paso 3: Escaneo de directorios
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando directorios...")
            
            # Aquí se ejecutaría Gobuster cuando esté implementado
            # gobuster_result = await self.gobuster.scan(target)
            # scan_result.gobuster_results = gobuster_result
            
            # Paso 4: Análisis de vulnerabilidades web
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando vulnerabilidades web...")
            
            # Aquí se ejecutaría Nikto cuando esté implementado
            # nikto_result = await self.nikto.scan(target)
            # scan_result.nikto_results = nikto_result
            
            # Paso 5: Detección de vulnerabilidades
            current_step += 1
            self._update_progress(current_step, total_steps, "Detectando vulnerabilidades...")
            
            # Aquí se ejecutaría Nuclei cuando esté implementado
            # nuclei_result = await self.nuclei.scan(target)
            # scan_result.nuclei_results = nuclei_result
            
            # Paso 6: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando escaneo...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo comprensivo completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo comprensivo: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def vulnerability_scan(self, target: str, options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo enfocado en vulnerabilidades
        
        Args:
            target: Objetivo a escanear
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="vulnerability",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = 4
            current_step = 0
            
            # Paso 1: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando objetivo...")
            
            # Paso 2: Escaneo de vulnerabilidades con Nmap
            current_step += 1
            self._update_progress(current_step, total_steps, "Escaneando vulnerabilidades...")
            
            if self.nmap.is_available():
                ports = options.get('ports', '1-1000')
                nmap_result = await self.nmap.vulnerability_scan(target, ports)
                scan_result.nmap_results = nmap_result
            else:
                scan_result.errors.append("Nmap no disponible")
            
            # Paso 3: Análisis con herramientas especializadas
            current_step += 1
            self._update_progress(current_step, total_steps, "Analizando con herramientas especializadas...")
            
            # Aquí se ejecutarían otras herramientas de vulnerabilidades
            
            # Paso 4: Finalización
            current_step += 1
            self._update_progress(current_step, total_steps, "Finalizando análisis...")
            
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo de vulnerabilidades completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo de vulnerabilidades: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    async def custom_scan(self, target: str, tools: List[str], options: Dict[str, Any] = None) -> ScanResult:
        """
        Realiza un escaneo personalizado con herramientas específicas
        
        Args:
            target: Objetivo a escanear
            tools: Lista de herramientas a usar
            options: Opciones de configuración del escaneo
            
        Returns:
            ScanResult: Resultado del escaneo
        """
        options = options or {}
        
        self.logger.info(f"Iniciando escaneo personalizado de {target} con herramientas: {tools}")
        
        # Validar objetivo
        is_valid, target_type, error_msg = validate_target(target)
        if not is_valid:
            raise ValueError(f"Objetivo inválido: {error_msg}")
        
        # Crear resultado del escaneo
        scan_result = ScanResult(
            target=target,
            scan_type="custom",
            start_time=datetime.now(),
            metadata={
                'target_type': target_type,
                'tools': tools,
                'options': options
            }
        )
        
        self.current_scan = scan_result
        self.is_scanning = True
        
        try:
            total_steps = len(tools) + 1
            current_step = 0
            
            # Paso inicial: Validación
            current_step += 1
            self._update_progress(current_step, total_steps, "Validando configuración...")
            
            # Ejecutar herramientas seleccionadas
            for tool in tools:
                current_step += 1
                self._update_progress(current_step, total_steps, f"Ejecutando {tool}...")
                
                if tool == "nmap" and self.nmap.is_available():
                    ports = options.get('ports', '1-1000')
                    scan_type = options.get('nmap_scan_type', 'basic')
                    
                    if scan_type == 'basic':
                        result = await self.nmap.basic_scan(target, ports)
                    elif scan_type == 'comprehensive':
                        result = await self.nmap.comprehensive_scan(target, ports)
                    elif scan_type == 'vulnerability':
                        result = await self.nmap.vulnerability_scan(target, ports)
                    else:
                        result = await self.nmap.basic_scan(target, ports)
                    
                    scan_result.nmap_results = result
                
                # Aquí se agregarían otros wrappers de herramientas
                
            scan_result.status = "completed"
            scan_result.end_time = datetime.now()
            
            self.logger.info(f"Escaneo personalizado completado en {scan_result.duration:.2f} segundos")
            
            return scan_result
            
        except Exception as e:
            scan_result.status = "error"
            scan_result.end_time = datetime.now()
            scan_result.errors.append(str(e))
            
            self.logger.error(f"Error en escaneo personalizado: {e}")
            raise
            
        finally:
            self.is_scanning = False
    
    def stop_scan(self):
        """Detiene el escaneo actual"""
        if self.is_scanning and self.current_scan:
            self.logger.info("Deteniendo escaneo actual...")
            self.current_scan.status = "stopped"
            self.current_scan.end_time = datetime.now()
            self.is_scanning = False
    
    def get_scan_status(self) -> Dict[str, Any]:
        """Obtiene el estado actual del escaneo"""
        if not self.current_scan:
            return {"status": "idle"}
        
        return {
            "status": self.current_scan.status,
            "target": self.current_scan.target,
            "scan_type": self.current_scan.scan_type,
            "start_time": self.current_scan.start_time.isoformat(),
            "duration": self.current_scan.duration,
            "is_scanning": self.is_scanning
        }
    
    def get_available_scan_types(self) -> Dict[str, Dict[str, str]]:
        """Obtiene los tipos de escaneo disponibles"""
        return {
            "basic": {
                "name": "Escaneo Básico",
                "description": "Escaneo rápido de puertos usando Nmap",
                "duration": "5-15 minutos",
                "tools": ["nmap"]
            },
            "comprehensive": {
                "name": "Escaneo Comprensivo",
                "description": "Escaneo completo con múltiples herramientas",
                "duration": "30-60 minutos",
                "tools": ["nmap", "gobuster", "nikto", "nuclei"]
            },
            "vulnerability": {
                "name": "Escaneo de Vulnerabilidades",
                "description": "Escaneo enfocado en detectar vulnerabilidades",
                "duration": "20-45 minutos",
                "tools": ["nmap", "nuclei", "nikto"]
            },
            "custom": {
                "name": "Escaneo Personalizado",
                "description": "Escaneo con herramientas seleccionadas manualmente",
                "duration": "Variable",
                "tools": ["seleccionables"]
            }
        }
    
    def save_results(self, scan_result: ScanResult, output_path: str):
        """Guarda los resultados del escaneo"""
        # Placeholder para guardar resultados
        # Aquí se implementaría la serialización y guardado
        self.logger.info(f"Guardando resultados en {output_path}")
    
    def print_results(self, scan_result: ScanResult):
        """Imprime los resultados del escaneo en consola"""
        print(f"\n=== Resultados del Escaneo ===")
        print(f"Objetivo: {scan_result.target}")
        print(f"Tipo: {scan_result.scan_type}")
        print(f"Estado: {scan_result.status}")
        print(f"Duración: {scan_result.duration:.2f} segundos" if scan_result.duration else "N/A")
        
        if scan_result.nmap_results:
            print(f"\nPuertos abiertos: {len(scan_result.open_ports)}")
            print(f"Servicios detectados: {len(scan_result.services)}")
        
        if scan_result.vulnerabilities:
            print(f"Vulnerabilidades encontradas: {len(scan_result.vulnerabilities)}")
        
        if scan_result.errors:
            print(f"\nErrores:")
            for error in scan_result.errors:
                print(f"  - {error}")
    
    async def full_audit(self, target: str, threads: int = 4) -> ScanResult:
        """
        Realiza una auditoría completa del objetivo
        
        Args:
            target: Objetivo a auditar
            threads: Número de hilos para ejecución paralela
            
        Returns:
            ScanResult: Resultado de la auditoría
        """
        options = {
            'ports': '1-65535',
            'threads': threads,
            'deep_scan': True
        }
        
        return await self.comprehensive_scan(target, options) 