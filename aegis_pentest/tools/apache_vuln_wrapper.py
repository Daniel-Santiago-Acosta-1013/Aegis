"""
Wrapper para Apache Vulnerability Testing Tool - Herramienta específica para vulnerabilidades de Apache
"""

import logging
import re
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class ApacheVulnResult:
    """Resultado de un escaneo con Apache Vulnerability Testing Tool"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    apache_info: Dict[str, Any]
    scan_stats: Dict[str, Any]
    raw_output: str


class ApacheVulnWrapper:
    """Wrapper para la herramienta Apache Vulnerability Testing Tool"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('apache_vuln')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Apache Vulnerability Testing Tool está disponible"""
        return self.config.is_tool_available('apache_vuln')
    
    def should_run_against_target(self, target: str, target_type: str, nmap_result=None, 
                                  nikto_result=None, service_info=None) -> bool:
        """Determina si Apache Vuln Tool debe ejecutarse contra el target"""
        # Solo ejecutar en targets web
        if target_type not in ['url', 'domain']:
            return False
        
        # Verificar si hay evidencia de Apache
        apache_detected = False
        
        # 1. Verificar en resultados de nmap
        if nmap_result and hasattr(nmap_result, 'services'):
            for service in nmap_result.services:
                service_version = service.get('version', '').lower()
                if 'apache' in service_version:
                    apache_detected = True
                    self.logger.info(f"Apache detectado en Nmap: {service.get('version')}")
                    break
        
        # 2. Verificar en resultados de Nikto si están disponibles
        if nikto_result:
            for vuln in nikto_result:
                if 'apache' in str(vuln).lower():
                    apache_detected = True
                    self.logger.info("Apache detectado en resultados de Nikto")
                    break
        
        # 3. Verificar en información de servicios adicional
        if service_info:
            for service in service_info:
                if 'apache' in str(service).lower():
                    apache_detected = True
                    self.logger.info("Apache detectado en información de servicios")
                    break
        
        if not apache_detected:
            self.logger.info("Apache no detectado - saltando Apache Vulnerability Testing Tool")
            return False
        
        return True
    
    async def scan(self, target: str) -> ApacheVulnResult:
        """Escanea vulnerabilidades específicas de Apache"""
        if not self.is_available():
            raise RuntimeError("Apache Vulnerability Testing Tool no está disponible")
        
        self.logger.info(f"Iniciando escaneo Apache Vulnerability Testing Tool de {target}")
        
        # Preparar URL base
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        # Comando para Apache Vulnerability Testing Tool
        cmd = [
            'python3',
            self.tool_config.get('path', './poc_vulnerability_testing.py'),
            '--target', target
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="apache_vuln",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 300)
            )
            
            # La herramienta puede retornar códigos no-zero pero aún dar información útil
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            full_output = stdout + stderr
            
            # Parsear resultados
            vulnerabilities = self._parse_vulnerabilities(full_output)
            apache_info = self._extract_apache_info(full_output)
            
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'target': target,
                'apache_version': apache_info.get('version', 'Unknown'),
                'cves_tested': apache_info.get('cves_tested', [])
            }
            
            result = ApacheVulnResult(
                target=target,
                vulnerabilities=vulnerabilities,
                apache_info=apache_info,
                scan_stats=scan_stats,
                raw_output=full_output
            )
            
            self.logger.info(f"Escaneo Apache Vulnerability Testing Tool completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en Apache Vulnerability Testing Tool: {str(e)}")
            raise
    
    def _parse_vulnerabilities(self, output: str) -> List[Dict[str, Any]]:
        """Parsea las vulnerabilidades encontradas por Apache Vulnerability Testing Tool"""
        vulnerabilities = []
        lines = output.splitlines()
        
        # CVEs conocidos que detecta la herramienta
        known_cves = {
            'CVE-2024-38472': 'Apache HTTP Server on Windows UNC SSRF',
            'CVE-2024-39573': 'mod_rewrite proxy handler substitution',
            'CVE-2024-38477': 'Crash resulting in Denial of Service in mod_proxy',
            'CVE-2024-38476': 'Exploitable backend application output causing internal redirects',
            'CVE-2024-38475': 'mod_rewrite weakness with filesystem path matching',
            'CVE-2024-38474': 'Weakness with encoded question marks in backreferences',
            'CVE-2024-38473': 'mod_proxy proxy encoding problem',
            'CVE-2023-38709': 'HTTP response splitting'
        }
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            # Buscar indicadores de vulnerabilidades
            if any(indicator in line.lower() for indicator in [
                'vulnerable', 'exploit', 'found', 'potential vulnerability',
                'security issue', 'poc successful'
            ]):
                
                # Determinar severidad y CVE
                severity = self._determine_severity(line)
                cve_id = self._extract_cve_from_line(line)
                
                # Buscar descripción en líneas siguientes
                description = line
                vulnerability_type = 'Generic Apache Vulnerability'
                
                if cve_id in known_cves:
                    vulnerability_type = known_cves[cve_id]
                    description = f"{cve_id}: {vulnerability_type}"
                
                # Buscar contexto adicional
                for j in range(i+1, min(i+5, len(lines))):
                    if lines[j].strip() and not lines[j].startswith('['):
                        description += " " + lines[j].strip()
                        break
                
                vuln = {
                    'id': cve_id if cve_id != 'N/A' else f'apache_vuln_{len(vulnerabilities) + 1}',
                    'severity': severity,
                    'port': 'N/A',
                    'description': description[:150],
                    'type': 'apache_vuln',
                    'vulnerability_type': vulnerability_type,
                    'cve_id': cve_id,
                    'exploitation_status': self._determine_exploitation_status(line),
                    'raw_data': {'line': line, 'context': description}
                }
                vulnerabilities.append(vuln)
            
            # Buscar líneas específicas de testing de endpoints
            elif any(endpoint in line.lower() for endpoint in [
                'php-info.php', 'xmlrpc.php', 'adminer.php', 'cgi-bin'
            ]):
                # Verificar si la respuesta indica vulnerabilidad
                if any(vuln_indicator in line.lower() for vuln_indicator in [
                    '200', 'found', 'accessible', 'exposed'
                ]):
                    vuln = {
                        'id': f'apache_exposure_{len(vulnerabilities) + 1}',
                        'severity': 'MEDIUM',
                        'port': 'N/A',
                        'description': f"Endpoint expuesto detectado: {line[:100]}",
                        'type': 'apache_vuln',
                        'vulnerability_type': 'Information Disclosure',
                        'cve_id': 'N/A',
                        'exploitation_status': 'Confirmed',
                        'raw_data': {'line': line}
                    }
                    vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_apache_info(self, output: str) -> Dict[str, Any]:
        """Extrae información del servidor Apache"""
        apache_info = {
            'version': 'Unknown',
            'modules': [],
            'server_tokens': 'Unknown',
            'cves_tested': [],
            'endpoints_tested': []
        }
        
        lines = output.splitlines()
        
        for line in lines:
            line = line.strip()
            
            # Buscar versión de Apache
            version_match = re.search(r'apache[/\s](\d+\.\d+(?:\.\d+)?)', line, re.IGNORECASE)
            if version_match:
                apache_info['version'] = version_match.group(1)
            
            # Buscar módulos mencionados
            if any(module in line.lower() for module in ['mod_rewrite', 'mod_proxy', 'mod_ssl']):
                apache_info['modules'].append(line)
            
            # Buscar CVEs que se están probando
            cve_match = re.search(r'CVE-\d{4}-\d+', line, re.IGNORECASE)
            if cve_match and cve_match.group(0) not in apache_info['cves_tested']:
                apache_info['cves_tested'].append(cve_match.group(0))
            
            # Buscar endpoints que se están probando
            if any(endpoint in line.lower() for endpoint in [
                'php-info.php', 'xmlrpc.php', 'adminer.php', 'bin/cron.php',
                'cache/index.tpl.php', 'cgi-bin/redir.cgi'
            ]):
                endpoint_match = re.search(r'([a-zA-Z0-9/_.-]+\.(?:php|cgi|tpl))', line)
                if endpoint_match and endpoint_match.group(0) not in apache_info['endpoints_tested']:
                    apache_info['endpoints_tested'].append(endpoint_match.group(0))
        
        return apache_info
    
    def _determine_severity(self, line: str) -> str:
        """Determina la severidad basada en el contenido de la línea"""
        line_lower = line.lower()
        
        # Vulnerabilidades críticas
        if any(critical in line_lower for critical in [
            'cve-2024-38472', 'cve-2024-39573', 'cve-2024-38477',
            'ssrf', 'denial of service', 'rce'
        ]):
            return 'CRITICAL'
        
        # Vulnerabilidades altas
        elif any(high in line_lower for high in [
            'cve-2024-38476', 'cve-2024-38475', 'internal redirect',
            'proxy handler', 'response splitting'
        ]):
            return 'HIGH'
        
        # Vulnerabilidades medias
        elif any(medium in line_lower for medium in [
            'cve-2024-38474', 'cve-2024-38473', 'information disclosure',
            'encoding problem', 'exposed endpoint'
        ]):
            return 'MEDIUM'
        
        # Por defecto
        else:
            return 'LOW'
    
    def _extract_cve_from_line(self, line: str) -> str:
        """Extrae CVE ID de una línea"""
        cve_match = re.search(r'CVE-\d{4}-\d+', line, re.IGNORECASE)
        return cve_match.group(0) if cve_match else 'N/A'
    
    def _determine_exploitation_status(self, line: str) -> str:
        """Determina el estado de explotación"""
        line_lower = line.lower()
        
        if any(confirmed in line_lower for confirmed in [
            'successful', 'exploited', 'confirmed', 'vulnerable'
        ]):
            return 'Confirmed'
        elif any(potential in line_lower for potential in [
            'potential', 'possible', 'likely'
        ]):
            return 'Potential'
        else:
            return 'Unknown'
    
    def get_supported_cves(self) -> List[str]:
        """Obtiene la lista de CVEs soportados por la herramienta"""
        return [
            'CVE-2024-38472',  # Apache HTTP Server on Windows UNC SSRF
            'CVE-2024-39573',  # mod_rewrite proxy handler substitution
            'CVE-2024-38477',  # Crash resulting in Denial of Service in mod_proxy
            'CVE-2024-38476',  # Exploitable backend application output causing internal redirects
            'CVE-2024-38475',  # mod_rewrite weakness with filesystem path matching
            'CVE-2024-38474',  # Weakness with encoded question marks in backreferences
            'CVE-2024-38473',  # mod_proxy proxy encoding problem
            'CVE-2023-38709'   # HTTP response splitting
        ]
    
    def get_tested_endpoints(self) -> List[str]:
        """Obtiene la lista de endpoints que prueba la herramienta"""
        return [
            'php-info.php',
            'xmlrpc.php',
            'adminer.php',
            'bin/cron.php',
            'cache/index.tpl.php',
            'cgi-bin/redir.cgi'
        ] 