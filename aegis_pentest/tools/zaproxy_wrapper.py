"""
Wrapper para OWASP ZAP - Web Application Security Testing
"""
import json
import logging
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class ZapResult:
    """Resultado de un escaneo con ZAP"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    spider_results: List[str]
    scan_stats: Dict[str, Any]
    raw_output: str


class ZapWrapper:
    """Wrapper para la herramienta OWASP ZAP"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('zaproxy')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si ZAP está disponible"""
        return self.config.is_tool_available('zaproxy')
    
    def should_run_against_target(self, target: str, target_type: str, nmap_result=None) -> bool:
        """Determina si ZAP debe ejecutarse contra el target"""
        # Solo ejecutar en targets web
        if target_type not in ['url', 'domain']:
            return False
        
        # Si tenemos resultados de nmap, verificar puertos web
        if nmap_result and hasattr(nmap_result, 'ports'):
            web_ports = []
            for port_info in nmap_result.ports:
                if (port_info.get('state') == 'open' and 
                    port_info.get('port') in [80, 443, 8080, 8443, 3000, 5000, 8000, 9000]):
                    web_ports.append(port_info.get('port'))
            
            if not web_ports:
                self.logger.info("No se detectaron puertos web abiertos - saltando ZAP")
                return False
        
        return True
    
    async def quick_scan(self, target: str) -> ZapResult:
        """Escaneo rápido con ZAP usando baseline scan"""
        if not self.is_available():
            raise RuntimeError("OWASP ZAP no está disponible")
        
        self.logger.info(f"Iniciando escaneo rápido ZAP de {target}")
        
        # Preparar URL base
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        # Comando para baseline scan
        cmd = [
            self.tool_config.get('path', 'zap-baseline.py'),
            '-t', target,
            '-J', '-',  # Output JSON a stdout
            '-m', '5',  # 5 minutos máximo
            '-z', '-config api.disablekey=true'  # Deshabilitar API key
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="zaproxy",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 600)
            )
            
            # ZAP baseline puede retornar códigos no-zero aunque funcione
            vulnerabilities = []
            spider_results = []
            
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            
            # Intentar parsear JSON si está disponible
            try:
                if stdout and stdout.strip():
                    results = json.loads(stdout)
                    vulnerabilities = self._parse_zap_alerts(results)
            except json.JSONDecodeError:
                # Si no hay JSON, parsear output de texto
                vulnerabilities = self._parse_text_output(stdout + stderr)
            
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'target': target,
                'scan_type': 'baseline'
            }
            
            result = ZapResult(
                target=target,
                vulnerabilities=vulnerabilities,
                spider_results=spider_results,
                scan_stats=scan_stats,
                raw_output=stdout + stderr
            )
            
            self.logger.info(f"Escaneo ZAP completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en ZAP: {str(e)}")
            raise
    
    async def full_scan(self, target: str) -> ZapResult:
        """Escaneo completo con ZAP incluyendo spider y active scan"""
        if not self.is_available():
            raise RuntimeError("OWASP ZAP no está disponible")
        
        self.logger.info(f"Iniciando escaneo completo ZAP de {target}")
        
        # Preparar URL base
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        # Comando para full scan
        cmd = [
            self.tool_config.get('path', 'zap-full-scan.py'),
            '-t', target,
            '-J', '-',  # Output JSON a stdout
            '-m', '10',  # 10 minutos máximo
            '-z', '-config api.disablekey=true'  # Deshabilitar API key
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="zaproxy",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 900)
            )
            
            vulnerabilities = []
            spider_results = []
            
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            
            # Intentar parsear JSON si está disponible
            try:
                if stdout and stdout.strip():
                    results = json.loads(stdout)
                    vulnerabilities = self._parse_zap_alerts(results)
                    spider_results = self._parse_spider_results(results)
            except json.JSONDecodeError:
                vulnerabilities = self._parse_text_output(stdout + stderr)
            
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'spider_urls': len(spider_results),
                'target': target,
                'scan_type': 'full'
            }
            
            result = ZapResult(
                target=target,
                vulnerabilities=vulnerabilities,
                spider_results=spider_results,
                scan_stats=scan_stats,
                raw_output=stdout + stderr
            )
            
            self.logger.info(f"Escaneo ZAP completo: {len(vulnerabilities)} vulnerabilidades, {len(spider_results)} URLs")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en ZAP completo: {str(e)}")
            raise
    
    def _parse_zap_alerts(self, results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Parsea las alertas de ZAP desde JSON"""
        vulnerabilities = []
        
        for site in results.get('site', []):
            for alert in site.get('alerts', []):
                vuln = {
                    'id': alert.get('pluginid', 'N/A'),
                    'severity': self._normalize_severity(alert.get('riskdesc', 'Unknown')),
                    'port': 'N/A',
                    'description': alert.get('name', 'Sin descripción')[:100],
                    'type': 'zap',
                    'confidence': alert.get('confidence', 'Unknown'),
                    'url': alert.get('url', ''),
                    'param': alert.get('param', ''),
                    'attack': alert.get('attack', ''),
                    'evidence': alert.get('evidence', ''),
                    'solution': alert.get('solution', ''),
                    'reference': alert.get('reference', ''),
                    'raw_data': alert
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _parse_spider_results(self, results: Dict[str, Any]) -> List[str]:
        """Parsea los resultados del spider de ZAP"""
        urls = []
        
        for site in results.get('site', []):
            for url_info in site.get('urls', []):
                if isinstance(url_info, str):
                    urls.append(url_info)
                elif isinstance(url_info, dict):
                    urls.append(url_info.get('url', ''))
        
        return urls
    
    def _parse_text_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea output de texto cuando no hay JSON disponible"""
        vulnerabilities = []
        
        lines = output.splitlines()
        current_vuln = {}
        
        for line in lines:
            line = line.strip()
            
            # Detectar alertas comunes en output de texto
            if any(keyword in line.lower() for keyword in ['high', 'medium', 'low', 'info']):
                if 'risk' in line.lower() or 'severity' in line.lower():
                    if current_vuln:
                        vulnerabilities.append(current_vuln)
                    
                    current_vuln = {
                        'id': 'text_parsed',
                        'severity': self._extract_severity_from_line(line),
                        'port': 'N/A',
                        'description': line[:100],
                        'type': 'zap',
                        'confidence': 'Unknown',
                        'raw_data': {'text_line': line}
                    }
        
        if current_vuln:
            vulnerabilities.append(current_vuln)
        
        return vulnerabilities
    
    def _normalize_severity(self, risk_desc: str) -> str:
        """Normaliza la severidad de ZAP al formato estándar"""
        risk_lower = risk_desc.lower()
        
        if 'high' in risk_lower:
            return 'HIGH'
        elif 'medium' in risk_lower:
            return 'MEDIUM'
        elif 'low' in risk_lower:
            return 'LOW'
        elif 'info' in risk_lower:
            return 'INFO'
        else:
            return 'UNKNOWN'
    
    def _extract_severity_from_line(self, line: str) -> str:
        """Extrae severidad de una línea de texto"""
        line_lower = line.lower()
        
        if 'high' in line_lower:
            return 'HIGH'
        elif 'medium' in line_lower:
            return 'MEDIUM'
        elif 'low' in line_lower:
            return 'LOW'
        elif 'info' in line_lower:
            return 'INFO'
        else:
            return 'UNKNOWN'
    
    def get_scan_types(self) -> Dict[str, str]:
        """Obtiene los tipos de escaneo disponibles"""
        return {
            'baseline': 'Escaneo básico rápido (5 min)',
            'full': 'Escaneo completo con spider y active scan (10+ min)',
            'api': 'Escaneo específico para APIs REST'
        } 