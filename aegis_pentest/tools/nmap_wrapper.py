"""
Wrapper para Nmap - Escaneo de puertos y servicios
Integrado con sistema de logging en tiempo real
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

try:
    import nmap
    NMAP_AVAILABLE = True
    NMAP_IMPORT_ERROR = None
except ImportError as e:
    NMAP_AVAILABLE = False
    NMAP_IMPORT_ERROR = str(e)

from aegis_pentest.utils.helpers import parse_ports, merge_port_ranges
from aegis_pentest.utils.process_runner import get_process_runner, ProcessResult
from aegis_pentest.utils.logger import get_logger


@dataclass
class NmapResult:
    """Resultado de un escaneo Nmap"""
    host: str
    state: str
    ports: List[Dict[str, Any]]
    services: List[Dict[str, Any]]
    os_info: Dict[str, Any]
    script_results: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str
    process_result: Optional[ProcessResult] = None


class NmapWrapper:
    """Wrapper para la herramienta Nmap con logging en tiempo real"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nmap')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
        
        # Inicializar python-nmap si está disponible
        self.nm = None
        self._init_error = None
        
        if NMAP_AVAILABLE:
            try:
                self.nm = nmap.PortScanner()
                self.logger.info("NmapWrapper inicializado correctamente")
            except Exception as e:
                self._init_error = f"Error inicializando PortScanner: {str(e)}"
                self.logger.error(self._init_error)
        else:
            self._init_error = f"python-nmap no disponible: {NMAP_IMPORT_ERROR}"
            self.logger.error(self._init_error)
    
    def is_available(self) -> bool:
        """Verifica si Nmap está disponible"""
        # Verificar si el binario nmap está disponible
        if not self.config.is_tool_available('nmap'):
            return False
        
        # Verificar si python-nmap está disponible
        if not NMAP_AVAILABLE:
            return False
            
        # Verificar si no hubo errores de inicialización
        return self._init_error is None
    
    def get_availability_status(self) -> Dict[str, Any]:
        """Obtiene el estado detallado de disponibilidad"""
        return {
            "binary_available": self.config.is_tool_available('nmap'),
            "python_nmap_available": NMAP_AVAILABLE,
            "python_nmap_error": NMAP_IMPORT_ERROR,
            "init_error": self._init_error,
            "fully_available": self.is_available()
        }
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo básico de puertos con logging en tiempo real"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Preparar comando
        command = [
            'nmap',
            '-sS',  # SYN stealth scan
            '-sV',  # Detección de versiones
            '-p', ports,
            '-v',   # Verbose para mejor logging
            target
        ]
        
        # Ejecutar con logging en tiempo real
        process_result = await self.process_runner.run_tool_async(
            tool_name="nmap",
            command=command,
            target=target,
            timeout=self.tool_config.get('timeout', 300)
        )
        
        # Parsear resultado usando python-nmap para estructura
        if process_result.success:
            try:
                # Usar python-nmap para parsear el resultado
                arguments = f"-sS -sV -p {ports}"
                loop = asyncio.get_event_loop()
                nmap_result = await loop.run_in_executor(
                    None, 
                    self.nm.scan, 
                    target, 
                    arguments
                )
                
                result = self._parse_nmap_result(target, nmap_result)
                result.process_result = process_result
                result.raw_output = "\n".join(process_result.stdout_lines)
                
                return result
                
            except Exception as e:
                self.logger.error(f"Error parseando resultado nmap: {str(e)}")
                # Crear resultado básico desde el output del proceso
                return self._create_basic_result(target, process_result)
        else:
            raise RuntimeError(f"Nmap falló: {process_result.error_message}")
    
    async def comprehensive_scan(self, target: str, ports: str = "1-65535") -> NmapResult:
        """Escaneo comprensivo con detección de OS y scripts"""
        if not self.is_available():
            # Proporcionar información detallada sobre por qué no está disponible
            status = self.get_availability_status()
            error_details = []
            
            if not status["binary_available"]:
                error_details.append("Binario nmap no encontrado en PATH")
            
            if not status["python_nmap_available"]:
                error_details.append(f"python-nmap no disponible: {status['python_nmap_error']}")
            
            if status["init_error"]:
                error_details.append(f"Error de inicialización: {status['init_error']}")
            
            error_msg = "Nmap no está disponible: " + "; ".join(error_details)
            raise RuntimeError(error_msg)
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Comando comprensivo
        command = [
            'nmap',
            '-sS',  # SYN stealth scan  
            '-sV',  # Detección de versiones
            '-sC',  # Scripts por defecto
            '-O',   # Detección de OS
            '-A',   # Aggressive scan
            '-p', ports,
            '-v',   # Verbose
            '--version-all',
            target
        ]
        
        try:
            # Ejecutar con logging en tiempo real
            process_result = await self.process_runner.run_tool_async(
                tool_name="nmap",
                command=command,
                target=target,
                timeout=self.tool_config.get('timeout', 600)  # Más tiempo para escaneo comprensivo
            )
            
            if process_result.success:
                # Si el proceso fue exitoso, usar python-nmap para parsear el resultado
                if self.nm is not None:
                    try:
                        arguments = f"-sS -sV -sC -O -A -p {ports} --version-all"
                        loop = asyncio.get_event_loop()
                        
                        self.logger.info("Parseando resultado con python-nmap...")
                        
                        # Ejecutar python-nmap de forma asíncrona
                        nmap_result = await loop.run_in_executor(
                            None,
                            self.nm.scan,
                            target,
                            arguments
                        )
                        
                        # Parsear resultado
                        result = self._parse_nmap_result(target, nmap_result)
                        result.process_result = process_result
                        result.raw_output = "\n".join(process_result.stdout_lines)
                        
                        self.logger.info(f"Escaneo comprensivo completado exitosamente para {target}")
                        return result
                        
                    except Exception as e:
                        self.logger.error(f"Error parseando resultado nmap comprensivo: {str(e)}")
                        
                        # En caso de error de parsing, crear resultado básico desde el output del proceso
                        self.logger.info("Creando resultado básico desde output del proceso...")
                        result = self._create_basic_result(target, process_result)
                        result.raw_output = "\n".join(process_result.stdout_lines)
                        return result
                else:
                    # Si no hay python-nmap disponible, crear resultado básico
                    self.logger.warning("python-nmap no disponible, creando resultado básico...")
                    result = self._create_basic_result(target, process_result)
                    result.raw_output = "\n".join(process_result.stdout_lines)
                    return result
            else:
                # El proceso falló
                error_msg = f"Nmap comprensivo falló: {process_result.error_message}"
                
                # Agregar detalles del stderr si está disponible
                if process_result.stderr_lines:
                    stderr_output = "\n".join(process_result.stderr_lines)
                    error_msg += f"\nStderr: {stderr_output}"
                
                # Log del error detallado
                self.logger.error(error_msg)
                
                # Si el comando usado sudo, mostrar información específica
                if process_result.used_sudo:
                    error_msg += "\nNota: El comando se ejecutó con privilegios sudo"
                
                raise RuntimeError(error_msg)
                
        except Exception as e:
            # Capturar cualquier error inesperado
            import traceback
            full_traceback = traceback.format_exc()
            
            error_msg = f"Error en escaneo comprensivo de nmap: {str(e)}"
            self.logger.error(f"{error_msg}\nTraceback: {full_traceback}")
            
            # Re-lanzar la excepción con más contexto
            raise RuntimeError(f"{error_msg}\nVerifica los logs para más detalles") from e
    
    async def stealth_scan(self, target: str, ports: str = "80,443,8080,8443") -> NmapResult:
        """Escaneo sigiloso para evadir detección"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo sigiloso de {target}")
        
        command = [
            'nmap',
            '-sS',          # SYN stealth scan
            '-T2',          # Timing template (polite)
            '-f',           # Fragment packets
            '--source-port', '53',  # Use DNS source port
            '-p', ports,
            '-v',
            target
        ]
        
        process_result = await self.process_runner.run_tool_async(
            tool_name="nmap",
            command=command,
            target=target,
            timeout=self.tool_config.get('timeout', 400)
        )
        
        if process_result.success:
            try:
                arguments = f"-sS -T2 -f --source-port 53 -p {ports}"
                loop = asyncio.get_event_loop()
                nmap_result = await loop.run_in_executor(
                    None,
                    self.nm.scan,
                    target,
                    arguments
                )
                
                result = self._parse_nmap_result(target, nmap_result)
                result.process_result = process_result
                result.raw_output = "\n".join(process_result.stdout_lines)
                
                return result
                
            except Exception as e:
                self.logger.error(f"Error parseando resultado nmap sigiloso: {str(e)}")
                return self._create_basic_result(target, process_result)
        else:
            raise RuntimeError(f"Nmap sigiloso falló: {process_result.error_message}")
    
    async def udp_scan(self, target: str, ports: str = "53,67,68,123,161") -> NmapResult:
        """Escaneo UDP de puertos comunes"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo UDP de {target}")
        
        # Argumentos para escaneo UDP
        arguments = f"-sU -sV -p {ports}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo UDP: {str(e)}")
            raise
    
    async def vulnerability_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo de vulnerabilidades usando scripts NSE"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Scripts de vulnerabilidades
        vuln_scripts = "vuln,auth,brute,discovery,dos,exploit,external,fuzzer,intrusive,malware,safe,version"
        arguments = f"-sS -sV -p {ports} --script {vuln_scripts}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo de vulnerabilidades: {str(e)}")
            raise
    
    async def custom_scan(self, target: str, arguments: str) -> NmapResult:
        """Escaneo personalizado con argumentos específicos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo personalizado de {target}: {arguments}")
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo personalizado: {str(e)}")
            raise
    
    def _parse_nmap_result(self, target: str, scan_result: Dict) -> NmapResult:
        """Parsea el resultado de Nmap a formato estructurado"""
        host_info = scan_result['scan'].get(target, {})
        
        # Estado del host
        host_state = host_info.get('status', {}).get('state', 'unknown')
        
        # Información de puertos
        ports_info = []
        services_info = []
        
        tcp_ports = host_info.get('tcp', {})
        udp_ports = host_info.get('udp', {})
        
        # Procesar puertos TCP
        for port, info in tcp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'tcp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'tcp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Procesar puertos UDP
        for port, info in udp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'udp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'udp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Información del OS
        os_info = {}
        if 'osmatch' in host_info:
            os_matches = host_info['osmatch']
            if os_matches:
                best_match = max(os_matches, key=lambda x: int(x.get('accuracy', 0)))
                os_info = {
                    'name': best_match.get('name', 'Unknown'),
                    'accuracy': best_match.get('accuracy', '0'),
                    'line': best_match.get('line', ''),
                    'osclass': best_match.get('osclass', [])
                }
        
        # Resultados de scripts
        script_results = []
        for port_info in [tcp_ports, udp_ports]:
            for port, info in port_info.items():
                if 'script' in info:
                    for script_name, script_output in info['script'].items():
                        script_results.append({
                            'port': port,
                            'script': script_name,
                            'output': script_output
                        })
        
        # Estadísticas del escaneo
        scan_stats = {
            'elapsed': scan_result.get('nmap', {}).get('stats', {}).get('elapsed', ''),
            'timestr': scan_result.get('nmap', {}).get('stats', {}).get('timestr', ''),
            'up_hosts': scan_result.get('nmap', {}).get('stats', {}).get('uphosts', ''),
            'down_hosts': scan_result.get('nmap', {}).get('stats', {}).get('downhosts', ''),
            'total_hosts': scan_result.get('nmap', {}).get('stats', {}).get('totalhosts', '')
        }
        
        return NmapResult(
            host=target,
            state=host_state,
            ports=ports_info,
            services=services_info,
            os_info=os_info,
            script_results=script_results,
            scan_stats=scan_stats,
            raw_output=str(scan_result),
            process_result=None
        )
    
    def _extract_ports_from_args(self, arguments: str) -> Optional[str]:
        """Extrae la especificación de puertos de los argumentos"""
        import re
        
        # Buscar patrón -p seguido de especificación de puertos
        port_match = re.search(r'-p\s+([0-9,-]+)', arguments)
        if port_match:
            return port_match.group(1)
        
        return None
    
    async def ping_sweep(self, network: str) -> List[str]:
        """Realiza un ping sweep para descubrir hosts activos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Realizando ping sweep en {network}")
        
        try:
            arguments = "-sn"  # Ping scan only
            
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                network,
                arguments=arguments
            )
            
            # Extraer hosts activos
            active_hosts = []
            for host in result['scan']:
                if result['scan'][host]['status']['state'] == 'up':
                    active_hosts.append(host)
            
            return active_hosts
            
        except Exception as e:
            self.logger.error(f"Error en ping sweep: {str(e)}")
            raise
    
    def get_scan_templates(self) -> Dict[str, Dict[str, str]]:
        """Obtiene plantillas de escaneo predefinidas"""
        return {
            'quick': {
                'name': 'Escaneo Rápido',
                'description': 'Escaneo rápido de puertos comunes',
                'arguments': '-T4 -F'
            },
            'intense': {
                'name': 'Escaneo Intenso',
                'description': 'Escaneo completo con detección de servicios y OS',
                'arguments': '-T4 -A -v'
            },
            'comprehensive': {
                'name': 'Escaneo Comprensivo',
                'description': 'Escaneo de todos los puertos con scripts',
                'arguments': '-sS -sU -T4 -A -v -p 1-65535'
            },
            'stealth': {
                'name': 'Escaneo Sigiloso',
                'description': 'Escaneo lento para evadir detección',
                'arguments': '-sS -T2 -f'
            },
            'vulnerability': {
                'name': 'Escaneo de Vulnerabilidades',
                'description': 'Escaneo enfocado en detectar vulnerabilidades',
                'arguments': '-sV --script vuln'
            }
        }

    def _create_basic_result(self, target: str, process_result: ProcessResult) -> NmapResult:
        """Crea un resultado básico desde el output del proceso"""
        raw_output = "\n".join(process_result.stdout_lines)
        
        # Extraer información desde el output de texto
        ports = self._parse_ports_from_text(raw_output)
        services = self._extract_services_from_text(raw_output)
        os_info = self._extract_os_from_text(raw_output)
        
        return NmapResult(
            host=target,
            state='up' if ports else 'unknown',
            ports=ports,
            services=services,
            os_info=os_info,
            script_results=[],
            scan_stats=self._extract_stats_from_text(raw_output),
            raw_output=raw_output,
            process_result=process_result
        )
    
    def _parse_ports_from_text(self, output: str) -> List[Dict[str, Any]]:
        """Extrae información de puertos desde el output de texto de nmap"""
        ports = []
        
        lines = output.splitlines()
        for line in lines:
            # Buscar líneas que contengan información de puertos
            # Formato: "22/tcp   open  ssh     OpenSSH 8.2p1"
            # Formato filtrado: "5/tcp filtered rje"  
            # Formato básico: "80/tcp open"
            import re
            
            # Regex más flexible - hacer servicio opcional
            port_pattern = r'(\d+)/(tcp|udp)\s+(open|closed|filtered)(?:\s+(\S+))?(?:\s+(.+))?'
            match = re.search(port_pattern, line.strip())
            
            if match:
                port_num = int(match.group(1))
                protocol = match.group(2)
                state = match.group(3)
                service = match.group(4) or 'unknown'
                version_info = match.group(5) or ''
                
                port_data = {
                    'port': port_num,
                    'protocol': protocol,
                    'state': state,
                    'service': service,
                    'version': version_info.strip(),
                    'product': '',
                    'extrainfo': '',
                    'conf': '',
                    'method': 'text_parsed',
                    'reason': ''
                }
                ports.append(port_data)
                
        # También buscar puertos mencionados en traceroute para inferir conectividad
        for line in lines:
            if 'TRACEROUTE' in line and 'using port' in line:
                # Extraer puerto del traceroute: "TRACEROUTE (using port 80/tcp)"
                traceroute_pattern = r'using port (\d+)/(tcp|udp)'
                match = re.search(traceroute_pattern, line)
                if match:
                    port_num = int(match.group(1))
                    protocol = match.group(2)
                    
                    # Solo agregarlo si no está ya en la lista
                    if not any(p['port'] == port_num and p['protocol'] == protocol for p in ports):
                        port_data = {
                            'port': port_num,
                            'protocol': protocol,
                            'state': 'open',  # Si se usa para traceroute, está accesible
                            'service': 'http' if port_num == 80 else 'https' if port_num == 443 else 'unknown',
                            'version': '',
                            'product': '',
                            'extrainfo': 'inferred from traceroute',
                            'conf': '',
                            'method': 'traceroute_inferred',
                            'reason': 'traceroute'
                        }
                        ports.append(port_data)
        
        return ports
    
    def _extract_services_from_text(self, output: str) -> List[Dict[str, Any]]:
        """Extrae información de servicios desde el output de texto"""
        services = []
        
        lines = output.splitlines()
        for line in lines:
            import re
            
            # Buscar líneas de servicios abiertos con información detallada
            service_pattern = r'(\d+)/(tcp|udp)\s+open\s+(\S+)(?:\s+(.+))?'
            match = re.match(service_pattern, line.strip())
            
            if match:
                port_num = int(match.group(1))
                protocol = match.group(2)
                service_name = match.group(3)
                version_info = match.group(4) or ''
                
                service_data = {
                    'port': port_num,
                    'protocol': protocol,
                    'service': service_name,
                    'version': version_info.strip(),
                    'banner': version_info.strip()
                }
                services.append(service_data)
        
        return services
    
    def _extract_os_from_text(self, output: str) -> Dict[str, Any]:
        """Extrae información del sistema operativo desde el output de texto"""
        os_info = {}
        
        lines = output.splitlines()
        for i, line in enumerate(lines):
            if 'OS details:' in line or 'Running:' in line:
                # Extraer información del OS
                os_line = line.split(':', 1)
                if len(os_line) > 1:
                    os_info = {
                        'name': os_line[1].strip(),
                        'accuracy': 'unknown',
                        'line': line.strip(),
                        'osclass': []
                    }
                break
            elif 'No exact OS matches for host' in line:
                # Buscar líneas siguientes con información de OS
                for j in range(i+1, min(i+5, len(lines))):
                    if lines[j].strip() and not lines[j].startswith('Network'):
                        os_info = {
                            'name': lines[j].strip(),
                            'accuracy': 'low',
                            'line': lines[j].strip(),
                            'osclass': []
                        }
                        break
                break
        
        return os_info
    
    def _extract_stats_from_text(self, output: str) -> Dict[str, Any]:
        """Extrae estadísticas desde el output de texto"""
        stats = {}
        
        lines = output.splitlines()
        for line in lines:
            if 'Nmap done:' in line:
                # Extraer información de tiempo
                import re
                time_pattern = r'scanned in ([\d.]+) seconds'
                match = re.search(time_pattern, line)
                if match:
                    stats['elapsed'] = match.group(1)
                
                # Extraer información de hosts
                hosts_pattern = r'(\d+) IP address(?:es)? \((\d+) host(?:s)? up\)'
                hosts_match = re.search(hosts_pattern, line)
                if hosts_match:
                    stats['total_hosts'] = hosts_match.group(1)
                    stats['up_hosts'] = hosts_match.group(2)
                    stats['down_hosts'] = str(int(hosts_match.group(1)) - int(hosts_match.group(2)))
                break
        
        return stats 