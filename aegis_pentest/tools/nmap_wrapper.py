"""
Wrapper para Nmap - Escaneo de puertos y servicios
Integrado con sistema de logging en tiempo real
"""

import nmap
import asyncio
import logging
import subprocess
import shlex
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from pathlib import Path

from aegis_pentest.utils.helpers import parse_ports, merge_port_ranges
from aegis_pentest.utils.process_runner import get_process_runner, ProcessResult
from aegis_pentest.utils.logger import get_logger


@dataclass
class NmapResult:
    """Resultado de un escaneo Nmap"""
    host: str
    state: str
    ports: List[Dict[str, Any]]
    services: List[Dict[str, Any]]
    os_info: Dict[str, Any]
    script_results: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str
    process_result: Optional[ProcessResult] = None


class NmapWrapper:
    """Wrapper para la herramienta Nmap con logging en tiempo real"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nmap')
        self.logger = logging.getLogger(__name__)
        self.nm = nmap.PortScanner()
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Nmap está disponible"""
        return self.config.is_tool_available('nmap')
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo básico de puertos con logging en tiempo real"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Preparar comando
        command = [
            'nmap',
            '-sS',  # SYN stealth scan
            '-sV',  # Detección de versiones
            '-p', ports,
            '-v',   # Verbose para mejor logging
            target
        ]
        
        # Ejecutar con logging en tiempo real
        process_result = await self.process_runner.run_tool_async(
            tool_name="nmap",
            command=command,
            target=target,
            timeout=self.tool_config.get('timeout', 300)
        )
        
        # Parsear resultado usando python-nmap para estructura
        if process_result.success:
            try:
                # Usar python-nmap para parsear el resultado
                arguments = f"-sS -sV -p {ports}"
                loop = asyncio.get_event_loop()
                nmap_result = await loop.run_in_executor(
                    None, 
                    self.nm.scan, 
                    target, 
                    arguments
                )
                
                result = self._parse_nmap_result(target, nmap_result)
                result.process_result = process_result
                result.raw_output = "\n".join(process_result.stdout_lines)
                
                return result
                
            except Exception as e:
                self.logger.error(f"Error parseando resultado nmap: {str(e)}")
                # Crear resultado básico desde el output del proceso
                return self._create_basic_result(target, process_result)
        else:
            raise RuntimeError(f"Nmap falló: {process_result.error_message}")
    
    async def comprehensive_scan(self, target: str, ports: str = "1-65535") -> NmapResult:
        """Escaneo comprensivo con detección de OS y scripts"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Comando comprensivo
        command = [
            'nmap',
            '-sS',  # SYN stealth scan  
            '-sV',  # Detección de versiones
            '-sC',  # Scripts por defecto
            '-O',   # Detección de OS
            '-A',   # Aggressive scan
            '-p', ports,
            '-v',   # Verbose
            '--version-all',
            target
        ]
        
        process_result = await self.process_runner.run_tool_async(
            tool_name="nmap",
            command=command,
            target=target,
            timeout=self.tool_config.get('timeout', 600)  # Más tiempo para escaneo comprensivo
        )
        
        if process_result.success:
            try:
                arguments = f"-sS -sV -sC -O -A -p {ports} --version-all"
                loop = asyncio.get_event_loop()
                nmap_result = await loop.run_in_executor(
                    None,
                    self.nm.scan,
                    target,
                    arguments
                )
                
                result = self._parse_nmap_result(target, nmap_result)
                result.process_result = process_result
                result.raw_output = "\n".join(process_result.stdout_lines)
                
                return result
                
            except Exception as e:
                self.logger.error(f"Error parseando resultado nmap comprensivo: {str(e)}")
                return self._create_basic_result(target, process_result)
        else:
            raise RuntimeError(f"Nmap comprensivo falló: {process_result.error_message}")
    
    async def stealth_scan(self, target: str, ports: str = "80,443,8080,8443") -> NmapResult:
        """Escaneo sigiloso para evadir detección"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo sigiloso de {target}")
        
        command = [
            'nmap',
            '-sS',          # SYN stealth scan
            '-T2',          # Timing template (polite)
            '-f',           # Fragment packets
            '--source-port', '53',  # Use DNS source port
            '-p', ports,
            '-v',
            target
        ]
        
        process_result = await self.process_runner.run_tool_async(
            tool_name="nmap",
            command=command,
            target=target,
            timeout=self.tool_config.get('timeout', 400)
        )
        
        if process_result.success:
            try:
                arguments = f"-sS -T2 -f --source-port 53 -p {ports}"
                loop = asyncio.get_event_loop()
                nmap_result = await loop.run_in_executor(
                    None,
                    self.nm.scan,
                    target,
                    arguments
                )
                
                result = self._parse_nmap_result(target, nmap_result)
                result.process_result = process_result
                result.raw_output = "\n".join(process_result.stdout_lines)
                
                return result
                
            except Exception as e:
                self.logger.error(f"Error parseando resultado nmap sigiloso: {str(e)}")
                return self._create_basic_result(target, process_result)
        else:
            raise RuntimeError(f"Nmap sigiloso falló: {process_result.error_message}")
    
    async def udp_scan(self, target: str, ports: str = "53,67,68,123,161") -> NmapResult:
        """Escaneo UDP de puertos comunes"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo UDP de {target}")
        
        # Argumentos para escaneo UDP
        arguments = f"-sU -sV -p {ports}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo UDP: {str(e)}")
            raise
    
    async def vulnerability_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo de vulnerabilidades usando scripts NSE"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Scripts de vulnerabilidades
        vuln_scripts = "vuln,auth,brute,discovery,dos,exploit,external,fuzzer,intrusive,malware,safe,version"
        arguments = f"-sS -sV -p {ports} --script {vuln_scripts}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo de vulnerabilidades: {str(e)}")
            raise
    
    async def custom_scan(self, target: str, arguments: str) -> NmapResult:
        """Escaneo personalizado con argumentos específicos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo personalizado de {target}: {arguments}")
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo personalizado: {str(e)}")
            raise
    
    def _parse_nmap_result(self, target: str, scan_result: Dict) -> NmapResult:
        """Parsea el resultado de Nmap a formato estructurado"""
        host_info = scan_result['scan'].get(target, {})
        
        # Estado del host
        host_state = host_info.get('status', {}).get('state', 'unknown')
        
        # Información de puertos
        ports_info = []
        services_info = []
        
        tcp_ports = host_info.get('tcp', {})
        udp_ports = host_info.get('udp', {})
        
        # Procesar puertos TCP
        for port, info in tcp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'tcp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'tcp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Procesar puertos UDP
        for port, info in udp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'udp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'udp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Información del OS
        os_info = {}
        if 'osmatch' in host_info:
            os_matches = host_info['osmatch']
            if os_matches:
                best_match = max(os_matches, key=lambda x: int(x.get('accuracy', 0)))
                os_info = {
                    'name': best_match.get('name', 'Unknown'),
                    'accuracy': best_match.get('accuracy', '0'),
                    'line': best_match.get('line', ''),
                    'osclass': best_match.get('osclass', [])
                }
        
        # Resultados de scripts
        script_results = []
        for port_info in [tcp_ports, udp_ports]:
            for port, info in port_info.items():
                if 'script' in info:
                    for script_name, script_output in info['script'].items():
                        script_results.append({
                            'port': port,
                            'script': script_name,
                            'output': script_output
                        })
        
        # Estadísticas del escaneo
        scan_stats = {
            'elapsed': scan_result.get('nmap', {}).get('stats', {}).get('elapsed', ''),
            'timestr': scan_result.get('nmap', {}).get('stats', {}).get('timestr', ''),
            'up_hosts': scan_result.get('nmap', {}).get('stats', {}).get('uphosts', ''),
            'down_hosts': scan_result.get('nmap', {}).get('stats', {}).get('downhosts', ''),
            'total_hosts': scan_result.get('nmap', {}).get('stats', {}).get('totalhosts', '')
        }
        
        return NmapResult(
            host=target,
            state=host_state,
            ports=ports_info,
            services=services_info,
            os_info=os_info,
            script_results=script_results,
            scan_stats=scan_stats,
            raw_output=str(scan_result),
            process_result=None
        )
    
    def _extract_ports_from_args(self, arguments: str) -> Optional[str]:
        """Extrae la especificación de puertos de los argumentos"""
        import re
        
        # Buscar patrón -p seguido de especificación de puertos
        port_match = re.search(r'-p\s+([0-9,-]+)', arguments)
        if port_match:
            return port_match.group(1)
        
        return None
    
    async def ping_sweep(self, network: str) -> List[str]:
        """Realiza un ping sweep para descubrir hosts activos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Realizando ping sweep en {network}")
        
        try:
            arguments = "-sn"  # Ping scan only
            
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                network,
                arguments=arguments
            )
            
            # Extraer hosts activos
            active_hosts = []
            for host in result['scan']:
                if result['scan'][host]['status']['state'] == 'up':
                    active_hosts.append(host)
            
            return active_hosts
            
        except Exception as e:
            self.logger.error(f"Error en ping sweep: {str(e)}")
            raise
    
    def get_scan_templates(self) -> Dict[str, Dict[str, str]]:
        """Obtiene plantillas de escaneo predefinidas"""
        return {
            'quick': {
                'name': 'Escaneo Rápido',
                'description': 'Escaneo rápido de puertos comunes',
                'arguments': '-T4 -F'
            },
            'intense': {
                'name': 'Escaneo Intenso',
                'description': 'Escaneo completo con detección de servicios y OS',
                'arguments': '-T4 -A -v'
            },
            'comprehensive': {
                'name': 'Escaneo Comprensivo',
                'description': 'Escaneo de todos los puertos con scripts',
                'arguments': '-sS -sU -T4 -A -v -p 1-65535'
            },
            'stealth': {
                'name': 'Escaneo Sigiloso',
                'description': 'Escaneo lento para evadir detección',
                'arguments': '-sS -T2 -f'
            },
            'vulnerability': {
                'name': 'Escaneo de Vulnerabilidades',
                'description': 'Escaneo enfocado en detectar vulnerabilidades',
                'arguments': '-sV --script vuln'
            }
        }

    def _create_basic_result(self, target: str, process_result: ProcessResult) -> NmapResult:
        """Crea un resultado básico desde el output del proceso"""
        return NmapResult(
            host=target,
            state='unknown',
            ports=[],
            services=[],
            os_info={},
            script_results=[],
            scan_stats={},
            raw_output="\n".join(process_result.stdout_lines),
            process_result=process_result
        ) 