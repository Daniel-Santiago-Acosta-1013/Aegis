"""
Wrapper para Nmap - Escaneo de puertos y servicios
"""

import nmap
import asyncio
import logging
import subprocess
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from aegis_pentest.utils.helpers import parse_ports, merge_port_ranges


@dataclass
class NmapResult:
    """Resultado de un escaneo Nmap"""
    host: str
    state: str
    ports: List[Dict[str, Any]]
    services: List[Dict[str, Any]]
    os_info: Dict[str, Any]
    script_results: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class NmapWrapper:
    """Wrapper para la herramienta Nmap"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nmap')
        self.logger = logging.getLogger(__name__)
        self.nm = nmap.PortScanner()
    
    def is_available(self) -> bool:
        """Verifica si Nmap está disponible"""
        return self.config.is_tool_available('nmap')
    
    async def basic_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo básico de puertos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo básico de {target}")
        
        # Configurar argumentos
        arguments = f"-sS -sV -p {ports}"
        
        try:
            # Ejecutar escaneo
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None, 
                self.nm.scan, 
                target, 
                ports, 
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo básico: {str(e)}")
            raise
    
    async def comprehensive_scan(self, target: str, ports: str = "1-65535") -> NmapResult:
        """Escaneo comprensivo con detección de OS y scripts"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo comprensivo de {target}")
        
        # Argumentos para escaneo comprensivo
        arguments = f"-sS -sV -sC -O -A -p {ports} --version-all"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                ports,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo comprensivo: {str(e)}")
            raise
    
    async def stealth_scan(self, target: str, ports: str = "80,443,8080,8443") -> NmapResult:
        """Escaneo sigiloso para evadir detección"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo sigiloso de {target}")
        
        # Argumentos para escaneo sigiloso
        arguments = f"-sS -T2 -f --source-port 53 -p {ports}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                ports,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo sigiloso: {str(e)}")
            raise
    
    async def udp_scan(self, target: str, ports: str = "53,67,68,123,161") -> NmapResult:
        """Escaneo UDP de puertos comunes"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo UDP de {target}")
        
        # Argumentos para escaneo UDP
        arguments = f"-sU -sV -p {ports}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                ports,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo UDP: {str(e)}")
            raise
    
    async def vulnerability_scan(self, target: str, ports: str = "1-1000") -> NmapResult:
        """Escaneo de vulnerabilidades usando scripts NSE"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo de vulnerabilidades de {target}")
        
        # Scripts de vulnerabilidades
        vuln_scripts = "vuln,auth,brute,discovery,dos,exploit,external,fuzzer,intrusive,malware,safe,version"
        arguments = f"-sS -sV -p {ports} --script {vuln_scripts}"
        
        try:
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                ports,
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo de vulnerabilidades: {str(e)}")
            raise
    
    async def custom_scan(self, target: str, arguments: str) -> NmapResult:
        """Escaneo personalizado con argumentos específicos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Iniciando escaneo personalizado de {target}: {arguments}")
        
        try:
            # Extraer puertos de los argumentos si están presentes
            ports = self._extract_ports_from_args(arguments)
            
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                target,
                ports or "",
                arguments
            )
            
            return self._parse_nmap_result(target, result)
            
        except Exception as e:
            self.logger.error(f"Error en escaneo personalizado: {str(e)}")
            raise
    
    def _parse_nmap_result(self, target: str, scan_result: Dict) -> NmapResult:
        """Parsea el resultado de Nmap a formato estructurado"""
        host_info = scan_result['scan'].get(target, {})
        
        # Estado del host
        host_state = host_info.get('status', {}).get('state', 'unknown')
        
        # Información de puertos
        ports_info = []
        services_info = []
        
        tcp_ports = host_info.get('tcp', {})
        udp_ports = host_info.get('udp', {})
        
        # Procesar puertos TCP
        for port, info in tcp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'tcp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'tcp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Procesar puertos UDP
        for port, info in udp_ports.items():
            port_data = {
                'port': port,
                'protocol': 'udp',
                'state': info.get('state'),
                'service': info.get('name', 'unknown'),
                'version': info.get('version', ''),
                'product': info.get('product', ''),
                'extrainfo': info.get('extrainfo', ''),
                'conf': info.get('conf', ''),
                'method': info.get('method', ''),
                'reason': info.get('reason', '')
            }
            ports_info.append(port_data)
            
            if info.get('state') == 'open':
                service_data = {
                    'port': port,
                    'protocol': 'udp',
                    'service': info.get('name', 'unknown'),
                    'version': f"{info.get('product', '')} {info.get('version', '')}".strip(),
                    'banner': info.get('extrainfo', '')
                }
                services_info.append(service_data)
        
        # Información del OS
        os_info = {}
        if 'osmatch' in host_info:
            os_matches = host_info['osmatch']
            if os_matches:
                best_match = max(os_matches, key=lambda x: int(x.get('accuracy', 0)))
                os_info = {
                    'name': best_match.get('name', 'Unknown'),
                    'accuracy': best_match.get('accuracy', '0'),
                    'line': best_match.get('line', ''),
                    'osclass': best_match.get('osclass', [])
                }
        
        # Resultados de scripts
        script_results = []
        for port_info in [tcp_ports, udp_ports]:
            for port, info in port_info.items():
                if 'script' in info:
                    for script_name, script_output in info['script'].items():
                        script_results.append({
                            'port': port,
                            'script': script_name,
                            'output': script_output
                        })
        
        # Estadísticas del escaneo
        scan_stats = {
            'elapsed': scan_result.get('nmap', {}).get('stats', {}).get('elapsed', ''),
            'timestr': scan_result.get('nmap', {}).get('stats', {}).get('timestr', ''),
            'up_hosts': scan_result.get('nmap', {}).get('stats', {}).get('uphosts', ''),
            'down_hosts': scan_result.get('nmap', {}).get('stats', {}).get('downhosts', ''),
            'total_hosts': scan_result.get('nmap', {}).get('stats', {}).get('totalhosts', '')
        }
        
        return NmapResult(
            host=target,
            state=host_state,
            ports=ports_info,
            services=services_info,
            os_info=os_info,
            script_results=script_results,
            scan_stats=scan_stats,
            raw_output=str(scan_result)
        )
    
    def _extract_ports_from_args(self, arguments: str) -> Optional[str]:
        """Extrae la especificación de puertos de los argumentos"""
        import re
        
        # Buscar patrón -p seguido de especificación de puertos
        port_match = re.search(r'-p\s+([0-9,-]+)', arguments)
        if port_match:
            return port_match.group(1)
        
        return None
    
    async def ping_sweep(self, network: str) -> List[str]:
        """Realiza un ping sweep para descubrir hosts activos"""
        if not self.is_available():
            raise RuntimeError("Nmap no está disponible")
        
        self.logger.info(f"Realizando ping sweep en {network}")
        
        try:
            arguments = "-sn"  # Ping scan only
            
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                self.nm.scan,
                network,
                arguments=arguments
            )
            
            # Extraer hosts activos
            active_hosts = []
            for host in result['scan']:
                if result['scan'][host]['status']['state'] == 'up':
                    active_hosts.append(host)
            
            return active_hosts
            
        except Exception as e:
            self.logger.error(f"Error en ping sweep: {str(e)}")
            raise
    
    def get_scan_templates(self) -> Dict[str, Dict[str, str]]:
        """Obtiene plantillas de escaneo predefinidas"""
        return {
            'quick': {
                'name': 'Escaneo Rápido',
                'description': 'Escaneo rápido de puertos comunes',
                'arguments': '-T4 -F'
            },
            'intense': {
                'name': 'Escaneo Intenso',
                'description': 'Escaneo completo con detección de servicios y OS',
                'arguments': '-T4 -A -v'
            },
            'comprehensive': {
                'name': 'Escaneo Comprensivo',
                'description': 'Escaneo de todos los puertos con scripts',
                'arguments': '-sS -sU -T4 -A -v -p 1-65535'
            },
            'stealth': {
                'name': 'Escaneo Sigiloso',
                'description': 'Escaneo lento para evadir detección',
                'arguments': '-sS -T2 -f'
            },
            'vulnerability': {
                'name': 'Escaneo de Vulnerabilidades',
                'description': 'Escaneo enfocado en detectar vulnerabilidades',
                'arguments': '-sV --script vuln'
            }
        } 