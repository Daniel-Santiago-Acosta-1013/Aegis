"""
Wrapper para Nuclei - Detección de vulnerabilidades con templates
"""

import asyncio
import logging
import subprocess
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from pathlib import Path


@dataclass
class NucleiResult:
    """Resultado de un escaneo Nuclei"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    templates_used: List[str]
    scan_stats: Dict[str, Any]
    raw_output: str


class NucleiWrapper:
    """Wrapper para la herramienta Nuclei"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nuclei')
        self.logger = logging.getLogger(__name__)
        
        # Inicializar process_runner para logging integrado
        from aegis_pentest.utils.process_runner import get_process_runner
        from aegis_pentest.utils.logger import get_logger
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Nuclei está disponible"""
        return self.config.is_tool_available('nuclei')
    
    async def scan(self, target: str, templates: List[str] = None, severity: str = "info,low,medium,high,critical") -> NucleiResult:
        """
        Ejecuta un escaneo con Nuclei
        
        Args:
            target: Objetivo a escanear
            templates: Lista de templates específicos a usar
            severity: Niveles de severidad a incluir
            
        Returns:
            NucleiResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Nuclei no está disponible")
        
        self.logger.info(f"Iniciando escaneo Nuclei de {target}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'nuclei'),
            '-target', target,
            '-jsonl',  # Usar jsonl en lugar de json
            '-severity', severity,
            '-silent'
        ]
        
        # Agregar templates específicos si se proporcionan
        if templates:
            for template in templates:
                cmd.extend(['-t', template])
        else:
            # Usar templates por defecto
            templates_path = self.tool_config.get('templates_path')
            if templates_path and Path(templates_path).exists():
                cmd.extend(['-t', templates_path])
        
        try:
            # Ejecutar comando usando process_runner para logging integrado
            process_result = await self.process_runner.run_tool_async(
                tool_name="nuclei",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 600)
            )
            
            if not process_result.success:
                raise RuntimeError(f"Nuclei falló: {process_result.error_message}")
            
            # Parsear resultados JSON
            vulnerabilities = []
            stdout = "\n".join(process_result.stdout_lines)
            for line in stdout.splitlines():
                if line.strip():
                    try:
                        vuln_data = json.loads(line)
                        # Normalizar al formato esperado
                        normalized_vuln = self._normalize_vulnerability(vuln_data)
                        vulnerabilities.append(normalized_vuln)
                    except json.JSONDecodeError:
                        continue
            
            # Estadísticas
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'templates_used': templates or ['default'],
                'target': target
            }
            
            result = NucleiResult(
                target=target,
                vulnerabilities=vulnerabilities,
                templates_used=templates or ['default'],
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo Nuclei completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo Nuclei: {str(e)}")
            raise
    
    def _run_nuclei_command(self, cmd: List[str]) -> tuple:
        """Ejecuta el comando Nuclei de forma síncrona"""
        timeout = self.tool_config.get('timeout', 600)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            
            return result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Timeout de Nuclei ({timeout}s) excedido")
        except Exception as e:
            raise RuntimeError(f"Error ejecutando Nuclei: {str(e)}")
    
    async def scan_with_custom_templates(self, target: str, template_dir: str) -> NucleiResult:
        """Escanea usando templates personalizados"""
        if not Path(template_dir).exists():
            raise ValueError(f"Directorio de templates no existe: {template_dir}")
        
        return await self.scan(target, [template_dir])
    
    async def scan_cve(self, target: str, cve_list: List[str] = None) -> NucleiResult:
        """Escanea CVEs específicos"""
        templates = []
        
        if cve_list:
            # Buscar templates para CVEs específicos
            for cve in cve_list:
                templates.append(f"cves/{cve}")
        else:
            # Usar todos los templates de CVE
            templates = ["cves/"]
        
        return await self.scan(target, templates, "medium,high,critical")
    
    def get_available_templates(self) -> Dict[str, List[str]]:
        """Obtiene lista de templates disponibles organizados por categoría"""
        templates_path = self.tool_config.get('templates_path')
        
        if not templates_path or not Path(templates_path).exists():
            return {}
        
        templates_dir = Path(templates_path)
        categories = {}
        
        try:
            for category_dir in templates_dir.iterdir():
                if category_dir.is_dir():
                    category_name = category_dir.name
                    templates = []
                    
                    for template_file in category_dir.glob("*.yaml"):
                        templates.append(template_file.name)
                    
                    if templates:
                        categories[category_name] = templates
        
        except Exception as e:
            self.logger.error(f"Error listando templates: {e}")
        
        return categories
    
    def get_template_info(self, template_path: str) -> Dict[str, Any]:
        """Obtiene información de un template específico"""
        # Placeholder para obtener información del template
        # Esto requeriría parsear el archivo YAML del template
        return {
            'name': template_path,
            'severity': 'unknown',
            'description': 'Template information not available',
            'tags': []
        }
    
    def _normalize_vulnerability(self, vuln_data: Dict[str, Any]) -> Dict[str, Any]:
        """Normaliza una vulnerabilidad de Nuclei al formato estándar"""
        info = vuln_data.get('info', {})
        
        return {
            'id': vuln_data.get('template-id', 'N/A'),
            'severity': info.get('severity', 'unknown').upper(),
            'port': vuln_data.get('port', 'N/A'),
            'description': info.get('name', info.get('description', 'Sin descripción'))[:100],
            'type': 'nuclei',
            'template': vuln_data.get('template', ''),
            'host': vuln_data.get('host', ''),
            'url': vuln_data.get('url', ''),
            'matched_at': vuln_data.get('matched-at', ''),
            'raw_data': vuln_data  # Mantener datos originales para análisis detallado
        } 