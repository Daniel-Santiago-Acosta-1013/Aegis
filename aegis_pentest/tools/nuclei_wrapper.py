"""
Wrapper para Nuclei - Detección de vulnerabilidades con templates
Versión mejorada y optimizada para evitar colgamientos
"""

import logging
import subprocess
import json
import asyncio
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from pathlib import Path


@dataclass
class NucleiResult:
    """Resultado de un escaneo Nuclei"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    templates_used: List[str]
    scan_stats: Dict[str, Any]
    raw_output: str


class NucleiWrapper:
    """Wrapper mejorado para la herramienta Nuclei"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nuclei')
        self.logger = logging.getLogger(__name__)
        
        # Inicializar process_runner para logging integrado
        from aegis_pentest.utils.process_runner import get_process_runner
        from aegis_pentest.utils.logger import get_logger
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Nuclei está disponible"""
        return self.config.is_tool_available('nuclei')
    
    def test_nuclei_installation(self) -> Dict[str, Any]:
        """Verifica la instalación de Nuclei y templates"""
        try:
            # Verificar binario de Nuclei
            result = subprocess.run(['nuclei', '-version'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                return {
                    'available': False,
                    'error': 'Nuclei no responde al comando -version',
                    'suggestions': [
                        'Instalar Nuclei: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                        'Verificar PATH: which nuclei',
                        'Actualizar Go si es necesario'
                    ]
                }
            
            version = result.stdout.strip()
            
            # Verificar templates
            template_result = subprocess.run(['nuclei', '-tl'], capture_output=True, text=True, timeout=30)
            template_count = 0
            if template_result.returncode == 0:
                # Contar templates disponibles
                for line in template_result.stdout.splitlines():
                    if line.strip() and not line.startswith('Total'):
                        template_count += 1
            
            return {
                'available': True,
                'ready': template_count > 0,
                'version': version,
                'template_count': template_count,
                'ready_message': f"Nuclei listo con {template_count} templates" if template_count > 0 else "Sin templates disponibles"
            }
            
        except subprocess.TimeoutExpired:
            return {
                'available': False,
                'error': 'Nuclei no responde (timeout)',
                'suggestions': [
                    'Verificar que Nuclei esté instalado correctamente',
                    'Verificar conectividad de red para actualizar templates'
                ]
            }
        except FileNotFoundError:
            return {
                'available': False,
                'error': 'Nuclei no encontrado en PATH',
                'suggestions': [
                    'Instalar Nuclei: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest',
                    'Agregar $GOPATH/bin al PATH'
                ]
            }
        except Exception as e:
            return {
                'available': False,
                'error': f'Error verificando Nuclei: {str(e)}',
                'suggestions': [
                    'Reinstalar Nuclei',
                    'Verificar permisos'
                ]
            }
    
    async def scan_with_templates(self, target: str, templates: List[str]) -> NucleiResult:
        """Escaneo con templates específicos, optimizado para confiabilidad"""
        if not self.is_available():
            raise RuntimeError("Nuclei no está disponible")
        
        # Verificar templates
        if not templates or all(t.strip() == '' for t in templates):
            raise ValueError("Debe especificar al menos un template")
        
        # Limpiar y normalizar templates
        clean_templates = [t.strip().lower() for t in templates if t.strip()]
        
        # Verificar si se solicita ALL templates
        if len(clean_templates) == 1 and clean_templates[0] == 'all':
            self.logger.info(f"Solicitado escaneo con TODAS las plantillas - usando método específico")
            return await self._scan_all_templates(target)
        
        # Validar target URL
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        self.logger.info(f"Iniciando escaneo Nuclei de {target} con templates: {clean_templates}")
        
        # Construir comando optimizado para confiabilidad
        cmd = self._build_command(target, clean_templates, scan_type="specific")
        
        return await self._execute_scan(cmd, target, clean_templates, "specific")
    
    async def _scan_all_templates(self, target: str) -> NucleiResult:
        """Escaneo con TODAS las plantillas - método separado para mejor control"""
        # Validar target URL
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        self.logger.info(f"Iniciando escaneo COMPLETO de Nuclei en {target} con TODAS las plantillas")
        
        # Comando para todas las plantillas
        cmd = self._build_command(target, ['all'], scan_type="complete")
        
        return await self._execute_scan(cmd, target, ['ALL_TEMPLATES'], "complete")
    
    def _build_command(self, target: str, templates: List[str], scan_type: str = "specific") -> List[str]:
        """Construye el comando Nuclei optimizado"""
        cmd = [
            'nuclei',
            '-u', target,
            '-jsonl',        # Output JSONL para mejor parsing
            '-no-color',     # Sin colores ANSI
            '-silent',       # Reducir output verboso
            '-stats'         # Mostrar estadísticas
        ]
        
        # Configuración de timeouts y límites según tipo de escaneo
        if scan_type == "complete":
            # Configuración para escaneo completo (más conservadora)
            cmd.extend([
                '-timeout', '20',        # 20s por request
                '-retries', '1',         # Solo 1 reintento  
                '-rate-limit', '10',     # 10 requests/segundo
                '-max-host-error', '5'   # Max 5 errores por host
            ])
            # Para escaneo completo, usar templates por defecto (no especificar -t)
        else:
            # Configuración para templates específicos (más agresiva)
            cmd.extend([
                '-timeout', '10',        # 10s por request
                '-retries', '1',         # Solo 1 reintento
                '-rate-limit', '20',     # 20 requests/segundo
                '-max-host-error', '3'   # Max 3 errores por host
            ])
            
            # Agregar templates específicos
            for template in templates:
                template_path = self._map_template_name(template)
                if template_path:
                    cmd.extend(['-t', template_path])
        
        return cmd
    
    def _map_template_name(self, template_name: str) -> Optional[str]:
        """Mapea nombres de templates a paths seguros"""
        # Mapeo simple y directo
        template_mapping = {
            'cves': 'cves/',
            'exposures': 'exposures/',
            'technologies': 'technologies/',
            'misconfigurations': 'misconfiguration/',
            'default-logins': 'default-logins/',
            'vulnerabilities': 'vulnerabilities/',
            'fuzzing': 'fuzzing/',
            'takeovers': 'takeovers/',
            'workflows': 'workflows/'
        }
        
        template_lower = template_name.lower().strip()
        
        if template_lower in template_mapping:
            return template_mapping[template_lower]
        
        # Si no está en el mapeo, asumir que es una categoría válida
        if template_lower and not template_lower == 'all':
            return f"{template_lower}/"
        
        return None
    
    async def _execute_scan(self, cmd: List[str], target: str, templates: List[str], scan_type: str) -> NucleiResult:
        """Ejecuta el escaneo con manejo robusto de errores"""
        
        # Timeout basado en tipo de escaneo
        timeout = 300 if scan_type == "specific" else 900  # 5 min vs 15 min
        
        try:
            # Ejecutar con output en tiempo real habilitado
            # EL OUTPUT REAL DE NUCLEI SERÁ CAPTURADO AUTOMÁTICAMENTE POR process_runner
            process_result = await self.process_runner.run_tool_async(
                tool_name="nuclei",
                command=cmd,
                target=target,
                timeout=timeout,
                realtime_output=True  # CRUCIAL: output en tiempo real
            )
            
            # Análisis de resultados
            if not process_result.success:
                error_msg = process_result.error_message or "Error desconocido en Nuclei"
                
                # Si fue timeout, proporcionar información útil
                if process_result.timeout_occurred:
                    error_msg += f" - Timeout después de {timeout}s"
                
                raise RuntimeError(f"Nuclei falló: {error_msg}")
            
            # Procesar output
            return self._process_results(process_result, target, templates, scan_type)
            
        except asyncio.TimeoutError:
            error_msg = f"Timeout de {timeout}s alcanzado para {target}"
            raise RuntimeError(error_msg)
        except Exception as e:
            error_msg = f"Error ejecutando Nuclei: {str(e)}"
            raise RuntimeError(error_msg)
    
    def _process_results(self, process_result, target: str, templates: List[str], scan_type: str) -> NucleiResult:
        """Procesa los resultados del escaneo Nuclei"""
        
        vulnerabilities = []
        stdout = "\n".join(process_result.stdout_lines) if process_result.stdout_lines else ""
        stderr = "\n".join(process_result.stderr_lines) if process_result.stderr_lines else ""
        
        # Parsear líneas JSONL (este procesamiento es necesario para extraer hallazgos)
        vuln_count = 0
        for line_num, line in enumerate(stdout.splitlines(), 1):
            line = line.strip()
            if line and line.startswith('{'):
                try:
                    vuln_data = json.loads(line)
                    
                    # Verificar que es una vulnerabilidad válida
                    if 'template-id' in vuln_data and 'matched-at' in vuln_data:
                        normalized_vuln = self._normalize_vulnerability(vuln_data)
                        vulnerabilities.append(normalized_vuln)
                        vuln_count += 1
                        
                except json.JSONDecodeError:
                    # Líneas que no son JSON válido se ignoran
                    continue
        
        # Estadísticas finales
        scan_stats = {
            'total_vulnerabilities': len(vulnerabilities),
            'templates_used': templates,
            'target': target,
            'scan_type': scan_type,
            'success': True,
            'duration': process_result.duration,
            'stdout_lines': len(process_result.stdout_lines),
            'stderr_lines': len(process_result.stderr_lines)
        }
        
        result = NucleiResult(
            target=target,
            vulnerabilities=vulnerabilities,
            templates_used=templates,
            scan_stats=scan_stats,
            raw_output=stdout
        )
        
        self.logger.info(f"Escaneo Nuclei completado: {len(vulnerabilities)} vulnerabilidades encontradas")
        
        return result
    
    def _normalize_vulnerability(self, vuln_data: Dict[str, Any]) -> Dict[str, Any]:
        """Normaliza los datos de vulnerabilidad de Nuclei"""
        info = vuln_data.get('info', {})
        
        return {
            'id': vuln_data.get('template-id', 'unknown'),
            'name': info.get('name', 'Unknown Vulnerability'),
            'severity': info.get('severity', 'unknown').upper(),
            'description': info.get('description', 'No description available'),
            'url': vuln_data.get('matched-at', ''),
            'type': vuln_data.get('type', 'unknown'),
            'tags': info.get('tags', []),
            'author': info.get('author', []),
            'reference': info.get('reference', []),
            'raw_data': vuln_data
        }
    
    # Métodos de conveniencia
    async def quick_scan(self, target: str) -> NucleiResult:
        """Escaneo rápido con templates esenciales"""
        return await self.scan_with_templates(target, ['cves', 'exposures'])
    
    async def comprehensive_scan(self, target: str) -> NucleiResult:
        """Escaneo comprensivo con templates principales"""
        return await self.scan_with_templates(target, ['cves', 'exposures', 'technologies', 'misconfigurations'])
    
    async def full_scan(self, target: str) -> NucleiResult:
        """Escaneo completo con TODAS las plantillas"""
        return await self.scan_with_templates(target, ['all'])
    
    async def security_focused_scan(self, target: str) -> NucleiResult:
        """Escaneo enfocado en seguridad"""
        return await self.scan_with_templates(target, ['cves', 'vulnerabilities', 'default-logins'])
    
    async def recon_scan(self, target: str) -> NucleiResult:
        """Escaneo de reconocimiento"""
        return await self.scan_with_templates(target, ['exposures', 'technologies'])
    
    async def web_scan(self, target: str) -> NucleiResult:
        """Escaneo web específico"""
        return await self.scan_with_templates(target, ['vulnerabilities', 'misconfigurations', 'workflows'])
    
    def get_scan_presets(self) -> Dict[str, Dict[str, Any]]:
        """Obtiene los presets de escaneo disponibles"""
        return {
            'quick': {
                'name': 'Escaneo Rápido', 
                'templates': ['cves', 'exposures'],
                'duration': '2-5 min',
                'description': 'CVEs conocidos y exposiciones básicas'
            },
            'comprehensive': {
                'name': 'Escaneo Comprensivo',
                'templates': ['cves', 'exposures', 'technologies', 'misconfigurations'], 
                'duration': '5-10 min',
                'description': 'Cobertura amplia de vulnerabilidades comunes'
            },
            'full': {
                'name': 'Escaneo Completo',
                'templates': ['all'],
                'duration': '15-30 min', 
                'description': 'TODAS las plantillas disponibles'
            },
            'security': {
                'name': 'Enfoque de Seguridad',
                'templates': ['cves', 'vulnerabilities', 'default-logins'],
                'duration': '3-8 min',
                'description': 'Vulnerabilidades críticas de seguridad'
            },
            'recon': {
                'name': 'Reconocimiento',
                'templates': ['exposures', 'technologies'],
                'duration': '2-4 min', 
                'description': 'Información y tecnologías expuestas'
            },
            'web': {
                'name': 'Aplicaciones Web',
                'templates': ['vulnerabilities', 'misconfigurations', 'workflows'],
                'duration': '5-12 min',
                'description': 'Vulnerabilidades específicas de aplicaciones web'
            }
        } 