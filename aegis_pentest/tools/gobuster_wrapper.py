"""
Wrapper para Gobuster - Fuzzing de directorios y archivos
"""

import asyncio
import logging
import subprocess
from typing import Dict, List, Any
from dataclasses import dataclass
from pathlib import Path


@dataclass
class GobusterResult:
    """Resultado de un escaneo Gobuster"""
    target: str
    scan_type: str
    found_paths: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class GobusterWrapper:
    """Wrapper para la herramienta Gobuster"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('gobuster')
        self.logger = logging.getLogger(__name__)
        
        # Inicializar process_runner para logging integrado
        from aegis_pentest.utils.process_runner import get_process_runner
        from aegis_pentest.utils.logger import get_logger
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Gobuster está disponible"""
        return self.config.is_tool_available('gobuster')
    
    async def dir_scan(self, target: str, wordlist: str = None, extensions: List[str] = None, threads: int = 50) -> GobusterResult:
        """
        Ejecuta un escaneo de directorios con Gobuster
        
        Args:
            target: URL objetivo
            wordlist: Ruta del wordlist a usar
            extensions: Extensiones de archivo a buscar
            threads: Número de hilos
            
        Returns:
            GobusterResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Gobuster no está disponible")
        
        self.logger.info(f"Iniciando escaneo de directorios de {target}")
        
        # Usar wordlist por defecto si no se especifica
        if not wordlist:
            # Buscar wordlists comunes en diferentes ubicaciones
            possible_wordlists = [
                '/usr/share/wordlists/dirb/common.txt',
                '/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt',
                '/opt/homebrew/share/wordlists/dirb/common.txt',
                '/usr/local/share/wordlists/dirb/common.txt'
            ]
            
            wordlist = None
            for wl_path in possible_wordlists:
                if Path(wl_path).exists():
                    wordlist = wl_path
                    break
            
            if not wordlist:
                # Crear un wordlist básico temporal
                temp_wordlist = '/tmp/basic_wordlist.txt'
                basic_dirs = ['admin', 'test', 'backup', 'config', 'login', 'api', 'wp-admin', 'images', 'css', 'js', 'static']
                with open(temp_wordlist, 'w') as f:
                    for dir_name in basic_dirs:
                        f.write(f"{dir_name}\n")
                wordlist = temp_wordlist
                self.logger.warning(f"Usando wordlist básico temporal: {wordlist}")
        
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist no encontrado: {wordlist}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'gobuster'),
            'dir',
            '-u', target,
            '-w', wordlist,
            '-t', str(threads),
            '-q'  # Modo silencioso
        ]
        
        # Agregar extensiones si se especifican
        if extensions:
            cmd.extend(['-x', ','.join(extensions)])
        else:
            # Usar extensiones por defecto
            default_exts = self.tool_config.get('default_args', [])
            for arg in default_exts:
                if arg == '-x':
                    continue
                if ',' in arg and any(ext in arg for ext in ['php', 'html', 'txt', 'js']):
                    cmd.extend(['-x', arg])
                    break
        
        try:
            # Ejecutar comando usando process_runner para logging integrado
            process_result = await self.process_runner.run_tool_async(
                tool_name="gobuster",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 300)
            )
            
            if not process_result.success:
                raise RuntimeError(f"Gobuster falló: {process_result.error_message}")
            
            # Parsear resultados
            stdout = "\n".join(process_result.stdout_lines)
            found_paths = self._parse_dir_output(stdout)
            
            # Estadísticas
            scan_stats = {
                'total_found': len(found_paths),
                'wordlist_used': wordlist,
                'extensions': extensions or [],
                'threads': threads,
                'target': target
            }
            
            result = GobusterResult(
                target=target,
                scan_type="directory",
                found_paths=found_paths,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo de directorios completado: {len(found_paths)} rutas encontradas")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo de directorios: {str(e)}")
            raise
    
    async def dns_scan(self, domain: str, wordlist: str = None, threads: int = 50) -> GobusterResult:
        """
        Ejecuta un escaneo de subdominios DNS
        
        Args:
            domain: Dominio objetivo
            wordlist: Ruta del wordlist a usar
            threads: Número de hilos
            
        Returns:
            GobusterResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Gobuster no está disponible")
        
        self.logger.info(f"Iniciando escaneo DNS de {domain}")
        
        # Usar wordlist por defecto si no se especifica
        if not wordlist:
            wordlist = self.tool_config.get('wordlist', '/usr/share/wordlists/dirb/common.txt')
        
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist no encontrado: {wordlist}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'gobuster'),
            'dns',
            '-d', domain,
            '-w', wordlist,
            '-t', str(threads),
            '-q'
        ]
        
        try:
            # Ejecutar comando
            loop = asyncio.get_event_loop()
            stdout, stderr = await loop.run_in_executor(
                None,
                self._run_gobuster_command,
                cmd
            )
            
            # Parsear resultados
            found_paths = self._parse_dns_output(stdout)
            
            # Estadísticas
            scan_stats = {
                'total_found': len(found_paths),
                'wordlist_used': wordlist,
                'threads': threads,
                'domain': domain
            }
            
            result = GobusterResult(
                target=domain,
                scan_type="dns",
                found_paths=found_paths,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo DNS completado: {len(found_paths)} subdominios encontrados")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo DNS: {str(e)}")
            raise
    
    async def vhost_scan(self, target: str, wordlist: str = None, threads: int = 50) -> GobusterResult:
        """
        Ejecuta un escaneo de virtual hosts
        
        Args:
            target: URL objetivo
            wordlist: Ruta del wordlist a usar
            threads: Número de hilos
            
        Returns:
            GobusterResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Gobuster no está disponible")
        
        self.logger.info(f"Iniciando escaneo de virtual hosts de {target}")
        
        # Usar wordlist por defecto si no se especifica
        if not wordlist:
            wordlist = self.tool_config.get('wordlist', '/usr/share/wordlists/dirb/common.txt')
        
        if not Path(wordlist).exists():
            raise ValueError(f"Wordlist no encontrado: {wordlist}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'gobuster'),
            'vhost',
            '-u', target,
            '-w', wordlist,
            '-t', str(threads),
            '-q'
        ]
        
        try:
            # Ejecutar comando
            loop = asyncio.get_event_loop()
            stdout, stderr = await loop.run_in_executor(
                None,
                self._run_gobuster_command,
                cmd
            )
            
            # Parsear resultados
            found_paths = self._parse_vhost_output(stdout)
            
            # Estadísticas
            scan_stats = {
                'total_found': len(found_paths),
                'wordlist_used': wordlist,
                'threads': threads,
                'target': target
            }
            
            result = GobusterResult(
                target=target,
                scan_type="vhost",
                found_paths=found_paths,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo de virtual hosts completado: {len(found_paths)} hosts encontrados")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo de virtual hosts: {str(e)}")
            raise
    
    def _run_gobuster_command(self, cmd: List[str]) -> tuple:
        """Ejecuta el comando Gobuster de forma síncrona"""
        timeout = self.tool_config.get('timeout', 300)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            
            return result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Timeout de Gobuster ({timeout}s) excedido")
        except Exception as e:
            raise RuntimeError(f"Error ejecutando Gobuster: {str(e)}")
    
    def _parse_dir_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida del escaneo de directorios"""
        found_paths = []
        
        for line in output.splitlines():
            line = line.strip()
            if not line or line.startswith('='):
                continue
            
            # Formato típico: "/path (Status: 200) [Size: 1234]"
            if '(Status:' in line:
                parts = line.split('(Status:')
                if len(parts) >= 2:
                    path = parts[0].strip()
                    status_part = parts[1].split(')')[0].strip()
                    
                    # Extraer tamaño si está presente
                    size = 0
                    if '[Size:' in line:
                        try:
                            size_part = line.split('[Size:')[1].split(']')[0].strip()
                            size = int(size_part)
                        except:
                            pass
                    
                    found_paths.append({
                        'path': path,
                        'status_code': int(status_part) if status_part.isdigit() else 0,
                        'size': size,
                        'type': 'directory' if path.endswith('/') else 'file'
                    })
        
        return found_paths
    
    def _parse_dns_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida del escaneo DNS"""
        found_paths = []
        
        for line in output.splitlines():
            line = line.strip()
            if not line or '=' in line:
                continue
            
            # Formato típico: "Found: subdomain.example.com"
            if 'Found:' in line:
                subdomain = line.replace('Found:', '').strip()
                found_paths.append({
                    'subdomain': subdomain,
                    'type': 'subdomain'
                })
        
        return found_paths
    
    def _parse_vhost_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida del escaneo de virtual hosts"""
        found_paths = []
        
        for line in output.splitlines():
            line = line.strip()
            if not line or '=' in line:
                continue
            
            # Formato típico: "Found: vhost.example.com (Status: 200) [Size: 1234]"
            if 'Found:' in line and '(Status:' in line:
                parts = line.split('Found:')[1].split('(Status:')
                if len(parts) >= 2:
                    vhost = parts[0].strip()
                    status_part = parts[1].split(')')[0].strip()
                    
                    # Extraer tamaño si está presente
                    size = 0
                    if '[Size:' in line:
                        try:
                            size_part = line.split('[Size:')[1].split(']')[0].strip()
                            size = int(size_part)
                        except:
                            pass
                    
                    found_paths.append({
                        'vhost': vhost,
                        'status_code': int(status_part) if status_part.isdigit() else 0,
                        'size': size,
                        'type': 'vhost'
                    })
        
        return found_paths
    
    def get_available_wordlists(self) -> Dict[str, str]:
        """Obtiene lista de wordlists disponibles"""
        common_paths = [
            '/usr/share/wordlists/dirb/',
            '/usr/share/wordlists/dirbuster/',
            '/usr/share/seclists/',
            '/opt/SecLists/'
        ]
        
        wordlists = {}
        
        for base_path in common_paths:
            path = Path(base_path)
            if path.exists():
                for wordlist_file in path.rglob('*.txt'):
                    if wordlist_file.is_file():
                        wordlists[wordlist_file.name] = str(wordlist_file)
        
        return wordlists
    
    def get_scan_templates(self) -> Dict[str, Dict[str, Any]]:
        """Obtiene plantillas de escaneo predefinidas"""
        return {
            'quick_dir': {
                'name': 'Directorios Rápido',
                'description': 'Escaneo rápido de directorios comunes',
                'type': 'dir',
                'wordlist': 'common.txt',
                'extensions': ['php', 'html', 'txt'],
                'threads': 50
            },
            'comprehensive_dir': {
                'name': 'Directorios Comprensivo',
                'description': 'Escaneo extenso de directorios',
                'type': 'dir',
                'wordlist': 'directory-list-2.3-medium.txt',
                'extensions': ['php', 'html', 'txt', 'js', 'css', 'xml', 'json'],
                'threads': 100
            },
            'subdomain_enum': {
                'name': 'Enumeración de Subdominios',
                'description': 'Busca subdominios del dominio objetivo',
                'type': 'dns',
                'wordlist': 'subdomains-top1million-5000.txt',
                'threads': 50
            },
            'vhost_discovery': {
                'name': 'Descubrimiento de Virtual Hosts',
                'description': 'Busca virtual hosts en el servidor',
                'type': 'vhost',
                'wordlist': 'common.txt',
                'threads': 50
            }
        } 