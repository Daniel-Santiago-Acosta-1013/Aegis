"""
Wrapper para traceroute - Análisis de rutas de red
"""

import logging
import re
import ipaddress
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class TracerouteResult:
    """Resultado de un traceroute"""
    target: str
    hops: List[Dict[str, Any]]
    network_info: Dict[str, Any]
    scan_stats: Dict[str, Any]
    raw_output: str


class TracerouteWrapper:
    """Wrapper para la herramienta traceroute"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('traceroute')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si traceroute está disponible"""
        return self.config.is_tool_available('traceroute')
    
    def should_run_against_target(self, target: str, target_type: str, scan_phase: str = 'reconnaissance') -> bool:
        """Determina si traceroute debe ejecutarse contra el target"""
        # Ejecutar en fase de reconocimiento o cuando se necesite info de red
        if scan_phase not in ['reconnaissance', 'network_analysis', 'comprehensive']:
            return False
        
        # Solo ejecutar en IPs o dominios
        if target_type not in ['ip', 'domain']:
            return False
        
        # No ejecutar en localhost o IPs privadas
        if self._is_private_target(target):
            self.logger.info(f"Target {target} es privado/local - saltando traceroute")
            return False
        
        return True
    
    async def trace(self, target: str, max_hops: int = 30) -> TracerouteResult:
        """Ejecuta traceroute hacia el target"""
        if not self.is_available():
            raise RuntimeError("traceroute no está disponible")
        
        self.logger.info(f"Ejecutando traceroute hacia {target}")
        
        # Comando para traceroute
        cmd = [
            self.tool_config.get('path', 'traceroute'),
            '-n',  # No resolver nombres (más rápido)
            '-m', str(max_hops),  # Máximo número de saltos
            '-w', '3',  # Timeout de 3 segundos por hop
            target
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="traceroute",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 120)
            )
            
            # traceroute puede retornar códigos no-zero pero aún dar información útil
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            full_output = stdout + stderr
            
            # Parsear resultados
            hops = self._parse_traceroute_output(full_output)
            network_info = self._analyze_network_path(hops)
            
            scan_stats = {
                'total_hops': len(hops),
                'target': target,
                'successful_hops': len([h for h in hops if h.get('ip') != '*']),
                'average_latency': self._calculate_average_latency(hops)
            }
            
            result = TracerouteResult(
                target=target,
                hops=hops,
                network_info=network_info,
                scan_stats=scan_stats,
                raw_output=full_output
            )
            
            self.logger.info(f"Traceroute completado: {len(hops)} saltos analizados")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en traceroute: {str(e)}")
            raise
    
    async def tcp_trace(self, target: str, port: int = 80) -> TracerouteResult:
        """Ejecuta traceroute TCP hacia un puerto específico"""
        if not self.is_available():
            raise RuntimeError("traceroute no está disponible")
        
        self.logger.info(f"Ejecutando traceroute TCP hacia {target}:{port}")
        
        # Comando para traceroute TCP
        cmd = [
            self.tool_config.get('path', 'traceroute'),
            '-T',  # TCP SYN
            '-p', str(port),  # Puerto específico
            '-n',  # No resolver nombres
            '-m', '30',  # Máximo 30 saltos
            '-w', '3',  # Timeout 3 segundos
            target
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="traceroute",
                command=cmd,
                target=f"{target}:{port}",
                timeout=self.tool_config.get('timeout', 120)
            )
            
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            full_output = stdout + stderr
            
            hops = self._parse_traceroute_output(full_output)
            network_info = self._analyze_network_path(hops)
            network_info['trace_type'] = 'tcp'
            network_info['target_port'] = port
            
            scan_stats = {
                'total_hops': len(hops),
                'target': f"{target}:{port}",
                'successful_hops': len([h for h in hops if h.get('ip') != '*']),
                'average_latency': self._calculate_average_latency(hops),
                'trace_type': 'tcp'
            }
            
            result = TracerouteResult(
                target=target,
                hops=hops,
                network_info=network_info,
                scan_stats=scan_stats,
                raw_output=full_output
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en traceroute TCP: {str(e)}")
            raise
    
    def _parse_traceroute_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida de traceroute"""
        hops = []
        lines = output.splitlines()
        
        for line in lines:
            line = line.strip()
            
            # Buscar líneas que contengan información de saltos
            # Formato típico: " 1  192.168.1.1  1.234 ms  1.567 ms  1.890 ms"
            hop_match = re.match(r'\s*(\d+)\s+(.+)', line)
            if hop_match:
                hop_num = int(hop_match.group(1))
                hop_data = hop_match.group(2).strip()
                
                hop_info = {
                    'hop': hop_num,
                    'ip': '*',
                    'hostname': '',
                    'latencies': [],
                    'status': 'timeout'
                }
                
                # Extraer IP/hostname y latencias
                if '*' not in hop_data:
                    # Buscar IP address
                    ip_match = re.search(r'(\d+\.\d+\.\d+\.\d+)', hop_data)
                    if ip_match:
                        hop_info['ip'] = ip_match.group(1)
                        hop_info['status'] = 'success'
                        
                        # Buscar hostname si está presente
                        hostname_match = re.search(r'([a-zA-Z0-9.-]+)\s+\(' + re.escape(hop_info['ip']) + r'\)', hop_data)
                        if hostname_match:
                            hop_info['hostname'] = hostname_match.group(1)
                    
                    # Extraer latencias
                    latency_matches = re.findall(r'(\d+(?:\.\d+)?)\s*ms', hop_data)
                    if latency_matches:
                        hop_info['latencies'] = [float(lat) for lat in latency_matches]
                        hop_info['avg_latency'] = sum(hop_info['latencies']) / len(hop_info['latencies'])
                
                hops.append(hop_info)
        
        return hops
    
    def _analyze_network_path(self, hops: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analiza la ruta de red y extrae información útil"""
        network_info = {
            'total_hops': len(hops),
            'successful_hops': 0,
            'private_hops': [],
            'public_hops': [],
            'potential_firewalls': [],
            'high_latency_hops': [],
            'geographic_path': []
        }
        
        for hop in hops:
            if hop.get('ip') != '*':
                network_info['successful_hops'] += 1
                
                # Clasificar como privada o pública
                if self._is_private_ip(hop['ip']):
                    network_info['private_hops'].append(hop)
                else:
                    network_info['public_hops'].append(hop)
                
                # Detectar posibles firewalls (saltos con latencia muy alta)
                avg_latency = hop.get('avg_latency', 0)
                if avg_latency > 100:  # > 100ms puede indicar filtrado
                    network_info['high_latency_hops'].append(hop)
            
            # Detectar posibles firewalls (muchos timeouts consecutivos)
            else:
                network_info['potential_firewalls'].append(hop['hop'])
        
        return network_info
    
    def _calculate_average_latency(self, hops: List[Dict[str, Any]]) -> float:
        """Calcula la latencia promedio de todos los saltos exitosos"""
        successful_latencies = []
        
        for hop in hops:
            if hop.get('latencies'):
                successful_latencies.extend(hop['latencies'])
        
        if successful_latencies:
            return sum(successful_latencies) / len(successful_latencies)
        else:
            return 0.0
    
    def _is_private_target(self, target: str) -> bool:
        """Verifica si el target es una IP privada o localhost"""
        try:
            ip = ipaddress.ip_address(target)
            return ip.is_private or ip.is_loopback
        except ValueError:
            # Es un dominio
            if target.lower() in ['localhost', '127.0.0.1', '::1']:
                return True
            return False
    
    def _is_private_ip(self, ip_str: str) -> bool:
        """Verifica si una IP es privada"""
        try:
            ip = ipaddress.ip_address(ip_str)
            return ip.is_private
        except ValueError:
            return False
    
    def get_trace_options(self) -> Dict[str, str]:
        """Obtiene las opciones de traceroute disponibles"""
        return {
            'icmp': 'Traceroute ICMP tradicional (por defecto)',
            'tcp': 'Traceroute TCP SYN (útil para evadir firewalls)',
            'udp': 'Traceroute UDP (útil para ciertos tipos de red)',
            'ipv6': 'Traceroute IPv6 (cuando el target soporta IPv6)'
        } 