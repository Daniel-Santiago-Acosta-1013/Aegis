"""
Wrapper para ffuf - Directory/File Fuzzing
"""

import json
import logging
from typing import Dict, List, Any
from dataclasses import dataclass
from pathlib import Path

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class FfufResult:
    """Resultado de un escaneo con ffuf"""
    target: str
    directories: List[Dict[str, Any]]
    files: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    wordlist_used: str
    raw_output: str


class FfufWrapper:
    """Wrapper para la herramienta ffuf"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('ffuf')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si ffuf está disponible"""
        return self.config.is_tool_available('ffuf')
    
    def should_run_against_target(self, target: str, target_type: str, nmap_result=None) -> bool:
        """Determina si ffuf debe ejecutarse contra el target"""
        # Solo ejecutar en targets web
        if target_type not in ['url', 'domain']:
            return False
        
        # Si tenemos resultados de nmap, verificar puertos web
        if nmap_result and hasattr(nmap_result, 'ports'):
            web_ports = []
            for port_info in nmap_result.ports:
                if (port_info.get('state') == 'open' and 
                    port_info.get('port') in [80, 443, 8080, 8443, 3000, 5000, 8000, 9000]):
                    web_ports.append(port_info.get('port'))
            
            if not web_ports:
                self.logger.info("No se detectaron puertos web abiertos - saltando ffuf")
                return False
        
        return True
    
    async def scan_directories(self, target: str, wordlist: str = None, extensions: List[str] = None) -> FfufResult:
        """Escanea directorios usando ffuf"""
        if not self.is_available():
            raise RuntimeError("ffuf no está disponible")
        
        self.logger.info(f"Iniciando fuzzing de directorios en {target}")
        
        # Preparar URL base
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        # Wordlist por defecto
        if not wordlist:
            wordlist = self.tool_config.get('wordlist_dirs', '/usr/share/wordlists/dirb/common.txt')
        
        # Verificar si el wordlist existe
        if not Path(wordlist).exists():
            # Wordlists alternativos
            alternative_wordlists = [
                '/usr/share/dirb/wordlists/common.txt',
                '/usr/share/seclists/Discovery/Web-Content/common.txt',
                '/opt/SecLists/Discovery/Web-Content/common.txt'
            ]
            
            for alt_wordlist in alternative_wordlists:
                if Path(alt_wordlist).exists():
                    wordlist = alt_wordlist
                    break
            else:
                raise RuntimeError("No se encontró wordlist para ffuf")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'ffuf'),
            '-w', wordlist,
            '-u', f"{target}/FUZZ",
            '-mc', '200,204,301,302,307,401,403',  # Status codes a incluir
            '-fc', '404',  # Filtrar 404s
            '-t', str(self.tool_config.get('threads', 40)),
            '-o', '-',  # Output a stdout
            '-of', 'json',  # Formato JSON
            '-s'  # Silent mode
        ]
        
        # Agregar extensiones si se especifican
        if extensions:
            ext_wordlist = self._create_extension_wordlist(extensions)
            cmd.extend(['-w', ext_wordlist, '-u', f"{target}/FUZZ.FUZZ2"])
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="ffuf",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 600),
                realtime_output=True
            )
            
            if not process_result.success:
                raise RuntimeError(f"ffuf falló: {process_result.error_message}")
            
            # Parsear resultados JSON
            directories = []
            files = []
            
            stdout = "\n".join(process_result.stdout_lines)
            try:
                results = json.loads(stdout)
                for result in results.get('results', []):
                    item = {
                        'path': result.get('input', {}).get('FUZZ', ''),
                        'url': result.get('url', ''),
                        'status': result.get('status', 0),
                        'length': result.get('length', 0),
                        'words': result.get('words', 0),
                        'lines': result.get('lines', 0)
                    }
                    
                    # Clasificar como directorio o archivo
                    if item['path'].endswith('/') or item['status'] in [301, 302, 307]:
                        directories.append(item)
                    else:
                        files.append(item)
            
            except json.JSONDecodeError:
                self.logger.warning("No se pudo parsear output JSON de ffuf")
            
            scan_stats = {
                'total_found': len(directories) + len(files),
                'directories': len(directories),
                'files': len(files),
                'wordlist': wordlist,
                'target': target
            }
            
            result = FfufResult(
                target=target,
                directories=directories,
                files=files,
                scan_stats=scan_stats,
                wordlist_used=wordlist,
                raw_output=stdout
            )
            
            self.logger.info(f"Fuzzing completado: {len(directories)} directorios, {len(files)} archivos")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en ffuf: {str(e)}")
            raise
    
    async def scan_files(self, target: str, extensions: List[str] = None) -> FfufResult:
        """Escanea archivos específicos usando ffuf"""
        if not extensions:
            extensions = ['php', 'html', 'txt', 'js', 'css', 'json', 'xml']
        
        return await self.scan_directories(target, extensions=extensions)
    
    async def fuzz_target(self, target: str, wordlist: str = None) -> FfufResult:
        """Método wrapper para compatibilidad con modo interactivo"""
        return await self.scan_directories(target, wordlist)
    
    def _create_extension_wordlist(self, extensions: List[str]) -> str:
        """Crea un wordlist temporal con extensiones"""
        import tempfile
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt') as f:
            for ext in extensions:
                f.write(f"{ext}\n")
            return f.name
    
    def get_recommended_wordlists(self) -> Dict[str, str]:
        """Obtiene wordlists recomendados para diferentes tipos de fuzzing"""
        return {
            'directories': '/usr/share/wordlists/dirb/common.txt',
            'files': '/usr/share/seclists/Discovery/Web-Content/raft-medium-files.txt',
            'parameters': '/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt',
            'subdomains': '/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt'
        } 