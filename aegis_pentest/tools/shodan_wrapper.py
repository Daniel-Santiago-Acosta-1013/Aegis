"""
Wrapper para Shodan CLI - Inteligencia y reconocimiento
"""

import json
import logging
import ipaddress
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class ShodanResult:
    """Resultado de una búsqueda en Shodan"""
    target: str
    host_info: Dict[str, Any]
    open_ports: List[Dict[str, Any]]
    vulnerabilities: List[Dict[str, Any]]
    services: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class ShodanWrapper:
    """Wrapper para la herramienta Shodan CLI"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('shodan')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Shodan CLI está disponible"""
        return self.config.is_tool_available('shodan')
    
    def should_run_against_target(self, target: str, target_type: str, scan_phase: str = 'reconnaissance') -> bool:
        """Determina si Shodan debe ejecutarse contra el target"""
        # Ejecutar en fase de reconocimiento o intelligence gathering
        if scan_phase not in ['reconnaissance', 'intelligence', 'comprehensive']:
            return False
        
        # Solo ejecutar en IPs o dominios
        if target_type not in ['ip', 'domain']:
            return False
        
        # Verificar si hay API key disponible
        if not self.tool_config.get('api_key'):
            self.logger.warning("Shodan API key no configurada - saltando búsqueda")
            return False
        
        return True
    
    async def host_lookup(self, target: str) -> ShodanResult:
        """Busca información de un host específico en Shodan"""
        if not self.is_available():
            raise RuntimeError("Shodan CLI no está disponible")
        
        self.logger.info(f"Consultando Shodan para {target}")
        
        # Resolver dominio a IP si es necesario
        resolved_target = await self._resolve_target(target)
        
        # Comando para búsqueda de host
        cmd = [
            self.tool_config.get('path', 'shodan'),
            'host',
            resolved_target,
            '--format', 'json'
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="shodan",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 60)
            )
            
            if not process_result.success:
                # Shodan puede fallar si no encuentra información
                if 'no information available' in process_result.error_message.lower():
                    self.logger.info(f"No hay información en Shodan para {target}")
                    return self._create_empty_result(target)
                else:
                    raise RuntimeError(f"Shodan falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            # Parsear JSON de Shodan
            try:
                shodan_data = json.loads(stdout)
                return self._parse_shodan_data(target, shodan_data, stdout)
            
            except json.JSONDecodeError:
                self.logger.warning("No se pudo parsear respuesta JSON de Shodan")
                return self._create_empty_result(target)
            
        except Exception as e:
            self.logger.error(f"Error en Shodan: {str(e)}")
            raise
    
    async def search_query(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Ejecuta una búsqueda personalizada en Shodan"""
        if not self.is_available():
            raise RuntimeError("Shodan CLI no está disponible")
        
        self.logger.info(f"Ejecutando búsqueda Shodan: {query}")
        
        cmd = [
            self.tool_config.get('path', 'shodan'),
            'search',
            query,
            '--limit', str(limit),
            '--format', 'json'
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="shodan",
                command=cmd,
                target=query,
                timeout=self.tool_config.get('timeout', 120)
            )
            
            if not process_result.success:
                raise RuntimeError(f"Búsqueda Shodan falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            try:
                results = []
                for line in stdout.splitlines():
                    if line.strip():
                        results.append(json.loads(line))
                return results
            
            except json.JSONDecodeError:
                self.logger.warning("No se pudo parsear resultados de búsqueda Shodan")
                return []
            
        except Exception as e:
            self.logger.error(f"Error en búsqueda Shodan: {str(e)}")
            raise
    
    async def _resolve_target(self, target: str) -> str:
        """Resuelve un dominio a IP si es necesario"""
        try:
            # Verificar si ya es una IP
            ipaddress.ip_address(target)
            return target
        except ValueError:
            # Es un dominio, resolverlo
            import socket
            try:
                ip = socket.gethostbyname(target)
                self.logger.info(f"Resolviendo {target} -> {ip}")
                return ip
            except socket.gaierror:
                self.logger.warning(f"No se pudo resolver {target}")
                return target
    
    def _parse_shodan_data(self, target: str, data: Dict[str, Any], raw_output: str) -> ShodanResult:
        """Parsea los datos de Shodan a formato estructurado"""
        
        # Información del host
        host_info = {
            'ip': data.get('ip_str', target),
            'hostnames': data.get('hostnames', []),
            'org': data.get('org', 'Unknown'),
            'isp': data.get('isp', 'Unknown'),
            'country': data.get('country_name', 'Unknown'),
            'city': data.get('city', 'Unknown'),
            'asn': data.get('asn', 'Unknown'),
            'last_update': data.get('last_update', 'Unknown')
        }
        
        # Puertos abiertos y servicios
        open_ports = []
        services = []
        vulnerabilities = []
        
        for service_data in data.get('data', []):
            port = service_data.get('port', 0)
            protocol = service_data.get('transport', 'tcp')
            service_name = service_data.get('product', 'unknown')
            version = service_data.get('version', '')
            
            # Información del puerto
            port_info = {
                'port': port,
                'protocol': protocol,
                'state': 'open',
                'service': service_name,
                'version': version,
                'banner': service_data.get('data', '')[:200],
                'timestamp': service_data.get('timestamp', '')
            }
            open_ports.append(port_info)
            
            # Información del servicio
            service_info = {
                'port': port,
                'protocol': protocol,
                'service': service_name,
                'version': f"{service_data.get('product', '')} {version}".strip(),
                'banner': service_data.get('data', '')[:200],
                'ssl_info': service_data.get('ssl', {}),
                'http_info': service_data.get('http', {})
            }
            services.append(service_info)
            
            # Extraer vulnerabilidades si están presentes
            service_vulns = service_data.get('vulns', [])
            for vuln_id in service_vulns:
                vuln_info = {
                    'id': vuln_id,
                    'severity': 'UNKNOWN',  # Shodan no siempre provee severidad
                    'port': port,
                    'description': f"Vulnerabilidad {vuln_id} detectada en {service_name}",
                    'type': 'shodan',
                    'service': service_name,
                    'raw_data': service_data
                }
                vulnerabilities.append(vuln_info)
        
        scan_stats = {
            'total_ports': len(open_ports),
            'total_services': len(services),
            'total_vulnerabilities': len(vulnerabilities),
            'target': target,
            'source': 'shodan'
        }
        
        return ShodanResult(
            target=target,
            host_info=host_info,
            open_ports=open_ports,
            vulnerabilities=vulnerabilities,
            services=services,
            scan_stats=scan_stats,
            raw_output=raw_output
        )
    
    def _create_empty_result(self, target: str) -> ShodanResult:
        """Crea un resultado vacío cuando no hay información"""
        return ShodanResult(
            target=target,
            host_info={'ip': target, 'info': 'No information available'},
            open_ports=[],
            vulnerabilities=[],
            services=[],
            scan_stats={'total_ports': 0, 'total_services': 0, 'total_vulnerabilities': 0},
            raw_output=""
        )
    
    def get_search_templates(self) -> Dict[str, str]:
        """Obtiene plantillas de búsqueda comunes"""
        return {
            'web_servers': 'product:"Apache" OR product:"nginx" OR product:"IIS"',
            'databases': 'product:"MySQL" OR product:"PostgreSQL" OR product:"MongoDB"',
            'cameras': 'product:"webcam" OR "IP Camera"',
            'iot_devices': 'product:"Hikvision" OR "default password"',
            'vpn_servers': 'product:"OpenVPN" OR "VPN"',
            'rdp_servers': 'port:3389 product:"Microsoft Terminal Services"',
            'ssh_servers': 'port:22 product:"OpenSSH"',
            'ftp_servers': 'port:21 product:"FTP"'
        } 