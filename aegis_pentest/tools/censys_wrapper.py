"""
Wrapper para Censys CLI - Internet-wide scanning and intelligence
"""

import json
import logging
import ipaddress
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class CensysResult:
    """Resultado de una búsqueda en Censys"""
    target: str
    host_info: Dict[str, Any]
    certificates: List[Dict[str, Any]]
    services: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class CensysWrapper:
    """Wrapper para la herramienta Censys CLI"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('censys')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Censys CLI está disponible"""
        return self.config.is_tool_available('censys')
    
    def should_run_against_target(self, target: str, target_type: str, scan_phase: str = 'reconnaissance') -> bool:
        """Determina si Censys debe ejecutarse contra el target"""
        # Ejecutar en fase de reconocimiento o intelligence gathering
        if scan_phase not in ['reconnaissance', 'intelligence', 'comprehensive']:
            return False
        
        # Solo ejecutar en IPs o dominios
        if target_type not in ['ip', 'domain']:
            return False
        
        # Verificar si hay API credentials disponibles
        if not self.tool_config.get('api_id') or not self.tool_config.get('api_secret'):
            self.logger.warning("Censys API credentials no configuradas - saltando búsqueda")
            return False
        
        return True
    
    async def host_lookup(self, target: str) -> CensysResult:
        """Busca información de un host específico en Censys"""
        if not self.is_available():
            raise RuntimeError("Censys CLI no está disponible")
        
        self.logger.info(f"Consultando Censys para {target}")
        
        # Resolver dominio a IP si es necesario
        resolved_target = await self._resolve_target(target)
        
        # Comando para búsqueda de host
        cmd = [
            self.tool_config.get('path', 'censys'),
            'search',
            'hosts',
            resolved_target,
            '--format', 'json'
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="censys",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 60)
            )
            
            if not process_result.success:
                # Censys puede fallar si no encuentra información
                if 'no results' in process_result.error_message.lower():
                    self.logger.info(f"No hay información en Censys para {target}")
                    return self._create_empty_result(target)
                else:
                    raise RuntimeError(f"Censys falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            # Parsear JSON de Censys
            try:
                censys_data = json.loads(stdout)
                return self._parse_censys_data(target, censys_data, stdout)
            
            except json.JSONDecodeError:
                self.logger.warning("No se pudo parsear respuesta JSON de Censys")
                return self._create_empty_result(target)
            
        except Exception as e:
            self.logger.error(f"Error en Censys: {str(e)}")
            raise
    
    async def certificate_search(self, domain: str) -> List[Dict[str, Any]]:
        """Busca certificados SSL relacionados con un dominio"""
        if not self.is_available():
            raise RuntimeError("Censys CLI no está disponible")
        
        self.logger.info(f"Buscando certificados SSL para {domain}")
        
        cmd = [
            self.tool_config.get('path', 'censys'),
            'search',
            'certificates',
            f'names:{domain}',
            '--format', 'json',
            '--max-records', '50'
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="censys",
                command=cmd,
                target=domain,
                timeout=self.tool_config.get('timeout', 120)
            )
            
            if not process_result.success:
                raise RuntimeError(f"Búsqueda de certificados Censys falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            try:
                certificates = []
                for line in stdout.splitlines():
                    if line.strip():
                        cert_data = json.loads(line)
                        certificates.append(self._parse_certificate(cert_data))
                return certificates
            
            except json.JSONDecodeError:
                self.logger.warning("No se pudo parsear resultados de certificados Censys")
                return []
            
        except Exception as e:
            self.logger.error(f"Error en búsqueda de certificados Censys: {str(e)}")
            raise
    
    async def subdomain_discovery(self, domain: str) -> List[str]:
        """Descubre subdominios usando certificados SSL"""
        certificates = await self.certificate_search(domain)
        subdomains = set()
        
        for cert in certificates:
            # Extraer dominios de los nombres alternativos del certificado
            alt_names = cert.get('alt_names', [])
            for name in alt_names:
                if domain in name and name not in subdomains:
                    subdomains.add(name)
        
        return list(subdomains)
    
    async def _resolve_target(self, target: str) -> str:
        """Resuelve un dominio a IP si es necesario"""
        try:
            # Verificar si ya es una IP
            ipaddress.ip_address(target)
            return target
        except ValueError:
            # Es un dominio, resolverlo
            import socket
            try:
                ip = socket.gethostbyname(target)
                self.logger.info(f"Resolviendo {target} -> {ip}")
                return ip
            except socket.gaierror:
                self.logger.warning(f"No se pudo resolver {target}")
                return target
    
    def _parse_censys_data(self, target: str, data: Dict[str, Any], raw_output: str) -> CensysResult:
        """Parsea los datos de Censys a formato estructurado"""
        
        # Información del host
        host_info = {
            'ip': data.get('ip', target),
            'asn': data.get('autonomous_system', {}).get('asn', 'Unknown'),
            'org': data.get('autonomous_system', {}).get('organization', 'Unknown'),
            'country': data.get('location', {}).get('country', 'Unknown'),
            'city': data.get('location', {}).get('city', 'Unknown'),
            'last_updated': data.get('last_updated_at', 'Unknown')
        }
        
        # Servicios detectados
        services = []
        for service in data.get('services', []):
            service_info = {
                'port': service.get('port', 0),
                'protocol': service.get('transport_protocol', 'tcp'),
                'service': service.get('service_name', 'unknown'),
                'banner': service.get('banner', '')[:200],
                'tls': service.get('tls', {}),
                'http': service.get('http', {}),
                'timestamp': service.get('observed_at', '')
            }
            services.append(service_info)
        
        # Certificados
        certificates = []
        for service in data.get('services', []):
            if service.get('tls') and service.get('tls', {}).get('certificates'):
                for cert in service['tls']['certificates']:
                    cert_info = self._parse_certificate(cert)
                    certificates.append(cert_info)
        
        scan_stats = {
            'total_services': len(services),
            'total_certificates': len(certificates),
            'target': target,
            'source': 'censys'
        }
        
        return CensysResult(
            target=target,
            host_info=host_info,
            certificates=certificates,
            services=services,
            scan_stats=scan_stats,
            raw_output=raw_output
        )
    
    def _parse_certificate(self, cert_data: Dict[str, Any]) -> Dict[str, Any]:
        """Parsea información de un certificado SSL"""
        parsed_cert = cert_data.get('parsed', {})
        
        return {
            'fingerprint': cert_data.get('fingerprint_sha256', 'Unknown'),
            'issuer': parsed_cert.get('issuer', {}).get('common_name', ['Unknown'])[0] if parsed_cert.get('issuer', {}).get('common_name') else 'Unknown',
            'subject': parsed_cert.get('subject', {}).get('common_name', ['Unknown'])[0] if parsed_cert.get('subject', {}).get('common_name') else 'Unknown',
            'not_before': parsed_cert.get('validity', {}).get('start', 'Unknown'),
            'not_after': parsed_cert.get('validity', {}).get('end', 'Unknown'),
            'alt_names': parsed_cert.get('extensions', {}).get('subject_alt_name', {}).get('dns_names', []),
            'signature_algorithm': parsed_cert.get('signature', {}).get('signature_algorithm', {}).get('name', 'Unknown'),
            'key_algorithm': parsed_cert.get('subject_key_info', {}).get('key_algorithm', {}).get('name', 'Unknown')
        }
    
    def _create_empty_result(self, target: str) -> CensysResult:
        """Crea un resultado vacío cuando no hay información"""
        return CensysResult(
            target=target,
            host_info={'ip': target, 'info': 'No information available'},
            certificates=[],
            services=[],
            scan_stats={'total_services': 0, 'total_certificates': 0},
            raw_output=""
        )
    
    def get_search_examples(self) -> Dict[str, str]:
        """Obtiene ejemplos de búsqueda en Censys"""
        return {
            'apache_servers': 'services.software.product:"Apache httpd"',
            'nginx_servers': 'services.software.product:"nginx"',
            'open_databases': 'services.port:3306 or services.port:5432',
            'expired_certificates': 'services.tls.certificates.leaf_data.validity.end:[* TO now]',
            'weak_ssl': 'services.tls.cipher_suite.name:"RC4"',
            'default_passwords': 'services.banner:"default password"',
            'specific_country': 'location.country_code:"US"',
            'cloud_services': 'autonomous_system.organization:"Amazon" or autonomous_system.organization:"Google"'
        }
    
    def configure_api_credentials(self, api_id: str, api_secret: str):
        """Configura las credenciales de API de Censys"""
        import os
        
        # Configurar variables de entorno
        os.environ['CENSYS_API_ID'] = api_id
        os.environ['CENSYS_API_SECRET'] = api_secret
        
        self.logger.info("Credenciales de Censys configuradas")
    
    def get_rate_limits(self) -> Dict[str, Any]:
        """Información sobre los límites de rate de Censys"""
        return {
            'search_quota': '250 queries per month (free tier)',
            'bulk_quota': '1GB per month (free tier)',
            'rate_limit': '0.2 requests per second',
            'upgrade_info': 'Paid plans available for higher quotas'
        } 