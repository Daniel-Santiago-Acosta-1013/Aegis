"""
Wrapper para Nginxpwner - Herramienta específica para vulnerabilidades de Nginx
"""

import logging
import re
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class NginxpwnerResult:
    """Resultado de un escaneo con Nginxpwner"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    nginx_info: Dict[str, Any]
    scan_stats: Dict[str, Any]
    raw_output: str


class NginxpwnerWrapper:
    """Wrapper para la herramienta Nginxpwner"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nginxpwner')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Nginxpwner está disponible"""
        return self.config.is_tool_available('nginxpwner')
    
    def should_run_against_target(self, target: str, target_type: str, nmap_result=None, 
                                  nikto_result=None, service_info=None) -> bool:
        """Determina si Nginxpwner debe ejecutarse contra el target"""
        # Solo ejecutar en targets web
        if target_type not in ['url', 'domain']:
            return False
        
        # Verificar si hay evidencia de Nginx
        nginx_detected = False
        
        # 1. Verificar en resultados de nmap
        if nmap_result and hasattr(nmap_result, 'services'):
            for service in nmap_result.services:
                if 'nginx' in service.get('version', '').lower():
                    nginx_detected = True
                    self.logger.info(f"Nginx detectado en Nmap: {service.get('version')}")
                    break
        
        # 2. Verificar en resultados de Nikto si están disponibles
        if nikto_result:
            for vuln in nikto_result:
                if 'nginx' in str(vuln).lower():
                    nginx_detected = True
                    self.logger.info("Nginx detectado en resultados de Nikto")
                    break
        
        # 3. Verificar en información de servicios adicional
        if service_info:
            for service in service_info:
                if 'nginx' in str(service).lower():
                    nginx_detected = True
                    self.logger.info("Nginx detectado en información de servicios")
                    break
        
        if not nginx_detected:
            self.logger.info("Nginx no detectado - saltando Nginxpwner")
            return False
        
        return True
    
    async def scan(self, target: str) -> NginxpwnerResult:
        """Escanea vulnerabilidades específicas de Nginx"""
        if not self.is_available():
            raise RuntimeError("Nginxpwner no está disponible")
        
        self.logger.info(f"Iniciando escaneo Nginxpwner de {target}")
        
        # Preparar URL base
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        # Comando para Nginxpwner
        cmd = [
            self.tool_config.get('path', 'nginxpwner'),
            target,
            '--all',  # Ejecutar todas las pruebas
            '--timeout', str(self.tool_config.get('request_timeout', 10)),
            '--threads', str(self.tool_config.get('threads', 5))
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="nginxpwner",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 300)
            )
            
            if not process_result.success:
                # Nginxpwner puede fallar pero aún dar información útil
                self.logger.warning(f"Nginxpwner completó con advertencias: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            stderr = "\n".join(process_result.stderr_lines)
            full_output = stdout + stderr
            
            # Parsear resultados
            vulnerabilities = self._parse_vulnerabilities(full_output)
            nginx_info = self._extract_nginx_info(full_output)
            
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'target': target,
                'nginx_version': nginx_info.get('version', 'Unknown')
            }
            
            result = NginxpwnerResult(
                target=target,
                vulnerabilities=vulnerabilities,
                nginx_info=nginx_info,
                scan_stats=scan_stats,
                raw_output=full_output
            )
            
            self.logger.info(f"Escaneo Nginxpwner completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en Nginxpwner: {str(e)}")
            raise
    
    def _parse_vulnerabilities(self, output: str) -> List[Dict[str, Any]]:
        """Parsea las vulnerabilidades encontradas por Nginxpwner"""
        vulnerabilities = []
        lines = output.splitlines()
        
        for i, line in enumerate(lines):
            line = line.strip()
            
            # Buscar indicadores de vulnerabilidades
            if any(indicator in line.lower() for indicator in [
                'vulnerable', 'exploit', 'cve-', 'security', 'misconfiguration',
                'alias traversal', 'merge_slashes', 'missing headers'
            ]):
                
                # Determinar severidad basada en el contenido
                severity = self._determine_severity(line)
                
                # Extraer CVE si está presente
                cve_match = re.search(r'CVE-\d{4}-\d+', line, re.IGNORECASE)
                cve_id = cve_match.group(0) if cve_match else 'N/A'
                
                # Buscar descripción en líneas siguientes
                description = line
                for j in range(i+1, min(i+3, len(lines))):
                    if lines[j].strip() and not lines[j].startswith('['):
                        description += " " + lines[j].strip()
                        break
                
                vuln = {
                    'id': cve_id,
                    'severity': severity,
                    'port': 'N/A',
                    'description': description[:100],
                    'type': 'nginxpwner',
                    'vulnerability_type': self._classify_vulnerability(line),
                    'raw_data': {'line': line, 'context': description}
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_nginx_info(self, output: str) -> Dict[str, Any]:
        """Extrae información del servidor Nginx"""
        nginx_info = {
            'version': 'Unknown',
            'modules': [],
            'configuration_issues': []
        }
        
        lines = output.splitlines()
        
        for line in lines:
            line = line.strip()
            
            # Buscar versión de Nginx
            version_match = re.search(r'nginx[/\s](\d+\.\d+(?:\.\d+)?)', line, re.IGNORECASE)
            if version_match:
                nginx_info['version'] = version_match.group(1)
            
            # Buscar módulos
            if 'module' in line.lower():
                nginx_info['modules'].append(line)
            
            # Buscar problemas de configuración
            if any(issue in line.lower() for issue in [
                'misconfiguration', 'insecure', 'default', 'vulnerable'
            ]):
                nginx_info['configuration_issues'].append(line)
        
        return nginx_info
    
    def _determine_severity(self, line: str) -> str:
        """Determina la severidad basada en el contenido de la línea"""
        line_lower = line.lower()
        
        # Vulnerabilidades críticas
        if any(critical in line_lower for critical in [
            'remote code execution', 'rce', 'critical', 'cve-2021', 'cve-2022', 'cve-2023'
        ]):
            return 'CRITICAL'
        
        # Vulnerabilidades altas
        elif any(high in line_lower for high in [
            'directory traversal', 'path traversal', 'alias traversal', 'information disclosure'
        ]):
            return 'HIGH'
        
        # Vulnerabilidades medias
        elif any(medium in line_lower for medium in [
            'misconfiguration', 'missing headers', 'security headers'
        ]):
            return 'MEDIUM'
        
        # Por defecto
        else:
            return 'LOW'
    
    def _classify_vulnerability(self, line: str) -> str:
        """Clasifica el tipo de vulnerabilidad"""
        line_lower = line.lower()
        
        if 'alias' in line_lower or 'traversal' in line_lower:
            return 'Directory Traversal'
        elif 'merge_slashes' in line_lower:
            return 'Path Normalization'
        elif 'header' in line_lower:
            return 'Security Headers'
        elif 'cve' in line_lower:
            return 'Known CVE'
        elif 'configuration' in line_lower:
            return 'Misconfiguration'
        else:
            return 'Generic Nginx Issue'
    
    def get_vulnerability_types(self) -> List[str]:
        """Obtiene los tipos de vulnerabilidades que puede detectar"""
        return [
            'CVE-2021-23017 (DNS Resolver)',
            'Alias Traversal',
            'Merge Slashes',
            'Missing Security Headers',
            'Information Disclosure',
            'Path Normalization Issues',
            'Configuration Mismatches'
        ] 