"""
M√≥dulo de an√°lisis SSL/TLS usando OpenSSL
Proporciona an√°lisis detallado de certificados, configuraci√≥n SSL y seguridad
"""

import subprocess
import re
from datetime import datetime, timezone
from typing import Dict, List, Any
import asyncio
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import box


class SSLAnalyzer:
    """Analizador SSL/TLS usando OpenSSL"""
    
    def __init__(self, console: Console = None):
        self.console = console or Console()
        self.openssl_path = self._find_openssl()
        
    def _find_openssl(self) -> str:
        """Encuentra la ruta de OpenSSL en el sistema"""
        import shutil
        return shutil.which('openssl') or '/usr/bin/openssl'
    
    def is_available(self) -> bool:
        """Verifica si OpenSSL est√° disponible"""
        try:
            result = subprocess.run(
                [self.openssl_path, 'version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False
    
    def get_version(self) -> str:
        """Obtiene la versi√≥n de OpenSSL"""
        try:
            result = subprocess.run(
                [self.openssl_path, 'version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                return result.stdout.strip()
            return "Desconocida"
        except Exception:
            return "Error"
    
    async def analyze_domain(self, domain: str, port: int = 443) -> Dict[str, Any]:
        """An√°lisis completo SSL/TLS de un dominio"""
        results = {
            'domain': domain,
            'port': port,
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'certificate': {},
            'connection': {},
            'security': {},
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # An√°lisis del certificado
            cert_info = await self._get_certificate_info(domain, port)
            results['certificate'] = cert_info
            
            # An√°lisis de la conexi√≥n SSL
            conn_info = await self._analyze_ssl_connection(domain, port)
            results['connection'] = conn_info
            
            # An√°lisis de seguridad
            security_info = await self._analyze_ssl_security(domain, port)
            results['security'] = security_info
            
            # Detectar vulnerabilidades
            vulnerabilities = await self._check_ssl_vulnerabilities(domain, port)
            results['vulnerabilities'] = vulnerabilities
            
            # Generar recomendaciones
            recommendations = self._generate_recommendations(results)
            results['recommendations'] = recommendations
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def _get_certificate_info(self, domain: str, port: int) -> Dict[str, Any]:
        """Obtiene informaci√≥n detallada del certificado"""
        cert_info = {
            'subject': {},
            'issuer': {},
            'validity': {},
            'san': [],
            'signature_algorithm': '',
            'public_key': {},
            'extensions': {},
            'fingerprints': {}
        }
        
        try:
            # Obtener certificado con OpenSSL
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-servername', domain,
                '-showcerts'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                cert_text = stdout.decode('utf-8', errors='ignore')
                
                # Extraer el certificado
                cert_match = re.search(
                    r'-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----',
                    cert_text,
                    re.DOTALL
                )
                
                if cert_match:
                    cert_pem = cert_match.group(0)
                    
                    # Analizar certificado con OpenSSL
                    cert_details = await self._parse_certificate(cert_pem)
                    cert_info.update(cert_details)
            
        except Exception as e:
            cert_info['error'] = str(e)
        
        return cert_info
    
    async def _parse_certificate(self, cert_pem: str) -> Dict[str, Any]:
        """Analiza un certificado PEM con OpenSSL"""
        cert_info = {}
        
        try:
            # Crear archivo temporal para el certificado
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.pem', delete=False) as f:
                f.write(cert_pem)
                cert_file = f.name
            
            try:
                # Obtener informaci√≥n del certificado
                cmd = [self.openssl_path, 'x509', '-in', cert_file, '-text', '-noout']
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    cert_text = stdout.decode('utf-8')
                    cert_info = self._parse_certificate_text(cert_text)
                
                # Obtener fingerprints
                fingerprints = await self._get_certificate_fingerprints(cert_file)
                cert_info['fingerprints'] = fingerprints
                
            finally:
                # Limpiar archivo temporal
                Path(cert_file).unlink(missing_ok=True)
                
        except Exception as e:
            cert_info['error'] = str(e)
        
        return cert_info
    
    def _parse_certificate_text(self, cert_text: str) -> Dict[str, Any]:
        """Parsea el texto de salida de OpenSSL x509"""
        cert_info = {
            'subject': {},
            'issuer': {},
            'validity': {},
            'san': [],
            'signature_algorithm': '',
            'public_key': {},
            'extensions': {}
        }
        
        lines = cert_text.split('\n')
        current_section = None
        
        for line in lines:
            line = line.strip()
            
            # Subject
            if line.startswith('Subject:'):
                subject_str = line.replace('Subject:', '').strip()
                cert_info['subject'] = self._parse_dn(subject_str)
            
            # Issuer
            elif line.startswith('Issuer:'):
                issuer_str = line.replace('Issuer:', '').strip()
                cert_info['issuer'] = self._parse_dn(issuer_str)
            
            # Validity dates
            elif 'Not Before:' in line:
                date_str = line.split('Not Before:')[1].strip()
                cert_info['validity']['not_before'] = date_str
            
            elif 'Not After:' in line:
                date_str = line.split('Not After:')[1].strip()
                cert_info['validity']['not_after'] = date_str
            
            # Signature Algorithm
            elif 'Signature Algorithm:' in line and 'signature_algorithm' not in cert_info:
                cert_info['signature_algorithm'] = line.split('Signature Algorithm:')[1].strip()
            
            # Public Key Info
            elif 'Public Key Algorithm:' in line:
                cert_info['public_key']['algorithm'] = line.split('Public Key Algorithm:')[1].strip()
            
            elif 'Public-Key:' in line:
                key_size = re.search(r'\((\d+) bit\)', line)
                if key_size:
                    cert_info['public_key']['size'] = int(key_size.group(1))
            
            # Subject Alternative Names
            elif 'DNS:' in line:
                dns_names = re.findall(r'DNS:([^,\s]+)', line)
                cert_info['san'].extend(dns_names)
        
        # Calcular d√≠as hasta expiraci√≥n
        if cert_info['validity'].get('not_after'):
            try:
                expiry_date = datetime.strptime(
                    cert_info['validity']['not_after'].replace('GMT', '').strip(),
                    '%b %d %H:%M:%S %Y'
                )
                days_until_expiry = (expiry_date - datetime.now()).days
                cert_info['validity']['days_until_expiry'] = days_until_expiry
                cert_info['validity']['expired'] = days_until_expiry < 0
            except ValueError:
                pass
        
        return cert_info
    
    def _parse_dn(self, dn_str: str) -> Dict[str, str]:
        """Parsea un Distinguished Name"""
        dn = {}
        parts = [part.strip() for part in dn_str.split(',')]
        
        for part in parts:
            if '=' in part:
                key, value = part.split('=', 1)
                dn[key.strip()] = value.strip()
        
        return dn
    
    async def _get_certificate_fingerprints(self, cert_file: str) -> Dict[str, str]:
        """Obtiene fingerprints del certificado"""
        fingerprints = {}
        
        algorithms = ['md5', 'sha1', 'sha256']
        
        for algo in algorithms:
            try:
                cmd = [self.openssl_path, 'x509', '-in', cert_file, '-fingerprint', f'-{algo}', '-noout']
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    output = stdout.decode('utf-8').strip()
                    if '=' in output:
                        fingerprints[algo.upper()] = output.split('=')[1].strip()
                        
            except Exception:
                continue
        
        return fingerprints
    
    async def _analyze_ssl_connection(self, domain: str, port: int) -> Dict[str, Any]:
        """Analiza la conexi√≥n SSL/TLS"""
        conn_info = {
            'protocols': [],
            'ciphers': [],
            'supported_curves': [],
            'compression': False,
            'session_reuse': False,
            'ocsp_stapling': False,
            'hsts': False
        }
        
        try:
            # Probar diferentes protocolos TLS
            protocols = ['tls1_3', 'tls1_2', 'tls1_1', 'tls1', 'ssl3']
            
            for protocol in protocols:
                if await self._test_ssl_protocol(domain, port, protocol):
                    conn_info['protocols'].append(protocol.replace('_', '.').upper())
            
            # Obtener lista de ciphers soportados
            ciphers = await self._get_supported_ciphers(domain, port)
            conn_info['ciphers'] = ciphers
            
            # Verificar caracter√≠sticas de seguridad
            security_features = await self._check_security_features(domain, port)
            conn_info.update(security_features)
            
        except Exception as e:
            conn_info['error'] = str(e)
        
        return conn_info
    
    async def _test_ssl_protocol(self, domain: str, port: int, protocol: str) -> bool:
        """Prueba si un protocolo SSL/TLS espec√≠fico est√° soportado"""
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                f'-{protocol}',
                '-verify_return_error'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            return process.returncode == 0 and b'Verify return code: 0' in stdout
            
        except Exception:
            return False
    
    async def _get_supported_ciphers(self, domain: str, port: int) -> List[str]:
        """Obtiene lista de ciphers soportados"""
        ciphers = []
        
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-cipher', 'ALL'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                output = stdout.decode('utf-8')
                cipher_match = re.search(r'Cipher\s*:\s*([^\s\n]+)', output)
                if cipher_match:
                    ciphers.append(cipher_match.group(1))
                    
        except Exception:
            pass
        
        return ciphers
    
    async def _check_security_features(self, domain: str, port: int) -> Dict[str, bool]:
        """Verifica caracter√≠sticas de seguridad SSL/TLS"""
        features = {
            'compression': False,
            'session_reuse': False,
            'ocsp_stapling': False,
            'hsts': False
        }
        
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-status'  # Para OCSP stapling
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                output = stdout.decode('utf-8')
                
                # Verificar compresi√≥n
                features['compression'] = 'Compression: NONE' not in output
                
                # Verificar OCSP stapling
                features['ocsp_stapling'] = 'OCSP Response Status: successful' in output
                
        except Exception:
            pass
        
        return features
    
    async def _analyze_ssl_security(self, domain: str, port: int) -> Dict[str, Any]:
        """An√°lisis de seguridad SSL/TLS"""
        security = {
            'grade': 'Unknown',
            'score': 0,
            'weak_ciphers': [],
            'deprecated_protocols': [],
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Esta funci√≥n implementar√≠a un an√°lisis de seguridad m√°s profundo
            # Por ahora, implementamos verificaciones b√°sicas
            
            # Verificar protocolos obsoletos
            deprecated = ['SSL3', 'TLS1.0', 'TLS1.1']
            conn_info = await self._analyze_ssl_connection(domain, port)
            
            for protocol in conn_info.get('protocols', []):
                if protocol in deprecated:
                    security['deprecated_protocols'].append(protocol)
            
            # Calcular score b√°sico
            score = 100
            score -= len(security['deprecated_protocols']) * 20
            score -= len(security['weak_ciphers']) * 10
            security['score'] = max(0, score)
            
            # Asignar grado basado en score
            if security['score'] >= 80:
                security['grade'] = 'A'
            elif security['score'] >= 65:
                security['grade'] = 'B'
            elif security['score'] >= 50:
                security['grade'] = 'C'
            else:
                security['grade'] = 'F'
                
        except Exception as e:
            security['error'] = str(e)
        
        return security
    
    async def _check_ssl_vulnerabilities(self, domain: str, port: int) -> List[Dict[str, Any]]:
        """Verifica vulnerabilidades SSL/TLS conocidas"""
        vulnerabilities = []
        
        # Lista de vulnerabilidades comunes a verificar
        vuln_checks = [
            ('Heartbleed', self._check_heartbleed),
            ('POODLE', self._check_poodle),
            ('BEAST', self._check_beast),
            ('FREAK', self._check_freak)
        ]
        
        for vuln_name, check_func in vuln_checks:
            try:
                if await check_func(domain, port):
                    vulnerabilities.append({
                        'name': vuln_name,
                        'severity': 'High',
                        'description': f'El servidor es vulnerable a {vuln_name}',
                        'cve': self._get_vulnerability_cve(vuln_name)
                    })
            except Exception:
                continue
        
        return vulnerabilities
    
    async def _check_heartbleed(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad Heartbleed"""
        # Implementaci√≥n b√°sica - en producci√≥n se usar√≠a una verificaci√≥n m√°s robusta
        try:
            # OpenSSL puede detectar algunos aspectos de Heartbleed
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-tlsextdebug'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            # Esta es una verificaci√≥n simplificada
            return b'heartbeat' in stdout.lower()
            
        except Exception:
            return False
    
    async def _check_poodle(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad POODLE"""
        try:
            # POODLE afecta principalmente a SSL 3.0
            return await self._test_ssl_protocol(domain, port, 'ssl3')
        except Exception:
            return False
    
    async def _check_beast(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad BEAST"""
        try:
            # BEAST afecta principalmente a TLS 1.0 con ciertos ciphers
            if await self._test_ssl_protocol(domain, port, 'tls1'):
                # Verificar si usa ciphers vulnerables a BEAST
                ciphers = await self._get_supported_ciphers(domain, port)
                beast_vulnerable_ciphers = ['AES', 'DES']
                return any(cipher in ' '.join(ciphers) for cipher in beast_vulnerable_ciphers)
            return False
        except Exception:
            return False
    
    async def _check_freak(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad FREAK"""
        try:
            # FREAK involucra ciphers de exportaci√≥n d√©biles
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-cipher', 'EXPORT'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            return process.returncode == 0
            
        except Exception:
            return False
    
    def _get_vulnerability_cve(self, vuln_name: str) -> str:
        """Obtiene el CVE asociado a una vulnerabilidad"""
        cves = {
            'Heartbleed': 'CVE-2014-0160',
            'POODLE': 'CVE-2014-3566',
            'BEAST': 'CVE-2011-3389',
            'FREAK': 'CVE-2015-0204'
        }
        return cves.get(vuln_name, '')
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Genera recomendaciones basadas en el an√°lisis"""
        recommendations = []
        
        # Recomendaciones basadas en certificado
        cert = results.get('certificate', {})
        validity = cert.get('validity', {})
        
        if validity.get('days_until_expiry', 0) < 30:
            recommendations.append("üö® El certificado expira pronto. Renu√©velo antes de 30 d√≠as.")
        
        if validity.get('expired', False):
            recommendations.append("‚ùå El certificado ha expirado. Renu√©velo inmediatamente.")
        
        # Recomendaciones basadas en protocolos
        connection = results.get('connection', {})
        protocols = connection.get('protocols', [])
        
        if 'SSL3' in protocols:
            recommendations.append("üîí Deshabilite SSL 3.0 (vulnerable a POODLE).")
        
        if 'TLS1.0' in protocols:
            recommendations.append("üîí Considere deshabilitar TLS 1.0 (obsoleto).")
        
        if 'TLS1.1' in protocols:
            recommendations.append("üîí Considere deshabilitar TLS 1.1 (obsoleto).")
        
        if 'TLS1.3' not in protocols:
            recommendations.append("‚ú® Habilite TLS 1.3 para mejor seguridad y rendimiento.")
        
        # Recomendaciones basadas en vulnerabilidades
        vulnerabilities = results.get('vulnerabilities', [])
        
        if vulnerabilities:
            recommendations.append(f"‚ö†Ô∏è Se encontraron {len(vulnerabilities)} vulnerabilidades. Revise la configuraci√≥n SSL.")
        
        # Recomendaciones generales
        security = results.get('security', {})
        if security.get('grade', 'F') in ['C', 'D', 'F']:
            recommendations.append("üõ°Ô∏è La configuraci√≥n SSL necesita mejoras significativas.")
        
        return recommendations
    
    def display_results(self, results: Dict[str, Any]):
        """Muestra los resultados del an√°lisis SSL de forma visual"""
        domain = results.get('domain', 'Desconocido')
        port = results.get('port', 443)
        
        # Panel principal
        self.console.print(Panel(
            "[bold cyan]üîí AN√ÅLISIS SSL/TLS[/bold cyan]\n"
            f"[dim]Dominio: {domain}:{port}[/dim]",
            border_style="cyan"
        ))
        
        # Informaci√≥n del certificado
        self._display_certificate_info(results.get('certificate', {}))
        
        # Informaci√≥n de la conexi√≥n
        self._display_connection_info(results.get('connection', {}))
        
        # Informaci√≥n de seguridad
        self._display_security_info(results.get('security', {}))
        
        # Vulnerabilidades
        vulnerabilities = results.get('vulnerabilities', [])
        if vulnerabilities:
            self._display_vulnerabilities(vulnerabilities)
        
        # Recomendaciones
        recommendations = results.get('recommendations', [])
        if recommendations:
            self._display_recommendations(recommendations)
    
    def _display_certificate_info(self, cert_info: Dict[str, Any]):
        """Muestra informaci√≥n del certificado"""
        self.console.print(Panel(
            "[bold green]üìú INFORMACI√ìN DEL CERTIFICADO[/bold green]",
            border_style="green"
        ))
        
        cert_table = Table(box=box.ROUNDED)
        cert_table.add_column("Campo", style="cyan", min_width=15)
        cert_table.add_column("Valor", style="white")
        
        # Subject
        subject = cert_info.get('subject', {})
        if subject.get('CN'):
            cert_table.add_row("Sujeto (CN)", subject['CN'])
        
        # Issuer
        issuer = cert_info.get('issuer', {})
        if issuer.get('CN'):
            cert_table.add_row("Emisor (CN)", issuer['CN'])
        
        # Validity
        validity = cert_info.get('validity', {})
        if validity.get('not_before'):
            cert_table.add_row("V√°lido desde", validity['not_before'])
        if validity.get('not_after'):
            cert_table.add_row("V√°lido hasta", validity['not_after'])
        
        days_until_expiry = validity.get('days_until_expiry')
        if days_until_expiry is not None:
            color = "red" if days_until_expiry < 30 else "yellow" if days_until_expiry < 90 else "green"
            cert_table.add_row(
                "D√≠as hasta expirar",
                f"[{color}]{days_until_expiry} d√≠as[/{color}]"
            )
        
        # Algorithm
        if cert_info.get('signature_algorithm'):
            cert_table.add_row("Algoritmo firma", cert_info['signature_algorithm'])
        
        # Public Key
        public_key = cert_info.get('public_key', {})
        if public_key.get('algorithm'):
            key_info = public_key['algorithm']
            if public_key.get('size'):
                key_info += f" ({public_key['size']} bits)"
            cert_table.add_row("Clave p√∫blica", key_info)
        
        # SAN
        san = cert_info.get('san', [])
        if san:
            san_display = ', '.join(san[:5])
            if len(san) > 5:
                san_display += f' (+{len(san) - 5} m√°s)'
            cert_table.add_row("Subject Alt Names", san_display)
        
        self.console.print(cert_table)
        self.console.print()
    
    def _display_connection_info(self, conn_info: Dict[str, Any]):
        """Muestra informaci√≥n de la conexi√≥n SSL"""
        self.console.print(Panel(
            "[bold blue]üåê INFORMACI√ìN DE CONEXI√ìN[/bold blue]",
            border_style="blue"
        ))
        
        conn_table = Table(box=box.ROUNDED)
        conn_table.add_column("Aspecto", style="cyan", min_width=15)
        conn_table.add_column("Estado", style="white")
        
        # Protocolos soportados
        protocols = conn_info.get('protocols', [])
        if protocols:
            protocol_display = ', '.join(protocols)
            conn_table.add_row("Protocolos", protocol_display)
        
        # Ciphers
        ciphers = conn_info.get('ciphers', [])
        if ciphers:
            cipher_display = ', '.join(ciphers[:3])
            if len(ciphers) > 3:
                cipher_display += f' (+{len(ciphers) - 3} m√°s)'
            conn_table.add_row("Ciphers", cipher_display)
        
        # Caracter√≠sticas de seguridad
        features = [
            ('Compresi√≥n', conn_info.get('compression', False)),
            ('Reutilizaci√≥n sesi√≥n', conn_info.get('session_reuse', False)),
            ('OCSP Stapling', conn_info.get('ocsp_stapling', False)),
            ('HSTS', conn_info.get('hsts', False))
        ]
        
        for feature_name, enabled in features:
            status = "üü¢ S√≠" if enabled else "üî¥ No"
            conn_table.add_row(feature_name, status)
        
        self.console.print(conn_table)
        self.console.print()
    
    def _display_security_info(self, security_info: Dict[str, Any]):
        """Muestra informaci√≥n de seguridad"""
        grade = security_info.get('grade', 'Unknown')
        score = security_info.get('score', 0)
        
        # Color del grado
        grade_colors = {
            'A': 'green',
            'B': 'yellow',
            'C': 'orange',
            'D': 'red',
            'F': 'bright_red'
        }
        grade_color = grade_colors.get(grade, 'white')
        
        self.console.print(Panel(
            f"[bold {grade_color}]üõ°Ô∏è EVALUACI√ìN DE SEGURIDAD[/bold {grade_color}]\n"
            f"[bold]Grado: [{grade_color}]{grade}[/{grade_color}][/bold] | "
            f"[bold]Puntuaci√≥n: {score}/100[/bold]",
            border_style=grade_color
        ))
        
        # Mostrar problemas si existen
        deprecated_protocols = security_info.get('deprecated_protocols', [])
        weak_ciphers = security_info.get('weak_ciphers', [])
        
        if deprecated_protocols or weak_ciphers:
            security_table = Table(box=box.ROUNDED)
            security_table.add_column("Problema", style="red")
            security_table.add_column("Detalle", style="white")
            
            for protocol in deprecated_protocols:
                security_table.add_row("Protocolo obsoleto", protocol)
            
            for cipher in weak_ciphers:
                security_table.add_row("Cipher d√©bil", cipher)
            
            self.console.print(security_table)
        
        self.console.print()
    
    def _display_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]):
        """Muestra vulnerabilidades encontradas"""
        self.console.print(Panel(
            "[bold red]üö® VULNERABILIDADES DETECTADAS[/bold red]",
            border_style="red"
        ))
        
        vuln_table = Table(box=box.ROUNDED)
        vuln_table.add_column("Vulnerabilidad", style="red", min_width=12)
        vuln_table.add_column("Severidad", style="white", justify="center")
        vuln_table.add_column("CVE", style="cyan")
        vuln_table.add_column("Descripci√≥n", style="white")
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Unknown')
            severity_color = {
                'Critical': 'bright_red',
                'High': 'red',
                'Medium': 'yellow',
                'Low': 'green'
            }.get(severity, 'white')
            
            vuln_table.add_row(
                vuln.get('name', 'Unknown'),
                f"[{severity_color}]{severity}[/{severity_color}]",
                vuln.get('cve', 'N/A'),
                vuln.get('description', 'Sin descripci√≥n')
            )
        
        self.console.print(vuln_table)
        self.console.print()
    
    def _display_recommendations(self, recommendations: List[str]):
        """Muestra recomendaciones"""
        self.console.print(Panel(
            "[bold yellow]üí° RECOMENDACIONES[/bold yellow]",
            border_style="yellow"
        ))
        
        for recommendation in recommendations:
            self.console.print(f"  ‚Ä¢ {recommendation}")
        
        self.console.print() 