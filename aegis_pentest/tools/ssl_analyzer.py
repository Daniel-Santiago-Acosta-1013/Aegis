"""
Módulo de análisis SSL/TLS usando OpenSSL
Proporciona análisis detallado de certificados, configuración SSL y seguridad
"""

import subprocess
import re
from datetime import datetime, timezone
from typing import Dict, List, Any
import asyncio
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich import box


class SSLAnalyzer:
    """Analizador SSL/TLS usando OpenSSL"""
    
    def __init__(self, console: Console = None):
        self.console = console or Console()
        self.openssl_path = self._find_openssl()
        
    def _find_openssl(self) -> str:
        """Encuentra la ruta de OpenSSL en el sistema"""
        import shutil
        return shutil.which('openssl') or '/usr/bin/openssl'
    
    def is_available(self) -> bool:
        """Verifica si OpenSSL está disponible"""
        try:
            result = subprocess.run(
                [self.openssl_path, 'version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False
    
    def get_version(self) -> str:
        """Obtiene la versión de OpenSSL"""
        try:
            result = subprocess.run(
                [self.openssl_path, 'version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                return result.stdout.strip()
            return "Desconocida"
        except Exception:
            return "Error"
    
    async def analyze_domain(self, domain: str, port: int = 443) -> Dict[str, Any]:
        """Análisis completo SSL/TLS de un dominio"""
        results = {
            'domain': domain,
            'port': port,
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'certificate': {},
            'connection': {},
            'security': {},
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Análisis del certificado
            cert_info = await self._get_certificate_info(domain, port)
            results['certificate'] = cert_info
            
            # Análisis de la conexión SSL
            conn_info = await self._analyze_ssl_connection(domain, port)
            results['connection'] = conn_info
            
            # Análisis de seguridad
            security_info = await self._analyze_ssl_security(domain, port)
            results['security'] = security_info
            
            # Detectar vulnerabilidades
            vulnerabilities = await self._check_ssl_vulnerabilities(domain, port)
            results['vulnerabilities'] = vulnerabilities
            
            # Generar recomendaciones
            recommendations = self._generate_recommendations(results)
            results['recommendations'] = recommendations
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    async def _get_certificate_info(self, domain: str, port: int) -> Dict[str, Any]:
        """Obtiene información detallada del certificado"""
        cert_info = {
            'subject': {},
            'issuer': {},
            'validity': {},
            'san': [],
            'signature_algorithm': '',
            'public_key': {},
            'extensions': {},
            'fingerprints': {}
        }
        
        try:
            # Obtener certificado con OpenSSL
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-servername', domain,
                '-showcerts'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                cert_text = stdout.decode('utf-8', errors='ignore')
                
                # Extraer el certificado
                cert_match = re.search(
                    r'-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----',
                    cert_text,
                    re.DOTALL
                )
                
                if cert_match:
                    cert_pem = cert_match.group(0)
                    
                    # Analizar certificado con OpenSSL
                    cert_details = await self._parse_certificate(cert_pem)
                    cert_info.update(cert_details)
            
        except Exception as e:
            cert_info['error'] = str(e)
        
        return cert_info
    
    async def _parse_certificate(self, cert_pem: str) -> Dict[str, Any]:
        """Analiza un certificado PEM con OpenSSL"""
        cert_info = {}
        
        try:
            # Crear archivo temporal para el certificado
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', suffix='.pem', delete=False) as f:
                f.write(cert_pem)
                cert_file = f.name
            
            try:
                # Obtener información del certificado
                cmd = [self.openssl_path, 'x509', '-in', cert_file, '-text', '-noout']
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    cert_text = stdout.decode('utf-8')
                    cert_info = self._parse_certificate_text(cert_text)
                
                # Obtener fingerprints
                fingerprints = await self._get_certificate_fingerprints(cert_file)
                cert_info['fingerprints'] = fingerprints
                
            finally:
                # Limpiar archivo temporal
                Path(cert_file).unlink(missing_ok=True)
                
        except Exception as e:
            cert_info['error'] = str(e)
        
        return cert_info
    
    def _parse_certificate_text(self, cert_text: str) -> Dict[str, Any]:
        """Parsea el texto de salida de OpenSSL x509"""
        cert_info = {
            'subject': {},
            'issuer': {},
            'validity': {},
            'san': [],
            'signature_algorithm': '',
            'public_key': {},
            'extensions': {}
        }
        
        lines = cert_text.split('\n')
        current_section = None
        
        for line in lines:
            line = line.strip()
            
            # Subject
            if line.startswith('Subject:'):
                subject_str = line.replace('Subject:', '').strip()
                cert_info['subject'] = self._parse_dn(subject_str)
            
            # Issuer
            elif line.startswith('Issuer:'):
                issuer_str = line.replace('Issuer:', '').strip()
                cert_info['issuer'] = self._parse_dn(issuer_str)
            
            # Validity dates
            elif 'Not Before:' in line:
                date_str = line.split('Not Before:')[1].strip()
                cert_info['validity']['not_before'] = date_str
            
            elif 'Not After:' in line:
                date_str = line.split('Not After:')[1].strip()
                cert_info['validity']['not_after'] = date_str
            
            # Signature Algorithm
            elif 'Signature Algorithm:' in line and 'signature_algorithm' not in cert_info:
                cert_info['signature_algorithm'] = line.split('Signature Algorithm:')[1].strip()
            
            # Public Key Info
            elif 'Public Key Algorithm:' in line:
                cert_info['public_key']['algorithm'] = line.split('Public Key Algorithm:')[1].strip()
            
            elif 'Public-Key:' in line:
                key_size = re.search(r'\((\d+) bit\)', line)
                if key_size:
                    cert_info['public_key']['size'] = int(key_size.group(1))
            
            # Subject Alternative Names
            elif 'DNS:' in line:
                dns_names = re.findall(r'DNS:([^,\s]+)', line)
                cert_info['san'].extend(dns_names)
        
        # Calcular días hasta expiración
        if cert_info['validity'].get('not_after'):
            try:
                expiry_date = datetime.strptime(
                    cert_info['validity']['not_after'].replace('GMT', '').strip(),
                    '%b %d %H:%M:%S %Y'
                )
                days_until_expiry = (expiry_date - datetime.now()).days
                cert_info['validity']['days_until_expiry'] = days_until_expiry
                cert_info['validity']['expired'] = days_until_expiry < 0
            except ValueError:
                pass
        
        return cert_info
    
    def _parse_dn(self, dn_str: str) -> Dict[str, str]:
        """Parsea un Distinguished Name"""
        dn = {}
        parts = [part.strip() for part in dn_str.split(',')]
        
        for part in parts:
            if '=' in part:
                key, value = part.split('=', 1)
                dn[key.strip()] = value.strip()
        
        return dn
    
    async def _get_certificate_fingerprints(self, cert_file: str) -> Dict[str, str]:
        """Obtiene fingerprints del certificado"""
        fingerprints = {}
        
        algorithms = ['md5', 'sha1', 'sha256']
        
        for algo in algorithms:
            try:
                cmd = [self.openssl_path, 'x509', '-in', cert_file, '-fingerprint', f'-{algo}', '-noout']
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    output = stdout.decode('utf-8').strip()
                    if '=' in output:
                        fingerprints[algo.upper()] = output.split('=')[1].strip()
                        
            except Exception:
                continue
        
        return fingerprints
    
    async def _analyze_ssl_connection(self, domain: str, port: int) -> Dict[str, Any]:
        """Analiza la conexión SSL/TLS"""
        conn_info = {
            'protocols': [],
            'ciphers': [],
            'supported_curves': [],
            'compression': False,
            'session_reuse': False,
            'ocsp_stapling': False,
            'hsts': False
        }
        
        try:
            # Probar diferentes protocolos TLS
            protocols = ['tls1_3', 'tls1_2', 'tls1_1', 'tls1', 'ssl3']
            
            for protocol in protocols:
                if await self._test_ssl_protocol(domain, port, protocol):
                    conn_info['protocols'].append(protocol.replace('_', '.').upper())
            
            # Obtener lista de ciphers soportados
            ciphers = await self._get_supported_ciphers(domain, port)
            conn_info['ciphers'] = ciphers
            
            # Verificar características de seguridad
            security_features = await self._check_security_features(domain, port)
            conn_info.update(security_features)
            
        except Exception as e:
            conn_info['error'] = str(e)
        
        return conn_info
    
    async def _test_ssl_protocol(self, domain: str, port: int, protocol: str) -> bool:
        """Prueba si un protocolo SSL/TLS específico está soportado"""
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                f'-{protocol}',
                '-verify_return_error'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            return process.returncode == 0 and b'Verify return code: 0' in stdout
            
        except Exception:
            return False
    
    async def _get_supported_ciphers(self, domain: str, port: int) -> List[str]:
        """Obtiene lista de ciphers soportados"""
        ciphers = []
        
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-cipher', 'ALL'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                output = stdout.decode('utf-8')
                cipher_match = re.search(r'Cipher\s*:\s*([^\s\n]+)', output)
                if cipher_match:
                    ciphers.append(cipher_match.group(1))
                    
        except Exception:
            pass
        
        return ciphers
    
    async def _check_security_features(self, domain: str, port: int) -> Dict[str, bool]:
        """Verifica características de seguridad SSL/TLS"""
        features = {
            'compression': False,
            'session_reuse': False,
            'ocsp_stapling': False,
            'hsts': False
        }
        
        try:
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-status'  # Para OCSP stapling
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            if process.returncode == 0:
                output = stdout.decode('utf-8')
                
                # Verificar compresión
                features['compression'] = 'Compression: NONE' not in output
                
                # Verificar OCSP stapling
                features['ocsp_stapling'] = 'OCSP Response Status: successful' in output
                
        except Exception:
            pass
        
        return features
    
    async def _analyze_ssl_security(self, domain: str, port: int) -> Dict[str, Any]:
        """Análisis de seguridad SSL/TLS"""
        security = {
            'grade': 'Unknown',
            'score': 0,
            'weak_ciphers': [],
            'deprecated_protocols': [],
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Esta función implementaría un análisis de seguridad más profundo
            # Por ahora, implementamos verificaciones básicas
            
            # Verificar protocolos obsoletos
            deprecated = ['SSL3', 'TLS1.0', 'TLS1.1']
            conn_info = await self._analyze_ssl_connection(domain, port)
            
            for protocol in conn_info.get('protocols', []):
                if protocol in deprecated:
                    security['deprecated_protocols'].append(protocol)
            
            # Calcular score básico
            score = 100
            score -= len(security['deprecated_protocols']) * 20
            score -= len(security['weak_ciphers']) * 10
            security['score'] = max(0, score)
            
            # Asignar grado basado en score
            if security['score'] >= 80:
                security['grade'] = 'A'
            elif security['score'] >= 65:
                security['grade'] = 'B'
            elif security['score'] >= 50:
                security['grade'] = 'C'
            else:
                security['grade'] = 'F'
                
        except Exception as e:
            security['error'] = str(e)
        
        return security
    
    async def _check_ssl_vulnerabilities(self, domain: str, port: int) -> List[Dict[str, Any]]:
        """Verifica vulnerabilidades SSL/TLS conocidas"""
        vulnerabilities = []
        
        # Lista de vulnerabilidades comunes a verificar
        vuln_checks = [
            ('Heartbleed', self._check_heartbleed),
            ('POODLE', self._check_poodle),
            ('BEAST', self._check_beast),
            ('FREAK', self._check_freak)
        ]
        
        for vuln_name, check_func in vuln_checks:
            try:
                if await check_func(domain, port):
                    vulnerabilities.append({
                        'name': vuln_name,
                        'severity': 'High',
                        'description': f'El servidor es vulnerable a {vuln_name}',
                        'cve': self._get_vulnerability_cve(vuln_name)
                    })
            except Exception:
                continue
        
        return vulnerabilities
    
    async def _check_heartbleed(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad Heartbleed"""
        # Implementación básica - en producción se usaría una verificación más robusta
        try:
            # OpenSSL puede detectar algunos aspectos de Heartbleed
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-tlsextdebug'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            # Esta es una verificación simplificada
            return b'heartbeat' in stdout.lower()
            
        except Exception:
            return False
    
    async def _check_poodle(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad POODLE"""
        try:
            # POODLE afecta principalmente a SSL 3.0
            return await self._test_ssl_protocol(domain, port, 'ssl3')
        except Exception:
            return False
    
    async def _check_beast(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad BEAST"""
        try:
            # BEAST afecta principalmente a TLS 1.0 con ciertos ciphers
            if await self._test_ssl_protocol(domain, port, 'tls1'):
                # Verificar si usa ciphers vulnerables a BEAST
                ciphers = await self._get_supported_ciphers(domain, port)
                beast_vulnerable_ciphers = ['AES', 'DES']
                return any(cipher in ' '.join(ciphers) for cipher in beast_vulnerable_ciphers)
            return False
        except Exception:
            return False
    
    async def _check_freak(self, domain: str, port: int) -> bool:
        """Verifica vulnerabilidad FREAK"""
        try:
            # FREAK involucra ciphers de exportación débiles
            cmd = [
                self.openssl_path, 's_client',
                '-connect', f'{domain}:{port}',
                '-cipher', 'EXPORT'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate(input=b'\n')
            
            return process.returncode == 0
            
        except Exception:
            return False
    
    def _get_vulnerability_cve(self, vuln_name: str) -> str:
        """Obtiene el CVE asociado a una vulnerabilidad"""
        cves = {
            'Heartbleed': 'CVE-2014-0160',
            'POODLE': 'CVE-2014-3566',
            'BEAST': 'CVE-2011-3389',
            'FREAK': 'CVE-2015-0204'
        }
        return cves.get(vuln_name, '')
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Genera recomendaciones basadas en el análisis"""
        recommendations = []
        
        # Recomendaciones basadas en certificado
        cert = results.get('certificate', {})
        validity = cert.get('validity', {})
        
        if validity.get('days_until_expiry', 0) < 30:
            recommendations.append("🚨 El certificado expira pronto. Renuévelo antes de 30 días.")
        
        if validity.get('expired', False):
            recommendations.append("❌ El certificado ha expirado. Renuévelo inmediatamente.")
        
        # Recomendaciones basadas en protocolos
        connection = results.get('connection', {})
        protocols = connection.get('protocols', [])
        
        if 'SSL3' in protocols:
            recommendations.append("🔒 Deshabilite SSL 3.0 (vulnerable a POODLE).")
        
        if 'TLS1.0' in protocols:
            recommendations.append("🔒 Considere deshabilitar TLS 1.0 (obsoleto).")
        
        if 'TLS1.1' in protocols:
            recommendations.append("🔒 Considere deshabilitar TLS 1.1 (obsoleto).")
        
        if 'TLS1.3' not in protocols:
            recommendations.append("✨ Habilite TLS 1.3 para mejor seguridad y rendimiento.")
        
        # Recomendaciones basadas en vulnerabilidades
        vulnerabilities = results.get('vulnerabilities', [])
        
        if vulnerabilities:
            recommendations.append(f"⚠️ Se encontraron {len(vulnerabilities)} vulnerabilidades. Revise la configuración SSL.")
        
        # Recomendaciones generales
        security = results.get('security', {})
        if security.get('grade', 'F') in ['C', 'D', 'F']:
            recommendations.append("🛡️ La configuración SSL necesita mejoras significativas.")
        
        return recommendations
    
    def display_results(self, results: Dict[str, Any]):
        """Muestra los resultados del análisis SSL de forma visual"""
        domain = results.get('domain', 'Desconocido')
        port = results.get('port', 443)
        
        # Panel principal
        self.console.print(Panel(
            "[bold cyan]🔒 ANÁLISIS SSL/TLS[/bold cyan]\n"
            f"[dim]Dominio: {domain}:{port}[/dim]",
            border_style="cyan"
        ))
        
        # Información del certificado
        self._display_certificate_info(results.get('certificate', {}))
        
        # Información de la conexión
        self._display_connection_info(results.get('connection', {}))
        
        # Información de seguridad
        self._display_security_info(results.get('security', {}))
        
        # Vulnerabilidades
        vulnerabilities = results.get('vulnerabilities', [])
        if vulnerabilities:
            self._display_vulnerabilities(vulnerabilities)
        
        # Recomendaciones
        recommendations = results.get('recommendations', [])
        if recommendations:
            self._display_recommendations(recommendations)
    
    def _display_certificate_info(self, cert_info: Dict[str, Any]):
        """Muestra información del certificado"""
        self.console.print(Panel(
            "[bold green]📜 INFORMACIÓN DEL CERTIFICADO[/bold green]",
            border_style="green"
        ))
        
        cert_table = Table(box=box.ROUNDED)
        cert_table.add_column("Campo", style="cyan", min_width=15)
        cert_table.add_column("Valor", style="white")
        
        # Subject
        subject = cert_info.get('subject', {})
        if subject.get('CN'):
            cert_table.add_row("Sujeto (CN)", subject['CN'])
        
        # Issuer
        issuer = cert_info.get('issuer', {})
        if issuer.get('CN'):
            cert_table.add_row("Emisor (CN)", issuer['CN'])
        
        # Validity
        validity = cert_info.get('validity', {})
        if validity.get('not_before'):
            cert_table.add_row("Válido desde", validity['not_before'])
        if validity.get('not_after'):
            cert_table.add_row("Válido hasta", validity['not_after'])
        
        days_until_expiry = validity.get('days_until_expiry')
        if days_until_expiry is not None:
            color = "red" if days_until_expiry < 30 else "yellow" if days_until_expiry < 90 else "green"
            cert_table.add_row(
                "Días hasta expirar",
                f"[{color}]{days_until_expiry} días[/{color}]"
            )
        
        # Algorithm
        if cert_info.get('signature_algorithm'):
            cert_table.add_row("Algoritmo firma", cert_info['signature_algorithm'])
        
        # Public Key
        public_key = cert_info.get('public_key', {})
        if public_key.get('algorithm'):
            key_info = public_key['algorithm']
            if public_key.get('size'):
                key_info += f" ({public_key['size']} bits)"
            cert_table.add_row("Clave pública", key_info)
        
        # SAN
        san = cert_info.get('san', [])
        if san:
            san_display = ', '.join(san[:5])
            if len(san) > 5:
                san_display += f' (+{len(san) - 5} más)'
            cert_table.add_row("Subject Alt Names", san_display)
        
        self.console.print(cert_table)
        self.console.print()
    
    def _display_connection_info(self, conn_info: Dict[str, Any]):
        """Muestra información de la conexión SSL"""
        self.console.print(Panel(
            "[bold blue]🌐 INFORMACIÓN DE CONEXIÓN[/bold blue]",
            border_style="blue"
        ))
        
        conn_table = Table(box=box.ROUNDED)
        conn_table.add_column("Aspecto", style="cyan", min_width=15)
        conn_table.add_column("Estado", style="white")
        
        # Protocolos soportados
        protocols = conn_info.get('protocols', [])
        if protocols:
            protocol_display = ', '.join(protocols)
            conn_table.add_row("Protocolos", protocol_display)
        
        # Ciphers
        ciphers = conn_info.get('ciphers', [])
        if ciphers:
            cipher_display = ', '.join(ciphers[:3])
            if len(ciphers) > 3:
                cipher_display += f' (+{len(ciphers) - 3} más)'
            conn_table.add_row("Ciphers", cipher_display)
        
        # Características de seguridad
        features = [
            ('Compresión', conn_info.get('compression', False)),
            ('Reutilización sesión', conn_info.get('session_reuse', False)),
            ('OCSP Stapling', conn_info.get('ocsp_stapling', False)),
            ('HSTS', conn_info.get('hsts', False))
        ]
        
        for feature_name, enabled in features:
            status = "🟢 Sí" if enabled else "🔴 No"
            conn_table.add_row(feature_name, status)
        
        self.console.print(conn_table)
        self.console.print()
    
    def _display_security_info(self, security_info: Dict[str, Any]):
        """Muestra información de seguridad"""
        grade = security_info.get('grade', 'Unknown')
        score = security_info.get('score', 0)
        
        # Color del grado
        grade_colors = {
            'A': 'green',
            'B': 'yellow',
            'C': 'orange',
            'D': 'red',
            'F': 'bright_red'
        }
        grade_color = grade_colors.get(grade, 'white')
        
        self.console.print(Panel(
            f"[bold {grade_color}]🛡️ EVALUACIÓN DE SEGURIDAD[/bold {grade_color}]\n"
            f"[bold]Grado: [{grade_color}]{grade}[/{grade_color}][/bold] | "
            f"[bold]Puntuación: {score}/100[/bold]",
            border_style=grade_color
        ))
        
        # Mostrar problemas si existen
        deprecated_protocols = security_info.get('deprecated_protocols', [])
        weak_ciphers = security_info.get('weak_ciphers', [])
        
        if deprecated_protocols or weak_ciphers:
            security_table = Table(box=box.ROUNDED)
            security_table.add_column("Problema", style="red")
            security_table.add_column("Detalle", style="white")
            
            for protocol in deprecated_protocols:
                security_table.add_row("Protocolo obsoleto", protocol)
            
            for cipher in weak_ciphers:
                security_table.add_row("Cipher débil", cipher)
            
            self.console.print(security_table)
        
        self.console.print()
    
    def _display_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]):
        """Muestra vulnerabilidades encontradas"""
        self.console.print(Panel(
            "[bold red]🚨 VULNERABILIDADES DETECTADAS[/bold red]",
            border_style="red"
        ))
        
        vuln_table = Table(box=box.ROUNDED)
        vuln_table.add_column("Vulnerabilidad", style="red", min_width=12)
        vuln_table.add_column("Severidad", style="white", justify="center")
        vuln_table.add_column("CVE", style="cyan")
        vuln_table.add_column("Descripción", style="white")
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Unknown')
            severity_color = {
                'Critical': 'bright_red',
                'High': 'red',
                'Medium': 'yellow',
                'Low': 'green'
            }.get(severity, 'white')
            
            vuln_table.add_row(
                vuln.get('name', 'Unknown'),
                f"[{severity_color}]{severity}[/{severity_color}]",
                vuln.get('cve', 'N/A'),
                vuln.get('description', 'Sin descripción')
            )
        
        self.console.print(vuln_table)
        self.console.print()
    
    def _display_recommendations(self, recommendations: List[str]):
        """Muestra recomendaciones"""
        self.console.print(Panel(
            "[bold yellow]💡 RECOMENDACIONES[/bold yellow]",
            border_style="yellow"
        ))
        
        for recommendation in recommendations:
            self.console.print(f"  • {recommendation}")
        
        self.console.print() 