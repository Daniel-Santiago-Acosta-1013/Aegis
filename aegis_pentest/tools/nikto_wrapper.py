"""
Wrapper para Nikto - Escáner de vulnerabilidades web
"""

import asyncio
import logging
import subprocess
from typing import Dict, List, Optional, Any
from dataclasses import dataclass


@dataclass
class NiktoResult:
    """Resultado de un escaneo Nikto"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class NiktoWrapper:
    """Wrapper para la herramienta Nikto"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nikto')
        self.logger = logging.getLogger(__name__)
    
    def is_available(self) -> bool:
        """Verifica si Nikto está disponible"""
        return self.config.is_tool_available('nikto')
    
    async def scan(self, target: str, port: int = None, ssl: bool = None) -> NiktoResult:
        """
        Ejecuta un escaneo con Nikto
        
        Args:
            target: URL o host objetivo
            port: Puerto específico a escanear
            ssl: Forzar uso de SSL/TLS
            
        Returns:
            NiktoResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Nikto no está disponible")
        
        self.logger.info(f"Iniciando escaneo Nikto de {target}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'nikto'),
            '-h', target,
            '-Format', 'csv',
            '-nointeractive'
        ]
        
        # Agregar puerto si se especifica
        if port:
            cmd.extend(['-p', str(port)])
        
        # Forzar SSL si se especifica
        if ssl:
            cmd.extend(['-ssl'])
        
        try:
            # Ejecutar comando
            loop = asyncio.get_event_loop()
            stdout, stderr = await loop.run_in_executor(
                None,
                self._run_nikto_command,
                cmd
            )
            
            # Parsear resultados CSV
            vulnerabilities = self._parse_csv_output(stdout)
            
            # Estadísticas
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'target': target,
                'port': port,
                'ssl_used': ssl
            }
            
            result = NiktoResult(
                target=target,
                vulnerabilities=vulnerabilities,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo Nikto completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo Nikto: {str(e)}")
            raise
    
    def _run_nikto_command(self, cmd: List[str]) -> tuple:
        """Ejecuta el comando Nikto de forma síncrona"""
        timeout = self.tool_config.get('timeout', 600)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            
            return result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Timeout de Nikto ({timeout}s) excedido")
        except Exception as e:
            raise RuntimeError(f"Error ejecutando Nikto: {str(e)}")
    
    def _parse_csv_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida CSV de Nikto"""
        vulnerabilities = []
        
        lines = output.splitlines()
        for line in lines:
            line = line.strip()
            if not line or line.startswith('"Nikto'):
                continue
            
            # Parsear línea CSV
            # Formato: "host","ip","port","vuln_id","method","uri","description"
            parts = []
            current_part = ""
            in_quotes = False
            
            for char in line:
                if char == '"':
                    in_quotes = not in_quotes
                elif char == ',' and not in_quotes:
                    parts.append(current_part.strip('"'))
                    current_part = ""
                else:
                    current_part += char
            
            if current_part:
                parts.append(current_part.strip('"'))
            
            if len(parts) >= 7:
                vuln = {
                    'host': parts[0],
                    'ip': parts[1],
                    'port': parts[2],
                    'vuln_id': parts[3],
                    'method': parts[4],
                    'uri': parts[5],
                    'description': parts[6],
                    'severity': self._determine_severity(parts[6]),
                    'type': 'web_vulnerability'
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _determine_severity(self, description: str) -> str:
        """Determina la severidad basada en la descripción"""
        description_lower = description.lower()
        
        # Patrones de alta severidad
        high_patterns = ['sql injection', 'xss', 'code injection', 'file inclusion', 'remote file']
        if any(pattern in description_lower for pattern in high_patterns):
            return 'high'
        
        # Patrones de severidad media
        medium_patterns = ['directory traversal', 'information disclosure', 'authentication bypass']
        if any(pattern in description_lower for pattern in medium_patterns):
            return 'medium'
        
        # Patrones de baja severidad
        low_patterns = ['banner', 'version', 'misconfiguration', 'default']
        if any(pattern in description_lower for pattern in low_patterns):
            return 'low'
        
        return 'info'
    
    async def scan_ssl(self, target: str, port: int = 443) -> NiktoResult:
        """Escanea un objetivo HTTPS/SSL"""
        return await self.scan(target, port=port, ssl=True)
    
    async def scan_multiple_ports(self, target: str, ports: List[int]) -> List[NiktoResult]:
        """Escanea múltiples puertos del mismo objetivo"""
        results = []
        
        for port in ports:
            try:
                result = await self.scan(target, port=port)
                results.append(result)
            except Exception as e:
                self.logger.error(f"Error escaneando puerto {port}: {e}")
        
        return results 