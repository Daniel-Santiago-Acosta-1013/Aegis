"""
Wrapper para Nikto - Escáner de vulnerabilidades web
"""

import logging
import subprocess
from typing import Dict, List, Any
from dataclasses import dataclass
from pathlib import Path


@dataclass
class NiktoResult:
    """Resultado de un escaneo Nikto"""
    target: str
    vulnerabilities: List[Dict[str, Any]]
    scan_stats: Dict[str, Any]
    raw_output: str


class NiktoWrapper:
    """Wrapper para la herramienta Nikto"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('nikto')
        self.logger = logging.getLogger(__name__)
        
        # Inicializar process_runner para logging integrado
        from aegis_pentest.utils.process_runner import get_process_runner
        from aegis_pentest.utils.logger import get_logger
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si Nikto está disponible"""
        return self.config.is_tool_available('nikto')
    
    async def scan(self, target: str, port: int = None, ssl: bool = None) -> NiktoResult:
        """
        Ejecuta un escaneo con Nikto
        
        Args:
            target: URL o host objetivo
            port: Puerto específico a escanear
            ssl: Forzar uso de SSL/TLS
            
        Returns:
            NiktoResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("Nikto no está disponible")
        
        self.logger.info(f"Iniciando escaneo Nikto de {target}")
        
        # Construir comando optimizado para eficiencia
        cmd = [
            self.tool_config.get('path', 'nikto'),
            '-h', target,
            '-Format', 'csv',
            '-output', '/tmp/nikto_output.csv',
            '-nointeractive',
            '-maxtime', '1800',  # Máximo 30 minutos
            '-Display', 'V',     # Solo vulnerabilidades, no información
            '-Tuning', '1,2,3,4,5,6,7,8,9,0,a,b,c',  # Todas las categorías importantes
            '-timeout', '10'     # Timeout por request
        ]
        
        # Agregar puerto si se especifica
        if port:
            cmd.extend(['-p', str(port)])
        
        # Forzar SSL si se especifica
        if ssl:
            cmd.extend(['-ssl'])
        
        try:
            # Ejecutar comando usando process_runner para logging integrado
            process_result = await self.process_runner.run_tool_async(
                tool_name="nikto",
                command=cmd,
                target=target,
                timeout=self.tool_config.get('timeout', 1800)  # Aumentar timeout a 30 minutos
            )
            
            # Verificar si fue timeout y aún así tiene datos útiles
            if not process_result.success:
                if process_result.timeout_occurred:
                    self.logger.warning(f"Nikto timeout pero continuando con datos parciales")
                    # Intentar parsear lo que se pudo obtener
                else:
                    raise RuntimeError(f"Nikto falló: {process_result.error_message}")
            
            # Parsear resultados CSV desde archivo o stdout
            csv_output_file = '/tmp/nikto_output.csv'
            vulnerabilities = []
            stdout = "\n".join(process_result.stdout_lines)
            
            # Intentar primero el archivo CSV
            if Path(csv_output_file).exists():
                try:
                    with open(csv_output_file, 'r') as f:
                        csv_content = f.read()
                    if csv_content.strip():
                        vulnerabilities = self._parse_csv_output(csv_content)
                        self.logger.info(f"Vulnerabilidades parseadas desde archivo CSV: {len(vulnerabilities)}")
                except Exception as e:
                    self.logger.warning(f"Error leyendo archivo CSV: {e}")
            
            # Si no hay archivo CSV o está vacío, parsear desde stdout
            if not vulnerabilities and stdout:
                vulnerabilities = self._parse_text_output(stdout)
                self.logger.info(f"Vulnerabilidades parseadas desde stdout: {len(vulnerabilities)}")
            
            # Si aún no hay vulnerabilidades, crear al menos las básicas encontradas
            if not vulnerabilities and stdout:
                vulnerabilities = self._extract_basic_findings(stdout)
                self.logger.info(f"Hallazgos básicos extraídos: {len(vulnerabilities)}")
            
            # Estadísticas mejoradas
            scan_stats = {
                'total_vulnerabilities': len(vulnerabilities),
                'target': target,
                'port': port,
                'ssl_used': ssl,
                'scan_completed': process_result.success,
                'timeout_occurred': process_result.timeout_occurred if hasattr(process_result, 'timeout_occurred') else False,
                'scan_duration': process_result.duration
            }
            
            result = NiktoResult(
                target=target,
                vulnerabilities=vulnerabilities,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo Nikto completado: {len(vulnerabilities)} vulnerabilidades encontradas")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo Nikto: {str(e)}")
            raise
    
    def _run_nikto_command(self, cmd: List[str]) -> tuple:
        """Ejecuta el comando Nikto de forma síncrona"""
        timeout = self.tool_config.get('timeout', 600)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            
            return result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Timeout de Nikto ({timeout}s) excedido")
        except Exception as e:
            raise RuntimeError(f"Error ejecutando Nikto: {str(e)}")
    
    def _parse_csv_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida CSV de Nikto"""
        vulnerabilities = []
        
        lines = output.splitlines()
        for line in lines:
            line = line.strip()
            if not line or line.startswith('"Nikto'):
                continue
            
            # Parsear línea CSV
            # Formato: "host","ip","port","vuln_id","method","uri","description"
            parts = []
            current_part = ""
            in_quotes = False
            
            for char in line:
                if char == '"':
                    in_quotes = not in_quotes
                elif char == ',' and not in_quotes:
                    parts.append(current_part.strip('"'))
                    current_part = ""
                else:
                    current_part += char
            
            if current_part:
                parts.append(current_part.strip('"'))
            
            if len(parts) >= 7:
                vuln = {
                    'host': parts[0],
                    'ip': parts[1],
                    'port': parts[2],
                    'vuln_id': parts[3],
                    'method': parts[4],
                    'uri': parts[5],
                    'description': parts[6],
                    'severity': self._determine_severity(parts[6]),
                    'type': 'web_vulnerability'
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _determine_severity(self, description: str) -> str:
        """Determina la severidad basada en la descripción"""
        description_lower = description.lower()
        
        # Patrones de alta severidad
        high_patterns = ['sql injection', 'xss', 'code injection', 'file inclusion', 'remote file']
        if any(pattern in description_lower for pattern in high_patterns):
            return 'high'
        
        # Patrones de severidad media
        medium_patterns = ['directory traversal', 'information disclosure', 'authentication bypass']
        if any(pattern in description_lower for pattern in medium_patterns):
            return 'medium'
        
        # Patrones de baja severidad
        low_patterns = ['banner', 'version', 'misconfiguration', 'default']
        if any(pattern in description_lower for pattern in low_patterns):
            return 'low'
        
        return 'info'
    
    async def scan_ssl(self, target: str, port: int = 443) -> NiktoResult:
        """Escanea un objetivo HTTPS/SSL"""
        return await self.scan(target, port=port, ssl=True)
    
    async def scan_multiple_ports(self, target: str, ports: List[int]) -> List[NiktoResult]:
        """Escanea múltiples puertos del mismo objetivo"""
        results = []
        
        for port in ports:
            try:
                result = await self.scan(target, port=port)
                results.append(result)
            except Exception as e:
                self.logger.error(f"Error escaneando puerto {port}: {e}")
        
        return results
    
    def _parse_text_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida de texto de Nikto cuando CSV no está disponible"""
        vulnerabilities = []
        
        lines = output.splitlines()
        for line in lines:
            line = line.strip()
            if not line or line.startswith('-') or line.startswith('+'):
                continue
            
            # Buscar líneas que indican vulnerabilidades
            if any(indicator in line.lower() for indicator in [
                'cookie', 'header', 'vulnerable', 'security', 'ssl', 'certificate',
                'method', 'directory', 'file', 'script', 'server', 'banner'
            ]):
                vuln = {
                    'host': 'unknown',
                    'ip': 'unknown', 
                    'port': 'unknown',
                    'vuln_id': 'text_parsed',
                    'method': 'GET',
                    'uri': '/',
                    'description': line,
                    'severity': self._determine_severity(line),
                    'type': 'web_vulnerability'
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _extract_basic_findings(self, output: str) -> List[Dict[str, Any]]:
        """Extrae hallazgos básicos del output cuando otros métodos fallan"""
        vulnerabilities = []
        
        findings = {
            'Server Information': [],
            'SSL/TLS Issues': [], 
            'Cookie Issues': [],
            'Header Issues': [],
            'Security Issues': []
        }
        
        lines = output.splitlines()
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # Información del servidor
            if 'server:' in line.lower() or 'banner' in line.lower():
                findings['Server Information'].append(line)
            
            # Problemas SSL/TLS
            elif 'ssl' in line.lower() or 'certificate' in line.lower() or 'tls' in line.lower():
                findings['SSL/TLS Issues'].append(line)
            
            # Problemas de cookies
            elif 'cookie' in line.lower():
                findings['Cookie Issues'].append(line)
            
            # Problemas de headers
            elif 'header' in line.lower() or 'x-' in line.lower():
                findings['Header Issues'].append(line)
            
            # Otros problemas de seguridad
            elif any(term in line.lower() for term in ['vulnerable', 'security', 'breach', 'methods']):
                findings['Security Issues'].append(line)
        
        # Convertir hallazgos a formato de vulnerabilidad
        for category, items in findings.items():
            for item in items:
                vuln = {
                    'host': 'extracted',
                    'ip': 'extracted',
                    'port': 'extracted', 
                    'vuln_id': category.lower().replace(' ', '_'),
                    'method': 'SCAN',
                    'uri': '/',
                    'description': item,
                    'severity': self._determine_severity(item),
                    'type': 'web_finding',
                    'category': category
                }
                vulnerabilities.append(vuln)
        
        return vulnerabilities 