"""
Wrapper para CloudSploit - Cloud Security Auditing
"""

import json
import logging
from typing import Dict, List, Any
from dataclasses import dataclass

from aegis_pentest.utils.process_runner import get_process_runner
from aegis_pentest.utils.logger import get_logger


@dataclass
class CloudSploitResult:
    """Resultado de un análisis con CloudSploit"""
    target: str
    findings: List[Dict[str, Any]]
    cloud_provider: str
    scan_stats: Dict[str, Any]
    raw_output: str


class CloudSploitWrapper:
    """Wrapper para la herramienta CloudSploit"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('cloudsploit')
        self.logger = logging.getLogger(__name__)
        self.process_runner = get_process_runner()
        self.tool_logger = get_logger()
    
    def is_available(self) -> bool:
        """Verifica si CloudSploit está disponible"""
        return self.config.is_tool_available('cloudsploit')
    
    def should_run_against_target(self, target: str, target_type: str, context: Dict[str, Any] = None) -> bool:
        """Determina si CloudSploit debe ejecutarse contra el target"""
        # Solo ejecutar si se detectan servicios cloud o dominios cloud
        if target_type not in ['domain', 'ip']:
            return False
        
        # Verificar si el target parece ser de un proveedor cloud
        cloud_indicators = [
            'amazonaws.com', 'cloudfront.net', 'azurewebsites.net', 
            'azure.com', 'cloudapp.net', 'googleapis.com', 'gcp.com',
            'compute.google.com', 'storage.googleapis.com'
        ]
        
        is_cloud_target = any(indicator in target.lower() for indicator in cloud_indicators)
        
        # También verificar en contexto si hay información de servicios cloud
        if context:
            nmap_result = context.get('nmap_result')
            if nmap_result and hasattr(nmap_result, 'services'):
                for service in nmap_result.services:
                    service_info = str(service).lower()
                    if any(cloud in service_info for cloud in ['aws', 'azure', 'gcp', 'cloud']):
                        is_cloud_target = True
                        break
        
        if not is_cloud_target:
            self.logger.info("No se detectaron servicios cloud - saltando CloudSploit")
            return False
        
        # Verificar si hay credenciales configuradas
        if not self._has_cloud_credentials():
            self.logger.warning("Credenciales cloud no configuradas - CloudSploit limitado")
            return False
        
        return True
    
    async def scan_aws(self, region: str = 'us-east-1') -> CloudSploitResult:
        """Escanea configuración de AWS"""
        if not self.is_available():
            raise RuntimeError("CloudSploit no está disponible")
        
        self.logger.info(f"Iniciando auditoría AWS en región {region}")
        
        # Comando para CloudSploit AWS
        cmd = [
            'node',
            self.tool_config.get('path', './cloudsploit/index.js'),
            '--cloud', 'aws',
            '--region', region,
            '--format', 'json'
        ]
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="cloudsploit",
                command=cmd,
                target=f"aws-{region}",
                timeout=self.tool_config.get('timeout', 600)
            )
            
            if not process_result.success:
                raise RuntimeError(f"CloudSploit AWS falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            # Parsear resultados JSON
            findings = []
            try:
                results = json.loads(stdout)
                findings = self._parse_cloudsploit_results(results, 'aws')
            except json.JSONDecodeError:
                findings = self._parse_text_output(stdout, 'aws')
            
            scan_stats = {
                'total_findings': len(findings),
                'cloud_provider': 'aws',
                'region': region,
                'high_risk': len([f for f in findings if f.get('severity') == 'HIGH']),
                'medium_risk': len([f for f in findings if f.get('severity') == 'MEDIUM'])
            }
            
            result = CloudSploitResult(
                target=f"aws-{region}",
                findings=findings,
                cloud_provider='aws',
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Auditoría AWS completada: {len(findings)} hallazgos")
            return result
            
        except Exception as e:
            self.logger.error(f"Error en CloudSploit AWS: {str(e)}")
            raise
    
    async def scan_azure(self, subscription_id: str = None) -> CloudSploitResult:
        """Escanea configuración de Azure"""
        if not self.is_available():
            raise RuntimeError("CloudSploit no está disponible")
        
        self.logger.info("Iniciando auditoría Azure")
        
        cmd = [
            'node',
            self.tool_config.get('path', './cloudsploit/index.js'),
            '--cloud', 'azure',
            '--format', 'json'
        ]
        
        if subscription_id:
            cmd.extend(['--subscription', subscription_id])
        
        try:
            process_result = await self.process_runner.run_tool_async(
                tool_name="cloudsploit",
                command=cmd,
                target="azure",
                timeout=self.tool_config.get('timeout', 600)
            )
            
            if not process_result.success:
                raise RuntimeError(f"CloudSploit Azure falló: {process_result.error_message}")
            
            stdout = "\n".join(process_result.stdout_lines)
            
            findings = []
            try:
                results = json.loads(stdout)
                findings = self._parse_cloudsploit_results(results, 'azure')
            except json.JSONDecodeError:
                findings = self._parse_text_output(stdout, 'azure')
            
            scan_stats = {
                'total_findings': len(findings),
                'cloud_provider': 'azure',
                'subscription': subscription_id or 'default',
                'high_risk': len([f for f in findings if f.get('severity') == 'HIGH']),
                'medium_risk': len([f for f in findings if f.get('severity') == 'MEDIUM'])
            }
            
            result = CloudSploitResult(
                target="azure",
                findings=findings,
                cloud_provider='azure',
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en CloudSploit Azure: {str(e)}")
            raise
    
    def _parse_cloudsploit_results(self, results: Dict[str, Any], provider: str) -> List[Dict[str, Any]]:
        """Parsea los resultados JSON de CloudSploit"""
        findings = []
        
        # CloudSploit organiza resultados por categorías
        for category, checks in results.items():
            if isinstance(checks, dict):
                for check_name, check_result in checks.items():
                    if isinstance(check_result, dict) and check_result.get('status'):
                        
                        # Convertir resultado a formato estándar
                        finding = {
                            'id': f"cloudsploit_{category}_{check_name}",
                            'severity': self._map_cloudsploit_severity(check_result.get('status')),
                            'port': 'N/A',
                            'description': check_result.get('message', f"{category}: {check_name}")[:100],
                            'type': 'cloudsploit',
                            'category': category,
                            'check_name': check_name,
                            'cloud_provider': provider,
                            'resource': check_result.get('resource', 'N/A'),
                            'raw_data': check_result
                        }
                        findings.append(finding)
        
        return findings
    
    def _parse_text_output(self, output: str, provider: str) -> List[Dict[str, Any]]:
        """Parsea output de texto cuando no hay JSON disponible"""
        findings = []
        lines = output.splitlines()
        
        for line in lines:
            line = line.strip()
            
            # Buscar líneas que indiquen hallazgos
            if any(indicator in line.lower() for indicator in [
                'fail', 'warn', 'error', 'issue', 'vulnerability', 'misconfiguration'
            ]):
                
                severity = 'MEDIUM'
                if 'fail' in line.lower() or 'error' in line.lower():
                    severity = 'HIGH'
                elif 'warn' in line.lower():
                    severity = 'MEDIUM'
                else:
                    severity = 'LOW'
                
                finding = {
                    'id': f"cloudsploit_text_{len(findings) + 1}",
                    'severity': severity,
                    'port': 'N/A',
                    'description': line[:100],
                    'type': 'cloudsploit',
                    'cloud_provider': provider,
                    'raw_data': {'text_line': line}
                }
                findings.append(finding)
        
        return findings
    
    def _map_cloudsploit_severity(self, status: str) -> str:
        """Mapea el estado de CloudSploit a severidad estándar"""
        status_lower = status.lower()
        
        if status_lower in ['fail', 'error', 'critical']:
            return 'HIGH'
        elif status_lower in ['warn', 'warning', 'medium']:
            return 'MEDIUM'
        elif status_lower in ['pass', 'ok', 'good']:
            return 'INFO'
        else:
            return 'UNKNOWN'
    
    def _has_cloud_credentials(self) -> bool:
        """Verifica si hay credenciales cloud configuradas"""
        import os
        
        # Verificar credenciales AWS
        aws_creds = (
            os.environ.get('AWS_ACCESS_KEY_ID') or 
            os.environ.get('AWS_PROFILE') or
            os.path.exists(os.path.expanduser('~/.aws/credentials'))
        )
        
        # Verificar credenciales Azure
        azure_creds = (
            os.environ.get('AZURE_CLIENT_ID') or
            os.environ.get('AZURE_SUBSCRIPTION_ID')
        )
        
        # Verificar credenciales GCP
        gcp_creds = (
            os.environ.get('GOOGLE_APPLICATION_CREDENTIALS') or
            os.environ.get('GCLOUD_PROJECT')
        )
        
        return bool(aws_creds or azure_creds or gcp_creds)
    
    def get_supported_providers(self) -> List[str]:
        """Obtiene la lista de proveedores cloud soportados"""
        return ['aws', 'azure', 'gcp', 'oracle']
    
    def get_check_categories(self) -> Dict[str, List[str]]:
        """Obtiene las categorías de verificaciones disponibles"""
        return {
            'aws': [
                'EC2', 'S3', 'IAM', 'VPC', 'RDS', 'Lambda', 
                'CloudTrail', 'CloudWatch', 'ELB', 'Route53'
            ],
            'azure': [
                'Virtual Machines', 'Storage Accounts', 'Active Directory',
                'Network Security Groups', 'SQL Database', 'Key Vault'
            ],
            'gcp': [
                'Compute Engine', 'Cloud Storage', 'IAM',
                'VPC', 'Cloud SQL', 'Cloud Functions'
            ]
        } 