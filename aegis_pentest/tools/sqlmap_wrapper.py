"""
Wrapper para SQLMap - Detección de inyecciones SQL
"""

import asyncio
import logging
import subprocess
from typing import Dict, List, Any
from dataclasses import dataclass


@dataclass
class SqlMapResult:
    """Resultado de un escaneo SQLMap"""
    target: str
    injections: List[Dict[str, Any]]
    databases: List[str]
    scan_stats: Dict[str, Any]
    raw_output: str


class SqlMapWrapper:
    """Wrapper para la herramienta SQLMap"""
    
    def __init__(self, config):
        self.config = config
        self.tool_config = config.get_tool_config('sqlmap')
        self.logger = logging.getLogger(__name__)
    
    def is_available(self) -> bool:
        """Verifica si SQLMap está disponible"""
        return self.config.is_tool_available('sqlmap')
    
    async def scan(self, target: str, data: str = None, cookie: str = None, risk: int = 1, level: int = 1) -> SqlMapResult:
        """
        Ejecuta un escaneo con SQLMap
        
        Args:
            target: URL objetivo
            data: Datos POST a enviar
            cookie: Cookies para la sesión
            risk: Nivel de riesgo (1-3)
            level: Nivel de detalle (1-5)
            
        Returns:
            SqlMapResult: Resultado del escaneo
        """
        if not self.is_available():
            raise RuntimeError("SQLMap no está disponible")
        
        self.logger.info(f"Iniciando escaneo SQLMap de {target}")
        
        # Construir comando
        cmd = [
            self.tool_config.get('path', 'sqlmap'),
            '-u', target,
            '--batch',  # Modo no interactivo
            '--smart',  # Usar heurísticas inteligentes
            '--risk', str(risk),
            '--level', str(level),
            '--output-dir', '/tmp/sqlmap_output'
        ]
        
        # Agregar datos POST si se especifican
        if data:
            cmd.extend(['--data', data])
        
        # Agregar cookies si se especifican
        if cookie:
            cmd.extend(['--cookie', cookie])
        
        try:
            # Ejecutar comando
            loop = asyncio.get_event_loop()
            stdout, stderr = await loop.run_in_executor(
                None,
                self._run_sqlmap_command,
                cmd
            )
            
            # Parsear resultados
            injections = self._parse_sqlmap_output(stdout)
            databases = self._extract_databases(stdout)
            
            # Estadísticas
            scan_stats = {
                'total_injections': len(injections),
                'target': target,
                'risk_level': risk,
                'detail_level': level,
                'databases_found': len(databases)
            }
            
            result = SqlMapResult(
                target=target,
                injections=injections,
                databases=databases,
                scan_stats=scan_stats,
                raw_output=stdout
            )
            
            self.logger.info(f"Escaneo SQLMap completado: {len(injections)} inyecciones encontradas")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error en escaneo SQLMap: {str(e)}")
            raise
    
    def _run_sqlmap_command(self, cmd: List[str]) -> tuple:
        """Ejecuta el comando SQLMap de forma síncrona"""
        timeout = self.tool_config.get('timeout', 900)
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            
            return result.stdout, result.stderr
            
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Timeout de SQLMap ({timeout}s) excedido")
        except Exception as e:
            raise RuntimeError(f"Error ejecutando SQLMap: {str(e)}")
    
    def _parse_sqlmap_output(self, output: str) -> List[Dict[str, Any]]:
        """Parsea la salida de SQLMap para extraer inyecciones"""
        injections = []
        lines = output.splitlines()
        
        current_injection = None
        for line in lines:
            line = line.strip()
            
            # Detectar inicio de vulnerabilidad
            if 'is vulnerable' in line.lower() or 'injectable' in line.lower():
                if current_injection:
                    injections.append(current_injection)
                
                current_injection = {
                    'parameter': '',
                    'type': '',
                    'payload': '',
                    'dbms': '',
                    'severity': 'high',
                    'description': line
                }
            
            # Extraer información específica
            elif current_injection:
                if 'Parameter:' in line:
                    current_injection['parameter'] = line.split('Parameter:')[1].strip()
                elif 'Type:' in line:
                    current_injection['type'] = line.split('Type:')[1].strip()
                elif 'Payload:' in line:
                    current_injection['payload'] = line.split('Payload:')[1].strip()
                elif 'back-end DBMS:' in line:
                    current_injection['dbms'] = line.split('back-end DBMS:')[1].strip()
        
        # Agregar la última inyección si existe
        if current_injection:
            injections.append(current_injection)
        
        return injections
    
    def _extract_databases(self, output: str) -> List[str]:
        """Extrae la lista de bases de datos encontradas"""
        databases = []
        lines = output.splitlines()
        
        in_database_section = False
        for line in lines:
            line = line.strip()
            
            if 'available databases' in line.lower():
                in_database_section = True
                continue
            
            if in_database_section:
                if line.startswith('[*]') or line.startswith('-'):
                    db_name = line.replace('[*]', '').replace('-', '').strip()
                    if db_name and db_name not in databases:
                        databases.append(db_name)
                elif not line or line.startswith('['):
                    in_database_section = False
        
        return databases
    
    async def scan_form(self, target: str, form_data: Dict[str, str], cookie: str = None) -> SqlMapResult:
        """Escanea un formulario específico para inyecciones SQL"""
        # Convertir datos del formulario a formato POST
        data = '&'.join([f"{key}={value}" for key, value in form_data.items()])
        
        return await self.scan(target, data=data, cookie=cookie, risk=2, level=3)
    
    async def scan_get_parameter(self, target: str, parameter: str, cookie: str = None) -> SqlMapResult:
        """Escanea un parámetro GET específico"""
        if '?' not in target:
            target += f"?{parameter}=test"
        else:
            target += f"&{parameter}=test"
        
        return await self.scan(target, cookie=cookie, risk=2, level=2)
    
    async def comprehensive_scan(self, target: str, cookie: str = None) -> SqlMapResult:
        """Realiza un escaneo comprensivo con configuración agresiva"""
        return await self.scan(target, cookie=cookie, risk=3, level=5)
    
    def get_scan_profiles(self) -> Dict[str, Dict[str, Any]]:
        """Obtiene perfiles de escaneo predefinidos"""
        return {
            'basic': {
                'name': 'Escaneo Básico',
                'description': 'Escaneo rápido con bajo riesgo',
                'risk': 1,
                'level': 1,
                'duration': '5-15 minutos'
            },
            'thorough': {
                'name': 'Escaneo Detallado',
                'description': 'Escaneo completo con riesgo medio',
                'risk': 2,
                'level': 3,
                'duration': '15-30 minutos'
            },
            'aggressive': {
                'name': 'Escaneo Agresivo',
                'description': 'Escaneo exhaustivo con alto riesgo',
                'risk': 3,
                'level': 5,
                'duration': '30-60 minutos'
            }
        } 